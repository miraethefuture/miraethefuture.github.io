---
title: "Closures"
categories:
  - TIL
tags:
  - learning
  - 공부 기록
  - Swift
  - Closures
show_date: true
toc: true
toc_sticky: true
toc_label: "📂"
toc_icon: "kiwi-bird"
#header:
#  teaser: /assets/images/choose2.png
---

# 🚧
  Closures는 기능을 담고 있는 완전한 블락으로 코드 안에서 사용될 수 있습니다.  
  Constants와 Variables의 references를 찾아내고 담을 수 있습니다.
  이것을 *closing over* constants and variables한다고 합니다.

  Swift는 capturing과 관련된 모든 메모리 관리를 처리해줍니다.  

## Functions and Closures

  전역범위의 function 그리고 nested funtions는 모두 사실 특별한 케이스의 closures입니다.  
  클로저는 세가지 형태로 나눠집니다.  

  1. Global functions는 이름을 가지고 있지만 어떤 값도 capture하지 않는 클로저입니다.
  2. Nested functions는 이름을 가지고 있고 자신을 감싸고 있는 function의 값을 capture할 수 있는 클로저입니다.
  3. Closure expressions 주변의 값을 capture할 수 있는 가벼운 syntax로 쓰여진, 이름이 없는 클로저입니다.  

## Closure Expressions  

  Swift의 **closure expressions**는 간결하고 깔끔하도록 최적화된 syntax와 함께 명확한 스타일을 가지고 있습니다.  
  이 최적화는 아래의 네가지를 포함합니다.  

  1. 패러미터와 리턴 값의 타입을 문맥의 흐름으로부터 추론합니다.
  2. single-expressions closures로부터의 키워드로 표현되지 않은 returns
  3. 약칭으로 된 argument의 이름
  4. Trailing closure syntax 👷

  Closure expressions는 inline closures를 짧고 집중된 형태의 syntax로 작성하는 방식입니다.

  <div class="notice">
     <h4>💡</h4>
     <p>inline은 사용되기 전에 중간 변수에 할당되지 않고 바로 사용되는 것을 말합니다.
     </p>
  </div>  

  Closure expressions는 closures를 정확함과 의도를 잃지 않으면서 단축된 형태로 작성하기 위한 몇몇개의 syntax 최적화를 제공합니다.

### The Sorted Method  

  Swift의 standard library는 sorted(by:)를 제공합니다. 타입이 명확하게 밝혀진 값을 가지고 있는 배열을 정렬하는 메서드입니다. 주어진 sorting closure의 출력결과를 기반으로 배열의 값을 정렬합니다. 정렬하는 과정이 완료되면 sorted(by:) 메서드는 타입과 사이즈는 같지만 조건대로 정렬된 새로운 배열을 리턴합니다. 원래의 배열은 수정되지 않습니다.  

  아래의 closure expressions의 예제는 String type의 값을 가진 names라는 배열을 알파벳 순서의 반대로 정렬할 것입니다.

  ```swift
  let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
  ```
  sorted(by:)메서드는 배열의 contents와 같은 자료형의 arguments 두개를 받아들이는 closure를 가지고 있습니다. 그리고 값들이 정렬되면 첫번째 값이 두번째 값의 전, 또는 후에 나타나야 한다는 것을 알려주는 Bool 값을 리턴합니다. 이 sorting closure는 첫번째 값이 두번째 값 전에 나타나야 한다면 true를 리턴합니다. 그리고 반대 상황에서는 false를 리턴합니다.  

  이 예시는 String값의 배열을 정렬하므로 sorting closure는 (String, String) -> Bool 타입의 function이 필요합니다.  

#### The sorting closure: 방식1

  이 sorting closure를 제공하는 한 방식으로는, **function을 작성**하고 sorted(by:)메서드의 인자로 통과시키는 방법이 있습니다.

  ```swift
  fucn backward(_ s1: String, _ s2: String) -> Bool {
      return s1 > s2
  }
  var reversedNames = names.sorted(by: backward)
  // reversedNames = ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
  ```
  만약 첫번째 문자열(s1)이 두번째 문자열(s2)보다 크다면, backward function은 true를 리턴합니다. 이것은 정렬된 배열에서 s1이 s2전에 나타나야 한다는 것을 나타냅니다. 알파벳에서는 뒤로 갈수록 큰 값이기 때문에 알파벳의 역순으로 정렬됩니다.  

  위의 방법은 꼭 필요한 single expression function (a > b)를 작성한 긴 버전의 방법이었습니다.

#### The sorting closure: 방식2  

  **Closure Expression Syntax**를 이용해서 inline 방식으로 sorting closure를 작성하는 것이 더 나은 방식이 될 것입니다.  

  ```swift
  { ( parameters ) -> return type in
      statements
  }
  ```

  Closure expression syntax의 패러미터는 in-out 패러미터 둘다 될 수 있습니다. 하지만 default 값은 가질 수 없습니다. 아래의 예시는 closure expression 버전의 backward function입니다.

  ```swift
  reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
        return s1 > s2
  })
  ```

  위의 inline closure의 패러미터와 리턴 타입을 정의한 방식은 backward function의 정의한 방식과 똑같습니다. 둘다 (s1: String, s2: String) -> Bool 이라고 쓰였습니다. 하지만 inline closure expression에서는 { } 밖이 아니라 안에 작성되었다는 차이점이 있습니다. 그리고 바디 부분의 시작을 in 키워드로 알렸습니다. in 키워드는 클로저의 패러미터와 리턴 타입의 정의가 끝났다는 것을 알려주고 바디 부분이 시작된다는 것을 나타냅니다.  

#### Inferring Type From Context

  위의 sorting closure가 sorted(by:) 메서드의 argument로 통과되기 때문에 Swift는 sorting closure의 패러미터의 타입과 리턴 값의 타입을 추측할 수 있습니다. 그렇기 때문에 패러미터와 리턴 값의 타입은 작성될 필요가 없어집니다. 모든 타입들이 추측 가능해짐으로 return arrow(->)와 패러미터를 감싸는 괄호 또한 생략 가능해집니다.

  ```swift
  reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )
  ```
  Function이나 method에 closure를 통과시킬때는 언제나 패러미터 타입과 리턴 값의 타입을 추측하는 것이 가능합니다. 그렇기 때문에 function이나 method의 인자로써 inline closure을 사용할 때는 완전한 형태로 작성할 필요가 없어집니다.  

  그럼에도 불구하고, 원한다면 자료형을 명시할 수 있습니다. 만약 코드를 읽어야하는 사람들을 위해 모호한 부분을 피하고 싶다면 자료형을 명시하는 것은 좋은 방법이 될 것입니다.

#### Implicit Returns from Single-Expression closures

  Single-expression closures는 return 키워드를 생략하고 single expression의 결과를 리턴할 수 있습니다.

  ```swift
  reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )
  ```

#### Shorthand Argument Names  

  Swift는 inline closures의 argument 이름을 간단하게 전달하는 방법을 제공합니다. $0, $1, $2 등으로 클로저의 인자값을 나타낼 때 사용됩니다.  

  만약 closure expression에서 이 shorthand argument names를 사용한다면, 클로저의 argument list를 생략할 수 있습니다. shorthand argument names의 자료형은 사용되길 예상되는 function의 자료형으로부터 추측 가능하고, 가장 높은 수의 shorthand argument는 해당 클로저가 사용할 argument의 개수를 결정합니다. 이 closure expression의 전체가 바디부분으로 이루어져 있음으로 in 키워드도 생략이 가능합니다.

  ```swift
  reversedNames = names.sorted(by: { $0 > $1 } )
  ```

  위의 예시에서, $0은 첫번째 String argument를 $1 은 두번째 String argument를 나타냅니다. $1이 가장 높은 숫자의 shorthand argument라는 것은 해당 클로저가 두개의 arguments를 사용하는 것을 나타냅니다.

#### Operator Methods  

  심지어 더 짧은 방식으로 closure expression을 작성할 수 있습니다. Swift의 String type은 greater-than operator(>)의 특정 이행 메서드를 가지고 있습니다. 이 메서드의 패러미터 타입과 리턴 타입이 sorted(by:)메서드에게 필요한 패러미터 타입, 그리고 리턴 타입과 정확히 일치하기 때문에 단순히 > 하나만 통과시키더라도 Swift는 String 타입의 string-specific implementation을 사용하길 원한다는 것을 추론할 수 있을 것입니다.

  ```swift
  reversedNames = names.sorted(by: > )
  ```

#### Trailing closures  

  Closure expression을 어떤 function의 마지막 argument로 통과시켜야 하고 그 closure expression이 길다면, 해당 closure expression을 trailing closure로 작성하는 것이 유용한 방법이 될 수 있습니다. 사용하는 trailing closure가 function의 argument이더라도  function call의 () 뒤에 trailing closure을 작성합니다. 이 trailing closure syntax를 사용할때는 function을 호출할 때 첫번째 closure의 argument label (closure: // 같은)은 작성하지 않습니다. 아래의 예제는 single trailing closure를 사용하고 있지만 하나의 function call이 여러개의 trailing closures를 포함할 수 잇습니다.

  ```swift
  func someFunctionThatTakesAClosure(closure: () -> Void) {
      // funtion body 부분
  }

  // trailing closure를 사용하지 않고 위의 function을 호출하는 방법
  someFunctionThatTakesAClosure(closure: {
      // closure의 바디 부분
    })

  // trailing closure 사용
  someFunctionThatTakesAClosure() {
      // trailing closure의 바디 부분
  }  
  ```

  위에서 작성해보았던 string-sorting closure도 sorted(by:)메서드의 괄호 밖에서 trailing closure로 작성될 수 있습니다.

  ```swift
  reversedNames = names.sorted() { $0 > $1 }
  ```

  만약 closure expression이 function이나 method의 유일한 argument이고 trailing closure로 작성한다면 ()를 생략할 수 있습니다.

  ```swift
  reversedNames = names.sorted { $0 > $1 }
  ```

  Trailing closures는 어떤 closure가 한 줄 위에 inline 형식으로 작성이 어려울 정도로 길이가 길 때 가장 유용하게 사용됩니다. 예를 들어, Swift의 Array type은 map(_:) 메서드를 가지고 있습니다. 이 메서드는 하나의 closure expression을 argument로 가집니다. 해당 클로저는 배열의 각 아이템마다 한번씩 호출됩니다. 그리고 해당 item을 다르게 mapped된 value를 리턴합니다. (다른 타입일 수 있습니다.) map(\_:) 메서드에 통과시킬 클로저 안에 코드를 작성함으로써 mapping의 종류와 리턴 값의 타입을 특정 짓습니다.  

  주어진 클로저를 배열의 각 요소마다 적용한 뒤에, map(_:) 메서드는 새로 mapped된 값을 원래의 연결된 배열의 값과 같은 순서로 담고 있는 새 배열을 리턴합니다.

  아래 예시는 map(_:)메서드와 trailing closure를 사용하여 Int 타입의 값을 가지고 있는 배열을 String 타입의 값을 가진 배열로 변환하는 방법을 설명합니다. 배열 [16, 58, 510]은 새로운 배열인 ["OneSix", "FiveEight", "FiveOneZero"]를 생성하기 위해 사용되었습니다.

  ```swift
  let digitNames = [
      0: "Zero", 1: "One", 2: "Two", 3: "Three", 4: "Four",
      5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
  ]
  let numbers = [16, 58, 510]
  ```  
  위의 코드는 숫자와 영어 버전의 숫자 이름을 맵핑한 dictionary를 생성합니다. 문자열 배열로 변환될 numbers 배열도 정의합니다.  

  Array 타입의 map(_:)메서드에 trailing clousre로 closure expression을 통과시켜 numbers 배열을 문자열 배열로 만들어 봅니다.  

  ```swift
  let string = numbers.map { (number) -> String in
      var number = number
      var output = ""
      repeat {
          output = digitNames[number % 10]! + output
          number /= 10
      } while number > 0
      return output
  }
  // strings 상수의 타입은 [String]으로 추론됩니다.
  // 값은 ["OneSix", "FiveEight", "FiveOneZero"] 입니다.
  ```
  map(_:) 메서드는 numbers 배열안의 각 item마다 closure expression을 호출합니다. 맵핑될 배열의 값으로부터 타입을 추론할 수 있기 때문에 클로저의 인풋 패러미터인 number의 타입을 특정지을 필요가 없습니다.

  위의 예시에서 var number는 초기값으로 closure의 패러미터인 number를 가집니다. 이렇게 함으로써 클로저의 바디안에서 그 값이 변경될 수 있게 됩니다. (function 또는 closures의 패러미터는 언제나 constants 이기 때문에) 이 closure expression은 또한 mapped output 배열안의 담길 값의 타입을 나타내기위해 리턴 타입을 String으로 특정 지었습니다.  

  위의 closure expression은 호출될 때마다 ouput이라는 이름의 문자열을 만듭니다. 이것은 remainder operator (number % 10)을 사용하여 number의 마지막 수를 찾아내고 이렇게 찾아낸 숫자를 digitNames dictionary에서 키 값으로 가지는 값을 찾기 위해 사용합니다. 그리고 찾은 문자열 값을 현재 output 문자열과 합칩니다. 이 클로저는 0보다 큰 어떤 숫자를 문자 형식으로 나타내기 위해 사용될 수 있습니다. 클로저가 output 값으로 만들어진 새로운 배열이 map(_:) 메서드로부터 만들어집니다.  

  위의 예시에서의 trailing closure의 사용은 클로저가 사용된 function 바로 뒤에 클로저의 기능을 바로 요약해서 나타내줍니다. map(_:)의 괄호로 감쌀 필요가 없습니다.  

## Capturing Values  

  클로저는 constants나 variables가 정의된 곳 안에서 constants나 variables를 *capture*할 수 있습니다. 그리고나서 해당 클로저의 바디 안에서 캡쳐한 해당 값을 조회하거나 수정할 수 있습니다. 심지어 해당 constants나 variables가 더이상 원래의 범위안에 존재하지 않더라도 클로저는 해당 값을 조회, 수정할 수 있습니다.  

  Swift에서 값을 capture할 수 있는 가장 간단한 형태의 클로저는 바로 다른 function의 바디부분에 작성된 ested function 입니다. nested function은 바깥쪽 function의 argument를 capture할 수 있고 바깥쪽 function 안에 정의된 constants나 variables를 capture할 수 있습니다.
