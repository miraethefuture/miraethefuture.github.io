I"r<h1>🚧</h1>
<p>Closures는 기능을 담고 있는 완전한 블락으로 코드 안에서 사용될 수 있습니다.<br />
  Constants와 Variables의 references를 찾아내고 담을 수 있습니다.
  이것을 <em>closing over</em> constants and variables한다고 합니다.</p>

<p>Swift는 capturing과 관련된 모든 메모리 관리를 처리해줍니다.</p>

<h2 id="functions-and-closures">Functions and Closures</h2>

<p>전역범위의 function 그리고 nested funtions는 모두 사실 특별한 케이스의 closures입니다.<br />
  클로저는 세가지 형태로 나눠집니다.</p>

<ol>
  <li>Global functions는 이름을 가지고 있지만 어떤 값도 capture하지 않는 클로저입니다.</li>
  <li>Nested functions는 이름을 가지고 있고 자신을 감싸고 있는 function의 값을 capture할 수 있는 클로저입니다.</li>
  <li>Closure expressions 주변의 값을 capture할 수 있는 가벼운 syntax로 쓰여진, 이름이 없는 클로저입니다.</li>
</ol>

<p>Swift의 <strong>closure expressions</strong>는 간결하고 깔끔하도록 최적화된 syntax와 함께 명확한 스타일을 가지고 있습니다.<br />
  이 최적화는 아래의 네가지를 포함합니다.</p>

<ol>
  <li>패러미터와 리턴 값의 타입을 문맥의 흐름으로부터 추론합니다.</li>
  <li>single-expressions closures로부터의 키워드로 표현되지 않은 returns</li>
  <li>약칭으로 된 argument의 이름</li>
  <li>Trailing closure syntax 👷</li>
</ol>

<h3 id="closure-expressions">Closure Expressions</h3>

<p>Closure expressions는 inline closures를 짧고 집중된 형태의 syntax로 작성하는 방식입니다.</p>

<div class="notice">
     <h4>💡</h4>
     <p>inline은 사용되기 전에 중간 변수에 할당되지 않고 바로 사용되는 것을 말합니다.
     </p>
  </div>

<p>Closure expressions는 closures를 정확함과 의도를 잃지 않으면서 단축된 형태로 작성하기 위한 몇몇개의 syntax 최적화를 제공합니다.</p>

<h3 id="the-sorted-method">The Sorted Method</h3>

<p>Swift의 standard library는 sorted(by:)를 제공합니다. 타입이 명확하게 밝혀진 값을 가지고 있는 배열을 정렬하는 메서드입니다. 주어진 sorting closure의 출력결과를 기반으로 배열의 값을 정렬합니다. 정렬하는 과정이 완료되면 sorted(by:) 메서드는 타입과 사이즈는 같지만 조건대로 정렬된 새로운 배열을 리턴합니다. 원래의 배열은 수정되지 않습니다.</p>

<p>아래의 closure expressions의 예제는 String type의 값을 가진 names라는 배열을 알파벳 순서의 반대로 정렬할 것입니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">let</span> <span class="nv">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Chris"</span><span class="p">,</span> <span class="s">"Alex"</span><span class="p">,</span> <span class="s">"Ewa"</span><span class="p">,</span> <span class="s">"Barry"</span><span class="p">,</span> <span class="s">"Daniella"</span><span class="p">]</span>
</code></pre></div></div>
<p>sorted(by:)메서드는 배열의 contents와 같은 자료형의 arguments 두개를 받아들이는 closure를 가지고 있습니다. 그리고 값들이 정렬되면 첫번째 값이 두번째 값의 전, 또는 후에 나타나야 한다는 것을 알려주는 Bool 값을 리턴합니다. 이 sorting closure는 첫번째 값이 두번째 값 전에 나타나야 한다면 true를 리턴합니다. 그리고 반대 상황에서는 false를 리턴합니다.</p>

<p>이 예시는 String값의 배열을 정렬하므로 sorting closure는 (String, String) -&gt; Bool 타입의 function이 필요합니다.</p>

<h4 id="sorting-closures-1">sorting closures: 1</h4>

<p>이 sorting closure를 제공하는 한 방식으로는, function을 작성하고 sorted(by:)메서드의 인자로 통과시키는 방법이 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">fucn</span> <span class="nf">backward</span><span class="p">(</span><span class="n">_</span> <span class="nv">s1</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">s2</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span>
  <span class="p">}</span>
  <span class="k">var</span> <span class="nv">reversedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">backward</span><span class="p">)</span>
  <span class="c1">// reversedNames = ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</span>
</code></pre></div></div>
<p>만약 첫번째 문자열(s1)이 두번째 문자열(s2)보다 크다면, backward function은 true를 리턴합니다. 이것은 정렬된 배열에서 s1이 s2전에 나타나야 한다는 것을 나타냅니다. 알파벳에서는 뒤로 갈수록 큰 값이기 때문에 알파벳의 역순으로 정렬됩니다.</p>

<p>위의 방법은 꼭 필요한 single expression function (a &gt; b)를 작성한 긴 버전의 방법이었습니다.</p>

<h4 id="sorting-closure-2">sorting closure: 2</h4>

<p><strong>Closure Expression Syntax</strong>를 이용해서 inline 방식으로 sorting closure를 작성하는 것이 더 나은 방식이 될 것입니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">{</span> <span class="p">(</span> <span class="n">parameters</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="k">return</span> <span class="n">type</span> <span class="k">in</span>
      <span class="n">statements</span>
  <span class="p">}</span>
</code></pre></div></div>
:ET