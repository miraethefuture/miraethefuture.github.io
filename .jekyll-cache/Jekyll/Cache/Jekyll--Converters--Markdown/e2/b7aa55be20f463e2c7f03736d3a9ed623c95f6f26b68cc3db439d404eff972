I"BO<h1>🚧</h1>
<p>Closures는 기능을 담고 있는 완전한 블락으로 코드 안에서 사용될 수 있습니다.<br />
  Constants와 Variables의 references를 찾아내고 담을 수 있습니다.
  이것을 <em>closing over</em> constants and variables한다고 합니다.</p>

<p>Swift는 capturing과 관련된 모든 메모리 관리를 처리해줍니다.</p>

<h2 id="functions-and-closures">Functions and Closures</h2>

<p>전역범위의 function 그리고 nested funtions는 모두 사실 특별한 케이스의 closures입니다.<br />
  클로저는 세가지 형태로 나눠집니다.</p>

<ol>
  <li>Global functions는 이름을 가지고 있지만 어떤 값도 capture하지 않는 클로저입니다.</li>
  <li>Nested functions는 이름을 가지고 있고 자신을 감싸고 있는 function의 값을 capture할 수 있는 클로저입니다.</li>
  <li>Closure expressions 주변의 값을 capture할 수 있는 가벼운 syntax로 쓰여진, 이름이 없는 클로저입니다.</li>
</ol>

<p>Swift의 <strong>closure expressions</strong>는 간결하고 깔끔하도록 최적화된 syntax와 함께 명확한 스타일을 가지고 있습니다.<br />
  이 최적화는 아래의 네가지를 포함합니다.</p>

<ol>
  <li>패러미터와 리턴 값의 타입을 문맥의 흐름으로부터 추론합니다.</li>
  <li>single-expressions closures로부터의 키워드로 표현되지 않은 returns</li>
  <li>약칭으로 된 argument의 이름</li>
  <li>Trailing closure syntax 👷</li>
</ol>

<h3 id="closure-expressions">Closure Expressions</h3>

<p>Closure expressions는 inline closures를 짧고 집중된 형태의 syntax로 작성하는 방식입니다.</p>

<div class="notice">
     <h4>💡</h4>
     <p>inline은 사용되기 전에 중간 변수에 할당되지 않고 바로 사용되는 것을 말합니다.
     </p>
  </div>

<p>Closure expressions는 closures를 정확함과 의도를 잃지 않으면서 단축된 형태로 작성하기 위한 몇몇개의 syntax 최적화를 제공합니다.</p>

<h3 id="the-sorted-method">The Sorted Method</h3>

<p>Swift의 standard library는 sorted(by:)를 제공합니다. 타입이 명확하게 밝혀진 값을 가지고 있는 배열을 정렬하는 메서드입니다. 주어진 sorting closure의 출력결과를 기반으로 배열의 값을 정렬합니다. 정렬하는 과정이 완료되면 sorted(by:) 메서드는 타입과 사이즈는 같지만 조건대로 정렬된 새로운 배열을 리턴합니다. 원래의 배열은 수정되지 않습니다.</p>

<p>아래의 closure expressions의 예제는 String type의 값을 가진 names라는 배열을 알파벳 순서의 반대로 정렬할 것입니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">let</span> <span class="nv">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Chris"</span><span class="p">,</span> <span class="s">"Alex"</span><span class="p">,</span> <span class="s">"Ewa"</span><span class="p">,</span> <span class="s">"Barry"</span><span class="p">,</span> <span class="s">"Daniella"</span><span class="p">]</span>
</code></pre></div></div>
<p>sorted(by:)메서드는 배열의 contents와 같은 자료형의 arguments 두개를 받아들이는 closure를 가지고 있습니다. 그리고 값들이 정렬되면 첫번째 값이 두번째 값의 전, 또는 후에 나타나야 한다는 것을 알려주는 Bool 값을 리턴합니다. 이 sorting closure는 첫번째 값이 두번째 값 전에 나타나야 한다면 true를 리턴합니다. 그리고 반대 상황에서는 false를 리턴합니다.</p>

<p>이 예시는 String값의 배열을 정렬하므로 sorting closure는 (String, String) -&gt; Bool 타입의 function이 필요합니다.</p>

<h4 id="the-sorting-closure-방식1">The sorting closure: 방식1</h4>

<p>이 sorting closure를 제공하는 한 방식으로는, <strong>function을 작성</strong>하고 sorted(by:)메서드의 인자로 통과시키는 방법이 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">fucn</span> <span class="nf">backward</span><span class="p">(</span><span class="n">_</span> <span class="nv">s1</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">s2</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span>
  <span class="p">}</span>
  <span class="k">var</span> <span class="nv">reversedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">backward</span><span class="p">)</span>
  <span class="c1">// reversedNames = ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</span>
</code></pre></div></div>
<p>만약 첫번째 문자열(s1)이 두번째 문자열(s2)보다 크다면, backward function은 true를 리턴합니다. 이것은 정렬된 배열에서 s1이 s2전에 나타나야 한다는 것을 나타냅니다. 알파벳에서는 뒤로 갈수록 큰 값이기 때문에 알파벳의 역순으로 정렬됩니다.</p>

<p>위의 방법은 꼭 필요한 single expression function (a &gt; b)를 작성한 긴 버전의 방법이었습니다.</p>

<h4 id="the-sorting-closure-방식2">The sorting closure: 방식2</h4>

<p><strong>Closure Expression Syntax</strong>를 이용해서 inline 방식으로 sorting closure를 작성하는 것이 더 나은 방식이 될 것입니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">{</span> <span class="p">(</span> <span class="n">parameters</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="k">return</span> <span class="n">type</span> <span class="k">in</span>
      <span class="n">statements</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Closure expression syntax의 패러미터는 in-out 패러미터 둘다 될 수 있습니다. 하지만 default 값은 가질 수 없습니다. 아래의 예시는 closure expression 버전의 backward function입니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">reversedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="nv">s1</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">s2</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span>
        <span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span>
  <span class="p">})</span>
</code></pre></div></div>

<p>위의 inline closure의 패러미터와 리턴 타입을 정의한 방식은 backward function의 정의한 방식과 똑같습니다. 둘다 (s1: String, s2: String) -&gt; Bool 이라고 쓰였습니다. 하지만 inline closure expression에서는 { } 밖이 아니라 안에 작성되었다는 차이점이 있습니다. 그리고 바디 부분의 시작을 in 키워드로 알렸습니다. in 키워드는 클로저의 패러미터와 리턴 타입의 정의가 끝났다는 것을 알려주고 바디 부분이 시작된다는 것을 나타냅니다.</p>

<h4 id="inferring-type-from-context">Inferring Type From Context</h4>

<p>위의 sorting closure가 sorted(by:) 메서드의 argument로 통과되기 때문에 Swift는 sorting closure의 패러미터의 타입과 리턴 값의 타입을 추측할 수 있습니다. 그렇기 때문에 패러미터와 리턴 값의 타입은 작성될 필요가 없어집니다. 모든 타입들이 추측 가능해짐으로 return arrow(-&gt;)와 패러미터를 감싸는 괄호 또한 생략 가능해집니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">reversedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="p">{</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="k">in</span> <span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span> <span class="p">}</span> <span class="p">)</span>
</code></pre></div></div>
<p>Function이나 method에 closure를 통과시킬때는 언제나 패러미터 타입과 리턴 값의 타입을 추측하는 것이 가능합니다. 그렇기 때문에 function이나 method의 인자로써 inline closure을 사용할 때는 완전한 형태로 작성할 필요가 없어집니다.</p>

<p>그럼에도 불구하고, 원한다면 자료형을 명시할 수 있습니다. 만약 코드를 읽어야하는 사람들을 위해 모호한 부분을 피하고 싶다면 자료형을 명시하는 것은 좋은 방법이 될 것입니다.</p>

<h4 id="implicit-returns-from-single-expression-closures">Implicit Returns from Single-Expression closures</h4>

<p>Single-expression closures는 return 키워드를 생략하고 single expression의 결과를 리턴할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">reversedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="p">{</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="k">in</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span> <span class="p">}</span> <span class="p">)</span>
</code></pre></div></div>

<h4 id="shorthand-argument-names">Shorthand Argument Names</h4>

<p>Swift는 inline closures의 argument 이름을 간단하게 전달하는 방법을 제공합니다. $0, $1, $2 등으로 클로저의 인자값을 나타낼 때 사용됩니다.</p>

<p>만약 closure expression에서 이 shorthand argument names를 사용한다면, 클로저의 argument list를 생략할 수 있습니다. shorthand argument names의 자료형은 사용되길 예상되는 function의 자료형으로부터 추측 가능하고, 가장 높은 수의 shorthand argument는 해당 클로저가 사용할 argument의 개수를 결정합니다. 이 closure expression의 전체가 바디부분으로 이루어져 있음으로 in 키워드도 생략이 가능합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">reversedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span> <span class="p">)</span>
</code></pre></div></div>

<p>위의 예시에서, $0은 첫번째 String argument를 $1 은 두번째 String argument를 나타냅니다. $1이 가장 높은 숫자의 shorthand argument라는 것은 해당 클로저가 두개의 arguments를 사용하는 것을 나타냅니다.</p>

<h4 id="operator-methods">Operator Methods</h4>

<p>심지어 더 짧은 방식으로 closure expression을 작성할 수 있습니다. Swift의 String type은 greater-than operator(&gt;)의 특정 이행 메서드를 가지고 있습니다. 이 메서드의 패러미터 타입과 리턴 타입이 sorted(by:)메서드에게 필요한 패러미터 타입, 그리고 리턴 타입과 정확히 일치하기 때문에 단순히 &gt; 하나만 통과시키더라도 Swift는 String 타입의 string-specific implementation을 사용하길 원한다는 것을 추론할 수 있을 것입니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">reversedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="o">&gt;</span> <span class="p">)</span>
</code></pre></div></div>

<h4 id="trailing-closures">Trailing closures</h4>

<p>Closure expression을 어떤 function의 마지막 argument로 통과시켜야 하고 그 closure expression이 길다면, 해당 closure expression을 trailing closure로 작성하는 것이 유용한 방법이 될 수 있습니다. 사용하는 trailing closure가 function의 argument이더라도  function call의 () 뒤에 trailing closure을 작성합니다. 이 trailing closure syntax를 사용할때는 function을 호출할 때 첫번째 closure의 argument label (closure: // 같은)은 작성하지 않습니다. 아래의 예제는 single trailing closure를 사용하고 있지만 하나의 function call이 여러개의 trailing closures를 포함할 수 잇습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">func</span> <span class="nf">someFunctionThatTakesAClosure</span><span class="p">(</span><span class="nv">closure</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// funtion body 부분</span>
  <span class="p">}</span>

  <span class="c1">// trailing closure를 사용하지 않고 위의 function을 호출하는 방법</span>
  <span class="nf">someFunctionThatTakesAClosure</span><span class="p">(</span><span class="nv">closure</span><span class="p">:</span> <span class="p">{</span>
      <span class="c1">// closure의 바디 부분</span>
    <span class="p">})</span>

  <span class="c1">// trailing closure 사용</span>
  <span class="nf">someFunctionThatTakesAClosure</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// trailing closure의 바디 부분</span>
  <span class="p">}</span>  
</code></pre></div></div>

<p>위에서 작성해보았던 string-sorting closure도 sorted(by:)메서드의 괄호 밖에서 trailing closure로 작성될 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">reversedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span>
</code></pre></div></div>

<p>만약 closure expression이 function이나 method의 유일한 argument이고 trailing closure로 작성한다면 ()를 생략할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">reversedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">sorted</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span>
</code></pre></div></div>

<p>Trailing closures는 어떤 closure가 한 줄 위에 inline 형식으로 작성이 어려울 정도로 길이가 길 때 가장 유용하게 사용됩니다. 예를 들어, Swift의 Array type은 map(_:) 메서드를 가지고 있습니다. 이 메서드는 하나의 closure expression을 argument로 가집니다. 해당 클로저는 배열의 각 아이템마다 한번씩 호출됩니다. 그리고 두개로 나뉘어진 mapped value를 리턴합니다.</p>

<p>아래 예시는 map(_:)메서드와 trailing closure를 사용하여 Int 타입의 값을 가지고 있는 배열을 String 타입의 값을 가진 배열로 변환하는 방법을 설명합니다. 배열 [16, 58, 510]은 새로운 배열인 [“OneSix”, “FiveEight”, “FiveOneZero”]를 생성하기 위해 사용되었습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">let</span> <span class="nv">digitNames</span> <span class="o">=</span> <span class="p">[</span>
      <span class="mi">0</span><span class="p">:</span> <span class="s">"Zero"</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">"One"</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s">"Two"</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s">"Three"</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="s">"Four"</span><span class="p">,</span>
      <span class="mi">5</span><span class="p">:</span> <span class="s">"Five"</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span> <span class="s">"Six"</span><span class="p">,</span> <span class="mi">7</span><span class="p">:</span> <span class="s">"Seven"</span><span class="p">,</span> <span class="mi">8</span><span class="p">:</span> <span class="s">"Eight"</span><span class="p">,</span> <span class="mi">9</span><span class="p">:</span> <span class="s">"Nine"</span>
  <span class="p">]</span>
  <span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">510</span><span class="p">]</span>
</code></pre></div></div>
<p>위의 코드는 숫자와 영어 버전의 숫자 이름을 맵핑한 dictionary를 생성합니다. 문자열 배열로 변환될 numbers 배열도 정의합니다.</p>

<p>Array 타입의 map(_:)메서드에 trailing clousre로 closure expression을 통과시켜 numbers 배열을 문자열 배열로 만들어 봅니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">let</span> <span class="nv">string</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="k">in</span>
      <span class="k">var</span> <span class="nv">number</span> <span class="o">=</span> <span class="n">number</span>
      <span class="k">var</span> <span class="nv">output</span> <span class="o">=</span> <span class="s">""</span>
      <span class="k">repeat</span> <span class="p">{</span>
          <span class="n">output</span> <span class="o">=</span> <span class="n">digitNames</span><span class="p">[</span><span class="kt">Number</span> <span class="o">%</span> <span class="mi">10</span><span class="p">]</span><span class="o">!</span> <span class="o">+</span> <span class="n">output</span>
          <span class="n">number</span> <span class="o">/=</span> <span class="mi">10</span>
      <span class="p">}</span> <span class="k">while</span> <span class="n">number</span> <span class="o">&gt;</span> <span class="mi">0</span>
      <span class="k">return</span> <span class="n">output</span>
  <span class="p">}</span>
  <span class="c1">// strings 상수의 타입은 [String]으로 추론됩니다.</span>
  <span class="c1">// 값은 ["OneSix", "FiveEight", "FiveOneZero"] 입니다.</span>
</code></pre></div></div>
:ET