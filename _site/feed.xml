<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-10-03T22:55:06+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html"> Jung Mirae</title><subtitle></subtitle><author><name>Mirae</name></author><entry><title type="html">로그인 기능 구현하기</title><link href="http://localhost:4000/til/2024-10-03-login.html" rel="alternate" type="text/html" title="로그인 기능 구현하기" /><published>2024-10-03T00:00:00+09:00</published><updated>2024-10-03T00:00:00+09:00</updated><id>http://localhost:4000/til/login</id><content type="html" xml:base="http://localhost:4000/til/2024-10-03-login.html"><![CDATA[<h1 id="구글-로그인">구글 로그인</h1>

<h2 id="환경설정">환경설정</h2>

<p><a href="https://developers.google.com/identity/sign-in/ios/start-integrating">🔗 Get started with Google Sign-In for iOS and macOS</a></p>

<ul>
  <li>CocoaPods나 SPM으로 Google Sign-In을 프로젝트에 추가합니다.</li>
  <li>OAuth client ID를 생성합니다.</li>
  <li>OAuth server client ID를 생성합니다. 대부분의 앱들은 로그인한 유저의 정보를 백엔드 서버로 보내야 합니다. 유저의 정보를 안전하게 백엔드 서버로 보내기 위해 ID token을 사용합니다. 유저의 ID token을 받기 위해서는 서버 클라이언트 ID인 두번째 클라이언트 ID가 필요합니다. 서버 클라이언트 ID를 얻기 위해 웹 어플리케이션 타입의 OAuth client ID를 생성합니다.</li>
</ul>

<p>⬆️ 윗 부분까지는 진행 완료. (서버 클라이언트 ID는 백엔드 개발자님께서 생성해주심)</p>

<h3 id="xcode-프로젝트-설정하기">Xcode 프로젝트 설정하기</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// OAuth client ID</span>
<span class="o">&lt;</span><span class="n">key</span><span class="o">&gt;</span><span class="kt">GIDClientID</span><span class="o">&lt;/</span><span class="n">key</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="kt">YOUR_IOS_CLIENT_ID</span><span class="o">&lt;/</span><span class="n">string</span><span class="o">&gt;</span>

<span class="c1">// OAuth server client ID</span>
<span class="o">&lt;</span><span class="n">key</span><span class="o">&gt;</span><span class="kt">GIDServerClientID</span><span class="o">&lt;/</span><span class="n">key</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="kt">YOUR_SERVER_CLIENT_ID</span><span class="o">&lt;/</span><span class="n">string</span><span class="o">&gt;</span>

<span class="c1">// Custom URL Scheme</span>
<span class="o">&lt;</span><span class="n">key</span><span class="o">&gt;</span><span class="kt">CFBundleURLTypes</span><span class="o">&lt;/</span><span class="n">key</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">array</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">dict</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">key</span><span class="o">&gt;</span><span class="kt">CFBundleURLSchemes</span><span class="o">&lt;/</span><span class="n">key</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">array</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="kt">YOUR_DOT_REVERSED_IOS_CLIENT_ID</span><span class="o">&lt;/</span><span class="n">string</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">array</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="n">dict</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">array</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>위와 같이 OAuth client ID / OAuth server client ID / Custom URL Scheme을 설정합니다.<br />
(보안을 위해 Config 파일에 값을 저장하였습니다.)</p>

<h2 id="구현">구현</h2>

<p><a href="https://developers.google.com/identity/sign-in/ios/sign-in">🔗 Integrating Google Sign-In into your iOS or macOS app</a><br />
<a href="https://developers.google.com/identity/sign-in/ios/sample-app">🔗 Try iOS Sample App</a></p>

<hr />

<h3 id="1-handle-the-authentication-redirect-url">1. Handle the authentication redirect URL</h3>

<p>AppDelegate에 아래 메서드를 추가하고, GIDSignIn의 handle url 메서드를 호출하는 코드를 추가합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">application</span><span class="p">(</span><span class="n">_</span> <span class="nv">app</span><span class="p">:</span> <span class="kt">UIApplication</span><span class="p">,</span> <span class="kd">open</span> <span class="nv">url</span><span class="p">:</span> <span class="kt">URL</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="p">[</span><span class="kt">UIApplication</span><span class="o">.</span><span class="kt">OpenURLOptionsKey</span> <span class="p">:</span> <span class="kt">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:])</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">handled</span><span class="p">:</span> <span class="kt">Bool</span>
    <span class="n">handled</span> <span class="o">=</span> <span class="kt">GIDSignIn</span><span class="o">.</span><span class="n">sharedInstance</span><span class="o">.</span><span class="nf">handle</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">handled</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="c1">// Handle other custom URL types.</span>
    
    <span class="c1">// If not handled by this app, return false.</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2-attempt-to-restore-the-users-sign-in-state">2. Attempt to restore the user’s sign-in state</h3>

<p>앱이 시작될 때, restorePreviousSignInWithCallback를 호출하여 이미 구글로 로그인을 했던 사용자의 sign-in 상태를 복구합니다. 로그인 상태가 복구되기 때문에 사용자가 앱을 사용할때마다 다시 로그인하지 않아도 됩니다. (사용자가 로그아웃하지 않았다면)</p>

<p><b>application(application:didFinishLaunchingWithOptions:)</b>에서 <b>restorePreviousSignIn</b>의 결과값을 사용하여, 처음 앱이 열렸을 때 어떤 뷰를 보여줄지 결정할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">application</span><span class="p">(</span><span class="n">_</span> <span class="nv">application</span><span class="p">:</span> <span class="kt">UIApplication</span><span class="p">,</span> <span class="n">didFinishLaunchingWithOptions</span> <span class="nv">launchOptions</span><span class="p">:</span> <span class="p">[</span><span class="kt">UIApplication</span><span class="o">.</span><span class="kt">LaunchOptionsKey</span><span class="p">:</span> <span class="kt">Any</span><span class="p">]?)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="c1">// Override point for customization after application launch.</span>
    <span class="kt">GIDSignIn</span><span class="o">.</span><span class="n">sharedInstance</span><span class="o">.</span><span class="n">restorePreviousSignIn</span> <span class="p">{</span> <span class="n">user</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
        <span class="k">if</span> <span class="n">error</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="n">user</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="c1">// Show the app's signed-out state.</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Show the app's signed-in state.</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Mirae</name></author><category term="TIL" /><summary type="html"><![CDATA[구글 로그인]]></summary></entry><entry><title type="html">Create a more responsive media app (WWDC)</title><link href="http://localhost:4000/ti/2024-09-27-responsiveMediaApp.html" rel="alternate" type="text/html" title="Create a more responsive media app (WWDC)" /><published>2024-09-27T00:00:00+09:00</published><updated>2024-09-27T00:00:00+09:00</updated><id>http://localhost:4000/ti/responsiveMediaApp</id><content type="html" xml:base="http://localhost:4000/ti/2024-09-27-responsiveMediaApp.html"><![CDATA[<p><a href="https://developer.apple.com/videos/play/wwdc2022/110379/?time=249">Create a more responsive media app (WWDC)</a></p>

<h1 id="avfoundation을-사용하여-더-반응이-빠른-미디어-앱-만들기">AVFoundation을 사용하여 더 반응이 빠른 미디어 앱 만들기</h1>

<ul>
  <li>썸네일을 보여주거나, 어러개의 미디어를 하나의 컴포지션으로 합치거나, 에셋의 정보를 얻는 등의 작업은 데이터를 로딩하는 작업이 필요합니다. 비디오처럼 큰 파일은 데이터를 로딩하는 작업에 긴 시간이 걸릴 수 있습니다. 이런 작업을 메인 스레드에서 동기적으로 실행하게 되면 레이턴시 이슈가 발생할 수 있습니다.</li>
  <li>AVFoundation의 도구들을 사용하여 데이터를 비동기적으로 로드한 뒤, 데이터 로딩 작업이 끝난 후 UI를 업데이트 하여, 앱이 위와 같은 문제없이 responsive하게 동작할 수 있습니다.</li>
</ul>

<h2 id="generating-thumbnails">Generating thumbnails</h2>

<p>AVAssetImageGenerator로부터 이미지를 얻는 것은 썸네일을 만드는 좋은 방법입니다.<br />
하지만 이미지를 생성하는 것은 실행 즉시 이루어지지 않습니다.<br />
이미지를 생성하기 위해서, image generator는 비디오 파일의 프레임 데이터를 먼저 로드해야 합니다.<br />
원격 서버나 인터넷에서 비디오 파일을 가져온다면 프레임 데이터를 로딩하는 작업이 훨씬 느리게 진행되기 때문에 이미지를 생성하는 방법을 신중히 선택해야 합니다.<br />
아래 코드에서 사용된 copyCGimage는 데이터를 메인스레드에서 동기적으로 로드합니다. 비디오가 로딩되길 기다리는 동안 UI는 멈춰버립니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">thumbnail</span><span class="p">()</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UIImage</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">generator</span> <span class="o">=</span> <span class="kt">AVAssetImageGenerator</span><span class="p">(</span><span class="nv">asset</span><span class="p">:</span> <span class="n">asset</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">thumbnail</span> <span class="o">=</span> <span class="k">try</span> <span class="n">generator</span><span class="o">.</span><span class="nf">copyCGImage</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span> <span class="nv">actualTime</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="k">return</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">cgImage</span><span class="p">:</span> <span class="n">thumbnail</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="imageat-time">image(at: time)</h3>
<p>image(at: time) 메서드를 사용하여 이미지 제너레이터가 데이터를 로딩하는 동안 호출된 스레드를 해제시켜 위와 같은 문제를 해결할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">thumbnail</span><span class="p">(</span><span class="nv">asset</span><span class="p">:</span> <span class="kt">AVAsset</span><span class="p">)</span> <span class="k">async</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UIImage</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">generator</span> <span class="o">=</span> <span class="kt">AVAssetImageGenerator</span><span class="p">(</span><span class="nv">asset</span><span class="p">:</span> <span class="n">asset</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">thumbnail</span> <span class="o">=</span> <span class="k">try</span> <span class="k">await</span> <span class="n">generator</span><span class="o">.</span><span class="nf">image</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span> <span class="kt">CMTime</span><span class="o">.</span><span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">image</span> <span class="c1">// time 설정 필요</span>
    <span class="k">return</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">cgImage</span><span class="p">:</span> <span class="n">thumbnail</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 코드에서 이미지 제너레이터는 튜플 (image: CGImage, actualTime: CMTime)을 리턴합니다.<br />
actual time은 에셋에서 해당 이미지의 actual time입니다. actual time은 몇가지 이유로 요청한 타임과 같지 않을 수 있습니다.<br />
위 코드와 같이 .image를 사용하여 이미지에만 접근할 수도 있습니다.</p>

<p>압축된 비디오의 프레임 중 IFrame은 다른 프레임들보다 로드하기 쉽습니다. 다른 프레임과 상관없이 독립적으로 디코딩되기 때문입니다.<br />
다른 프레임들은 가까이 있는 프레임에 의존하여 디코딩됩니다. <br />
그렇기 때문에 이미지 제너레이터는 기본적으로 요청한 시간과 가장 가까운 iFrame을 사용하여 이미지를 생성합니다.<br />
아래와 같이 tolerance를 zero로 설정하여 요청한 정확한 시간의 썸네일을 얻을 수 있지만, 요청한 시간의 프레임이 iFrame이 아닐 경우<br />
해당 프레임을 디코딩하기 위해 근처에 있는 프레임들까지 로딩해야할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">thumbnail</span><span class="p">(</span><span class="nv">asset</span><span class="p">:</span> <span class="kt">AVAsset</span><span class="p">)</span> <span class="k">async</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UIImage</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">generator</span> <span class="o">=</span> <span class="kt">AVAssetImageGenerator</span><span class="p">(</span><span class="nv">asset</span><span class="p">:</span> <span class="n">asset</span><span class="p">)</span>
    <span class="n">generator</span><span class="o">.</span><span class="n">requestedTimeToleranceBefore</span> <span class="o">=</span> <span class="o">.</span><span class="n">zero</span>
    <span class="n">generator</span><span class="o">.</span><span class="n">requestedTimeToleranceAfter</span> <span class="o">=</span> <span class="o">.</span><span class="n">zero</span>
    <span class="k">let</span> <span class="nv">thumbnail</span> <span class="o">=</span> <span class="k">try</span> <span class="k">await</span> <span class="n">generator</span><span class="o">.</span><span class="nf">image</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span> <span class="kt">CMTime</span><span class="o">.</span><span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">image</span> <span class="c1">// time 설정 필요</span>
    <span class="k">return</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">cgImage</span><span class="p">:</span> <span class="n">thumbnail</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>아래와 같이 더 넓은 tolerance를 줄 수 있습니다. 제너레이터가 더 많은 프레임 선택지를 갖게 함으로써 데이터 로딩을 줄일 수 있게 됩니다.<br />
프레임을 더 적게 로드할 수록 더 빠르게 이미지를 리턴할 수 있게 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">thumbnail</span><span class="p">(</span><span class="nv">asset</span><span class="p">:</span> <span class="kt">AVAsset</span><span class="p">)</span> <span class="k">async</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">UIImage</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">generator</span> <span class="o">=</span> <span class="kt">AVAssetImageGenerator</span><span class="p">(</span><span class="nv">asset</span><span class="p">:</span> <span class="n">asset</span><span class="p">)</span>
    <span class="n">generator</span><span class="o">.</span><span class="n">requestedTimeToleranceBefore</span> <span class="o">=</span> <span class="o">.</span><span class="n">zero</span>
    <span class="n">generator</span><span class="o">.</span><span class="n">requestedTimeToleranceAfter</span> <span class="o">=</span> <span class="kt">CMTime</span><span class="p">(</span><span class="nv">seconds</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nv">preferredTimescale</span><span class="p">:</span> <span class="mi">600</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">thumbnail</span> <span class="o">=</span> <span class="k">try</span> <span class="k">await</span> <span class="n">generator</span><span class="o">.</span><span class="nf">image</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span> <span class="kt">CMTime</span><span class="o">.</span><span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">image</span> <span class="c1">// time 설정 필요</span>
    <span class="k">return</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">cgImage</span><span class="p">:</span> <span class="n">thumbnail</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="generate-a-series-of-thumbnails">Generate a series of thumbnails</h2>

<p>여러개의 time으로 부터 섬네일들을 가져오기 위해서는, images(for: times)를 사용합니다.<br />
images(for: times)는 Async Sequence를 사용하여 결과값을 제공합니다.<br />
시퀀스를 사용하면 for in loop를 사용하여 items를 iterate할 수 있습니다.<br />
아래의 코드처럼 items(generator.images(for: times))가 한번에 가져올 수 없는 값이라면,<br />
async 시퀀스를 사용하여 각각의 iteration마다 다음 요소를 기다리도록 할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">timelineThumbnails</span><span class="p">(</span><span class="k">for</span> <span class="nv">times</span><span class="p">:</span> <span class="p">[</span><span class="kt">CMTime</span><span class="p">],</span> <span class="nv">asset</span><span class="p">:</span> <span class="kt">AVAsset</span><span class="p">)</span> <span class="k">async</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">generator</span> <span class="o">=</span> <span class="kt">AVAssetImageGenerator</span><span class="p">(</span><span class="nv">asset</span><span class="p">:</span> <span class="n">asset</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="k">await</span> <span class="n">result</span> <span class="k">in</span> <span class="n">generator</span><span class="o">.</span><span class="nf">images</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">times</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Mirae</name></author><category term="TI" /><summary type="html"><![CDATA[Create a more responsive media app (WWDC)]]></summary></entry><entry><title type="html">프로젝트 ‘로또메이트’ - 리팩토링 기록</title><link href="http://localhost:4000/til/2024-09-22-lottoMate-refactoringLog.html" rel="alternate" type="text/html" title="프로젝트 ‘로또메이트’ - 리팩토링 기록" /><published>2024-09-22T00:00:00+09:00</published><updated>2024-09-22T00:00:00+09:00</updated><id>http://localhost:4000/til/lottoMate-refactoringLog</id><content type="html" xml:base="http://localhost:4000/til/2024-09-22-lottoMate-refactoringLog.html"><![CDATA[<h1 id="template">Template</h1>

<blockquote class="block-tip">
  <h5 id="이슈-정리-템플리">이슈 정리 템플리</h5>

  <p>프로젝트 진행 중 리팩토링한 내용을 아래 템플릿에 따라 정리합니다.</p>
</blockquote>

<h2 id="1-리팩토링-이유-reason-for-refactoring">1. 리팩토링 이유 (Reason for Refactoring)</h2>
<ul>
  <li>배경 설명: 코드 리팩토링이 필요했던 배경을 설명합니다. 새로운 기술을 학습하거나 프로젝트 요구 사항이 변경되어 리팩토링이 필요하게 된 이유를 적습니다.
<!--- 예: "프로젝트의 유지보수성을 높이기 위해 코드 구조를 개선할 필요가 있었습니다." --></li>
</ul>

<h2 id="2-기존-코드-문제점-issues-in-existing-code">2. 기존 코드 문제점 (Issues in Existing Code)</h2>
<ul>
  <li>기존 코드의 문제점: 리팩토링 이전에 코드에서 발생한 문제들을 나열합니다. 성능 문제, 가독성, 중복 코드 등 개선해야 할 부분을 구체적으로 설명합니다.
<!--- 예: "중복된 코드가 많아 가독성이 떨어졌고, 유지보수 시 어려움이 있었습니다." --></li>
</ul>

<h2 id="3-리팩토링-과정-refactoring-process">3. 리팩토링 과정 (Refactoring Process)</h2>
<ul>
  <li>
    <p>수행한 작업: 리팩토링 중 어떤 작업을 수행했는지 단계별로 설명합니다. 코드 리팩토링 과정에서 변경한 주요 사항들을 포함합니다.
<!--- 예: "중복된 함수를 제거하고 공통 모듈로 추출하였습니다." --></p>
  </li>
  <li>
    <p>시도한 방법: 리팩토링을 진행하며 시도한 다양한 방법을 기록합니다. 성공하지 못한 접근 방식도 포함하여, 해결 과정에서의 고민을 보여줍니다.
<!--- 예: "처음에는 함수의 파라미터 수를 줄여서 문제를 해결하려 했지만, 전체 코드 구조에 맞지 않아 실패하였습니다." --></p>
  </li>
</ul>

<h2 id="4-최종-코드-final-code">4. 최종 코드 (Final Code)</h2>
<ul>
  <li>최종 코드 설명: 리팩토링 후의 최종 코드를 설명합니다. 리팩토링 전후의 주요 차이점과 개선된 부분을 코드와 함께 보여줍니다.
<!--- 예: "기존의 반복된 코드를 하나의 함수로 통합하고, 재사용 가능한 모듈로 만들었습니다." -->
    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 리팩토링 후의 최종 코드 예시</span>
<span class="kd">func</span> <span class="nf">updateUI</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">updateLabelText</span><span class="p">()</span>
  <span class="nf">updateButtonState</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="5-결과-outcome">5. 결과 (Outcome)</h2>
<ul>
  <li>성능 및 유지보수성 향상: 리팩토링 후 성능이나 유지보수성, 코드 가독성이 얼마나 개선되었는지 설명합니다.
<!--- 예: "리팩토링 후 코드의 가독성이 크게 향상되었으며, 유지보수가 용이해졌습니다." --></li>
</ul>

<h2 id="6-교훈-및-배운-점-lessons-learned">6. 교훈 및 배운 점 (Lessons Learned)</h2>
<ul>
  <li>리팩토링을 통해 배운 점: 리팩토링 과정에서 배운 점이나 새로 익힌 기술을 기록합니다. 비슷한 상황에서 적용할 수 있는 원칙이나 개선할 수 있는 부분을 정리합니다.
<!--- 예: "모듈화를 통해 코드의 재사용성을 높이는 것이 얼마나 중요한지 깨달았습니다." --></li>
</ul>

<hr />

<h1 id="rxswift-중첩-구독">[RxSwift] 중첩 구독</h1>

<h2 id="1-리팩토링-이유">1. 리팩토링 이유</h2>
<ul>
  <li>다른 개발자님께서 코드를 검토하던 중 중첩된 구독이 발생한 것을 알려주셨습니다. 코드의 가독성과 유지보수성을 높이기 위해 RxSwift의 권장 방식을 따르는 방향으로 리팩토링을 진행하게 되었습니다.</li>
</ul>

<h2 id="2-기존-코드-문제점">2. 기존 코드 문제점</h2>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">confirmButton</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="nf">tapGesture</span><span class="p">()</span>
    <span class="o">.</span><span class="nf">when</span><span class="p">(</span><span class="o">.</span><span class="n">recognized</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">_</span> <span class="k">in</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">self</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="k">let</span> <span class="nv">selectedRound</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="mi">0</span>
        
        <span class="n">viewModel</span><span class="o">.</span><span class="n">selectedLotteryType</span>
            <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">type</span> <span class="k">in</span>
                <span class="k">switch</span> <span class="n">type</span> <span class="p">{</span>
                <span class="k">case</span> <span class="o">.</span><span class="nv">lotto</span><span class="p">:</span>
                    <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">viewModel</span><span class="o">.</span><span class="nf">fetchLottoResult</span><span class="p">(</span><span class="nv">round</span><span class="p">:</span> <span class="n">selectedRound</span><span class="p">)</span>
                    <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">viewModel</span><span class="o">.</span><span class="n">currentLottoRound</span><span class="o">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">selectedRound</span><span class="p">)</span>
                <span class="k">case</span> <span class="o">.</span><span class="nv">pensionLottery</span><span class="p">:</span>
                    <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">viewModel</span><span class="o">.</span><span class="nf">fetchPensionLotteryResult</span><span class="p">(</span><span class="nv">round</span><span class="p">:</span> <span class="n">selectedRound</span><span class="p">)</span>
                    <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">viewModel</span><span class="o">.</span><span class="n">currentPensionLotteryRound</span><span class="o">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">selectedRound</span><span class="p">)</span>
                <span class="k">case</span> <span class="o">.</span><span class="nv">speeto</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="p">}</span>
            <span class="p">})</span>
            <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
        
        <span class="k">self</span><span class="o">.</span><span class="nf">dismiss</span><span class="p">(</span><span class="nv">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nv">completion</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li><a href="https://github.com/ReactiveX/RxSwift/blob/main/Documentation/Tips.md">여기</a> 에서 확인할 수 있듯이 RxSwift에서는 operator를 사용하여 스트림을 조합하는 것이 권장되지만, 기존 코드는 이를 따르지 않고 중첩 구독하는 방식으로 작성되어 있었습니다.</li>
</ul>

<h2 id="3-리팩토링-과정-refactoring-process-1">3. 리팩토링 과정 (Refactoring Process)</h2>
<ul>
  <li>중첩된 subscribe 제거: withLatestFrom 연산자를 사용하여 confirm 버튼을 탭하는 시점에 최신 lottery type을 가져오도록 하여 viewModel.selectedLotteryType의 subscribe를 제거하였습니다.</li>
</ul>

<h2 id="4-최종-코드-final-code-1">4. 최종 코드 (Final Code)</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">confirmButton</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="nf">tapGesture</span><span class="p">()</span>
    <span class="o">.</span><span class="nf">when</span><span class="p">(</span><span class="o">.</span><span class="n">recognized</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">withLatestFrom</span><span class="p">(</span><span class="n">viewModel</span><span class="o">.</span><span class="n">selectedLotteryType</span><span class="p">)</span> <span class="c1">// tap 시점에 최신 로터리 타입을 가져옴</span>
    <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">type</span> <span class="k">in</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">self</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="k">let</span> <span class="nv">selectedRound</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="mi">0</span>
        
        <span class="k">switch</span> <span class="n">type</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">lotto</span><span class="p">:</span>
            <span class="k">self</span><span class="o">.</span><span class="n">viewModel</span><span class="o">.</span><span class="nf">fetchLottoResult</span><span class="p">(</span><span class="nv">round</span><span class="p">:</span> <span class="n">selectedRound</span><span class="p">)</span>
            <span class="k">self</span><span class="o">.</span><span class="n">viewModel</span><span class="o">.</span><span class="n">currentLottoRound</span><span class="o">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">selectedRound</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">pensionLottery</span><span class="p">:</span>
            <span class="k">self</span><span class="o">.</span><span class="n">viewModel</span><span class="o">.</span><span class="nf">fetchPensionLotteryResult</span><span class="p">(</span><span class="nv">round</span><span class="p">:</span> <span class="n">selectedRound</span><span class="p">)</span>
            <span class="k">self</span><span class="o">.</span><span class="n">viewModel</span><span class="o">.</span><span class="n">currentPensionLotteryRound</span><span class="o">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">selectedRound</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">speeto</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="o">.</span><span class="nf">dismiss</span><span class="p">(</span><span class="nv">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nv">completion</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li>리팩토링 후의 최종 코드는 중첩된 구독을 제거하고, withLatestFrom 연산자를 사용하여 구독을 단순화했습니다. 이로 인해 코드의 가독성과 유지보수성이 크게 향상되었습니다.</li>
</ul>

<h2 id="6-교훈-및-배운-점">6. 교훈 및 배운 점</h2>
<ul>
  <li>리팩토링 과정에서 RxSwift의 operator 사용의 중요성을 깨달았습니다. 스트림을 조합하는 방식이 코드의 가독성과 유지보수성을 높이는 데 얼마나 효과적인지를 실감했으며, 앞으로도 이러한 원칙을 적용해 더 나은 코드를 작성할 수 있도록 할 것입니다.</li>
</ul>]]></content><author><name>Mirae</name></author><category term="TIL" /><summary type="html"><![CDATA[Template]]></summary></entry><entry><title type="html">프로젝트 ‘로또메이트’ - 문제 해결 내용</title><link href="http://localhost:4000/til/2024-09-20-lottoMate.html" rel="alternate" type="text/html" title="프로젝트 ‘로또메이트’ - 문제 해결 내용" /><published>2024-09-20T00:00:00+09:00</published><updated>2024-09-20T00:00:00+09:00</updated><id>http://localhost:4000/til/lottoMate</id><content type="html" xml:base="http://localhost:4000/til/2024-09-20-lottoMate.html"><![CDATA[<h1 id="template">Template</h1>

<blockquote class="block-tip">
  <h5 id="이슈-정리-템플릿">이슈 정리 템플릿</h5>

  <p>아래 템플릿을 사용하여 프로젝트 진행 중 발생한 이슈 내용을 정리합니다.<br />
각 항목에 맞춰 문제와 해결 방법을 구체적으로 작성합니다.</p>
</blockquote>

<h2 id="1-문제-상황-problem">1. 문제 상황 (Problem)</h2>
<ul>
  <li>
    <p>배경 설명: 문제 발생 전에 있었던 상황이나 필요했던 기능을 간략하게 설명합니다.<br />
<!--- 예: "프로젝트에서 UIPageView의 뷰에 corner radius를 적용했으나, 특정 기기에서 하단 부분이 잘리는 문제가 발생했습니다." --></p>
  </li>
  <li>
    <p>문제 설명: 구체적으로 문제가 무엇인지 설명합니다. 해당 문제를 어떻게 발견했는지, 문제를 다시 재현하는 방법도 간략하게 언급할 수 있습니다.<br />
<!--- 예: "iPhone 14 Pro에서 corner radius가 잘려서 보였고, UI가 깨진 것처럼 보였습니다." --></p>
  </li>
</ul>

<h2 id="2-원인-분석-analysis">2. 원인 분석 (Analysis)</h2>
<ul>
  <li>
    <p>원인 분석 과정: 문제를 분석하면서 발견한 내용을 설명합니다. 관련 코드를 포함하면 좋습니다.
<!--- 예: "이 문제는 PageViewController의 기본 레이아웃 방식이 일부 기기에서 화면 경계와 맞닿아 있어 발생했습니다." --></p>
  </li>
  <li>
    <p>시도한 방법들: 문제를 해결하기 위해 시도한 여러 방법을 설명합니다. 성공하지 못한 방법도 간략히 언급하여, 문제 해결 과정의 고민을 드러냅니다.
<!--- 예: "처음에는 PinLayout을 사용하여 해결하려 했으나, 특정 기기에서 원하는 대로 동작하지 않았습니다." --></p>
  </li>
</ul>

<h2 id="3-해결-방법-solution">3. 해결 방법 (Solution)</h2>
<ul>
  <li>최종 해결 방법: 문제를 어떻게 해결했는지 구체적으로 설명합니다. 해결한 코드를 포함시켜 독자가 쉽게 이해할 수 있도록 합니다.
<!--- 예: "뷰 계층 구조와 레이아웃 방식에서 오류를 찾은 후, 아래 코드를 통해 뷰의 하단이 잘리지 않도록 corner radius를 조정했습니다."
swift
Copy code
override func viewDidLayoutSubviews() {
  super.viewDidLayoutSubviews()
  rootFlexContainer.pin.top(view.safeAreaInsets.top).horizontally()
  rootFlexContainer.flex.layout(mode: .adjustHeight)
} --></li>
  <li>왜 이 방법이 효과적인지: 해결책이 왜 효과적이었는지 설명하여, 독자가 그 원리를 이해할 수 있게 돕습니다.
<!--- 예: "이 방법은 Safe Area Insets를 고려해 레이아웃을 조정했기 때문에 모든 기기에서 안정적으로 작동하게 되었습니다." --></li>
</ul>

<h2 id="4-결과-result">4. 결과 (Result)</h2>
<ul>
  <li>
    <p>결과 설명: 문제 해결 후의 결과를 설명합니다. 성능, UI 개선 등 눈에 띄는 변화가 있다면 언급합니다.
<!---예: "이제 모든 기기에서 UI가 깔끔하게 렌더링되었으며, corner radius가 잘리지 않고 적용되었습니다." --></p>
  </li>
  <li>
    <p>추가 개선 사항: 만약 문제 해결 과정에서 배운 점이나 추가로 고려할 사항이 있다면 짧게 언급합니다.
<!---예: "다음엔 Safe Area를 보다 효율적으로 관리하기 위해 추가적인 도구나 방법을 사용할 계획입니다." --></p>
  </li>
</ul>

<h2 id="5-교훈-takeaways">5. 교훈 (Takeaways)</h2>
<ul>
  <li>배운 점: 이 문제를 해결하며 배운 점을 간략히 정리합니다. 비슷한 상황에서 적용할 수 있는 원칙을 공유합니다.
<!---예: "Safe Area와 다양한 기기 레이아웃을 미리 고려하는 것이 중요하며, 레이아웃을 조정할 때는 PinLayout과 같은 라이브러리를 효과적으로 활용하는 것이 도움이 됩니다." --></li>
</ul>

<hr />

<h1 id="커스텀-네비게이션-바-레이아웃-이슈">커스텀 네비게이션 바 레이아웃 이슈</h1>

<center><img src="/assets/images/lottoMate_1.png" alt="lottoMate_1.png" width="257" /></center>
<p><br /></p>

<h2 id="1-문제-상황">1. 문제 상황</h2>
<ul>
  <li>
    <p>iPhone 14 Pro, iPhone 14 Pro Max, iPhone 15 Pro, iPhone 15 Pro Max 기기 시뮬레이터에서 status bar와 커스텀 navigation bar 사이에 5px 정도의 빈 공간이 나타나는 문제가 발생했습니다. 다른 기기 시뮬레이터 에서는 이러한 현상이 나타나지 않았으며, 문제는 해당 네 가지 기기 시뮬레이터에서만 재현되었습니다.</p>
  </li>
  <li>
    <p>문제는 rootFlexContainer가 top safe area 바로 아래에 커스텀 네비게이션 바가 위치하도록 작성된 코드에서 발생했습니다.</p>
    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rootFlexContainer</span><span class="o">.</span><span class="n">pin</span><span class="o">.</span><span class="nf">top</span><span class="p">(</span><span class="n">view</span><span class="o">.</span><span class="n">safeAreaInsets</span><span class="o">.</span><span class="n">top</span><span class="p">)</span><span class="o">.</span><span class="nf">horizontally</span><span class="p">()</span>
<span class="n">rootFlexContainer</span><span class="o">.</span><span class="n">flex</span><span class="o">.</span><span class="nf">layout</span><span class="p">(</span><span class="nv">mode</span><span class="p">:</span> <span class="o">.</span><span class="n">adjustHeight</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="2-원인-분석">2. 원인 분석</h2>
<ul>
  <li>
    <p>기존 코드에서는 view.safeAreaInsets.top을 사용하여 네비게이션 바를 top safe area 아래에 배치하고 있었습니다. 하지만 특정 기기에서는 status bar와 top safe area 간에 예상치 못한 빈 공간이 생기는 현상이 발생했습니다.</p>
  </li>
  <li>
    <p>처음에는 사용자의 기기 정보를 기반으로 문제가 발생하는 기기(iPhone 14 Pro, iPhone 14 Pro Max, iPhone 15 Pro, iPhone 15 Pro Max)에 한해 커스텀 네비게이션 바의 margin top 값을 -5로 설정하여 빈 공간만큼 뷰를 위로 이동시키는 방식을 시도했습니다. 이를 통해 빈 공간이 없는 것처럼 보이게 했으나, 기기별 정보를 이용해 코드를 분기 처리하는 방식은 안전하지 않다고 판단했습니다. 따라서 최종적으로 status bar의 높이를 동적으로 구한 후, 그 값을 이용해 커스텀 네비게이션 바를 status bar 바로 아래에 위치시키는 방법을 사용했습니다.</p>
  </li>
</ul>

<h2 id="3-해결-방법">3. 해결 방법</h2>
<ul>
  <li>
    <p>문제를 해결하기 위해, status bar의 높이를 직접 가져와 그 값을 기반으로 rootFlexContainer(커스텀 네비게이션 바)를 배치하도록 코드를 수정했습니다. 빈 공간이 발생하는 기기에서도 문제없이 동작할 수 있도록 statusBarManager를 통해 상태 바의 정확한 높이를 가져와 그 바로 아래에 네비게이션 바가 위치하도록 설정했습니다.</p>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 상태바의 높이를 가져오기 위한 설정</span>
  <span class="k">var</span> <span class="nv">statusBarHeight</span><span class="p">:</span> <span class="kt">CGFloat</span> <span class="o">=</span> <span class="mf">0.0</span>

  <span class="k">if</span> <span class="k">let</span> <span class="nv">windowScene</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">window</span><span class="p">?</span><span class="o">.</span><span class="n">windowScene</span> <span class="p">{</span>
      <span class="n">statusBarHeight</span> <span class="o">=</span> <span class="n">windowScene</span><span class="o">.</span><span class="n">statusBarManager</span><span class="p">?</span><span class="o">.</span><span class="n">statusBarFrame</span><span class="o">.</span><span class="n">height</span> <span class="p">??</span> <span class="mi">0</span>
  <span class="p">}</span>

  <span class="c1">// rootFlexContainer를 상태바 바로 아래에 배치</span>
  <span class="n">rootFlexContainer</span><span class="o">.</span><span class="n">pin</span>
      <span class="o">.</span><span class="nf">top</span><span class="p">(</span><span class="n">statusBarHeight</span><span class="p">)</span>  <span class="c1">// 상태바 바로 아래에 배치</span>
      <span class="o">.</span><span class="nf">horizontally</span><span class="p">()</span>         <span class="c1">// 좌우 여백은 기본으로 적용</span>
  <span class="n">rootFlexContainer</span><span class="o">.</span><span class="n">flex</span><span class="o">.</span><span class="nf">layout</span><span class="p">(</span><span class="nv">mode</span><span class="p">:</span> <span class="o">.</span><span class="n">adjustHeight</span><span class="p">)</span> <span class="c1">// 높이는 flex로 자동 조정</span>
</code></pre></div>    </div>
    <p>문제의 원인은 top safe area의 높이와 status bar의 높이가 서로 다르기 때문이었습니다. 기기마다 status bar의 높이가 다를 수 있지만, 이 값을 동적으로 가져와 top 값으로 설정함으로써 모든 기기에서 일관된 레이아웃을 유지할 수 있었습니다.</p>
  </li>
</ul>

<h2 id="4-결과">4. 결과</h2>
<ul>
  <li>해당 코드를 적용한 후, iPhone 14 Pro, iPhone 14 Pro Max, iPhone 15 Pro, iPhone 15 Pro Max에서 모두 빈 공간이 나타나지 않고 네비게이션 바가 정상적으로 status bar 바로 아래에 배치되었습니다. 그 외 다른 기기에서도 정상적으로 레이아웃이 유지됨을 확인했습니다.</li>
</ul>

<h2 id="5-교훈">5. 교훈</h2>
<ul>
  <li>이번 문제를 통해 기기별로 다른 코드를 사용하는 것보다, 모든 기기에서 일관되게 동작하는 코드를 찾는 것이 더 중요하다는 점을 알게 되었습니다. 앞으로는 특정 기기에 맞추기보다, 범용적으로 사용할 수 있는 코드를 우선적으로 고려하려고 합니다.</li>
</ul>

<h1 id="사진-확대-뷰-닫기-기능-이슈">사진 확대 뷰 닫기 기능 이슈</h1>

<center><img src="/assets/images/lottoMate_2_zoomImage.png" alt="lottoMate_2_zoomImage.png" width="257" /></center>
<p><br /></p>

<h2 id="1-문제-상황-1">1. 문제 상황</h2>
<ul>
  <li>사진 확대 기능에서 닫기 버튼을 통해 뷰를 제거하는 기능이 필요했습니다. 닫기 버튼을 처음 눌렀을 때 뷰가 사라지지 않고 두 번째 눌렀을 때부터 사라지는 문제가 발생했습니다.</li>
</ul>

<h2 id="2-원인-분석-1">2. 원인 분석</h2>
<ul>
  <li>
    <p>닫기 버튼 클릭 시 동작하는 함수인 dismissFullscreenImage()가 호출될 때 전체 subview의 배경색을 확인해본 결과, 사진 확대 뷰가 두번 추가되었기 때문에 발생한 문제임을 발견했습니다.</p>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">@objc</span> <span class="kd">func</span> <span class="nf">dismissFullscreenImage</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">for</span> <span class="n">subview</span> <span class="k">in</span> <span class="k">self</span><span class="o">.</span><span class="n">view</span><span class="o">.</span><span class="n">subviews</span> <span class="p">{</span>
          <span class="nf">print</span><span class="p">(</span><span class="s">"subview's background color: </span><span class="se">\(</span><span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">subview</span><span class="o">.</span><span class="n">backgroundColor</span><span class="p">)</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
      <span class="p">}</span>
        
  <span class="c1">// subview's background color: nil</span>
  <span class="c1">// subview's background color: Optional(kCGColorSpaceModelRGB 0 0 0 0.8 )</span>
  <span class="c1">// subview's background color: Optional(kCGColorSpaceModelRGB 1 1 1 0.8 )</span>
  <span class="c1">// subview's background color: Optional(kCGColorSpaceModelRGB 0 0 0 0.8 )</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="3-해결-방법-1">3. 해결 방법</h2>
<ul>
  <li>
    <p>winningReviewFullSizeImgName이 기본값을 내보낼 때도 서브 뷰가 추가되도록 코드가 작성되어 있었기 때문에 발생한 문제임을 발견했습니다. 기본값인 ““일 때는 뷰가 추가되지 않도록 수정했습니다.</p>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">func</span> <span class="nf">showTappedImage</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">viewModel</span><span class="o">.</span><span class="n">winningReviewFullSizeImgName</span>
          <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">name</span> <span class="k">in</span>
              <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s">""</span> <span class="p">{</span> <span class="c1">// 기본값인 ""일 때 추가되지 않도록 수정</span>
                  <span class="k">self</span><span class="o">.</span><span class="nf">changeStatusBarBgColor</span><span class="p">(</span><span class="nv">bgColor</span><span class="p">:</span> <span class="o">.</span><span class="n">clear</span><span class="p">)</span>
                  <span class="k">self</span><span class="o">.</span><span class="nf">showFullscreenImage</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span> <span class="s">"</span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
              <span class="p">}</span>
          <span class="p">})</span>
          <span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="4-결과-1">4. 결과</h2>
<ul>
  <li>문제 해결 후 닫기 버튼을 클릭하면 뷰가 즉시 제거되며, 사용자 경험이 개선되었습니다. 향후에는 UI 요소의 추가와 제거를 더 체계적으로 관리하기 위해 뷰의 상태를 명확하게 정의할 계획입니다.</li>
</ul>

<h2 id="5-교훈-1">5. 교훈</h2>
<ul>
  <li>이 문제를 해결하며 문제를 바로 해결하려고 하기보다는 문제의 원인을 빠르게 파악하는 것이 중요하다는 것을 깨달았습니다. 원인을 이해한 후에 적절한 해결책을 찾는 것이 더 효과적입니다.</li>
</ul>]]></content><author><name>Mirae</name></author><category term="TIL" /><summary type="html"><![CDATA[Template]]></summary></entry><entry><title type="html">PinLayout &amp;amp; FlexLayout</title><link href="http://localhost:4000/til/2024-06-26-PinLayoutAndFlexLayout.html" rel="alternate" type="text/html" title="PinLayout &amp;amp; FlexLayout" /><published>2024-06-26T00:00:00+09:00</published><updated>2024-06-26T00:00:00+09:00</updated><id>http://localhost:4000/til/PinLayoutAndFlexLayout</id><content type="html" xml:base="http://localhost:4000/til/2024-06-26-PinLayoutAndFlexLayout.html"><![CDATA[<blockquote>
  <p>이 포스팅은 PinLayout &amp; FlexLayout 사용하여 프로젝트를 진행하며 기억해두고 싶은 것을 적어두는 것에 목적을 두고 있습니다.</p>
</blockquote>

<p>🍊</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">override</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 뷰의 appearance를 정의</span>
    <span class="p">}</span>
    
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">layoutSubviews</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 이 안에서 layout을 설정해주어야 뷰에 나타남.</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>🍊</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">addressField</span><span class="o">.</span><span class="n">pin</span><span class="o">.</span><span class="nf">below</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="nf">visible</span><span class="p">([</span><span class="n">ageSwitch</span><span class="p">,</span> <span class="n">ageField</span><span class="p">]))</span><span class="o">.</span><span class="nf">horizontally</span><span class="p">()</span><span class="o">.</span><span class="nf">height</span><span class="p">(</span><span class="n">height</span><span class="p">)</span><span class="o">.</span><span class="nf">marginTop</span><span class="p">(</span><span class="n">margin</span><span class="p">)</span><span class="o">.</span><span class="nf">marginHorizontal</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>visible을 사용하여 보이는 뷰의 아래에 뷰를 pin 할 수 있음. ageSwitch 버튼의 isOn 상태에 따라 ageField가 나타났다 사라졌다 하는데 ageField가 나타났을 때는 ageField 아래에 뷰가 나타나고, 사라졌을 때는 ageSwitch 밑에 뷰가 나타남.</li>
</ul>

<p>🍊</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">override</span> <span class="kd">func</span> <span class="nf">layoutSubviews</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="o">.</span><span class="nf">layoutSubviews</span><span class="p">()</span>
    <span class="c1">// top: safety area에 고정, 나머지는 스크린 끝쪽에 고정</span>
    <span class="n">contentView</span><span class="o">.</span><span class="n">pin</span><span class="o">.</span><span class="nf">top</span><span class="p">(</span><span class="n">pin</span><span class="o">.</span><span class="n">safeArea</span><span class="p">)</span><span class="o">.</span><span class="nf">bottom</span><span class="p">()</span><span class="o">.</span><span class="nf">left</span><span class="p">()</span><span class="o">.</span><span class="nf">right</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>top: safety area에 고정, 나머지는 스크린 끝쪽에 고정</li>
</ul>

<p>🍊</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">flex</span><span class="o">.</span><span class="nf">addItem</span><span class="p">()</span><span class="o">.</span><span class="nf">direction</span><span class="p">(</span><span class="o">.</span><span class="n">row</span><span class="p">)</span><span class="o">.</span><span class="nf">alignItems</span><span class="p">(</span><span class="o">.</span><span class="n">baseline</span><span class="p">)</span><span class="o">.</span><span class="n">define</span> <span class="p">{</span> <span class="n">flex</span> <span class="k">in</span>
    <span class="n">flex</span><span class="o">.</span><span class="nf">addItem</span><span class="p">(</span><span class="n">view1</span><span class="p">)</span><span class="o">.</span><span class="nf">marginRight</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">flex</span><span class="o">.</span><span class="nf">addItem</span><span class="p">(</span><span class="n">view2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>UILabel의 높이가 같은 컨테이너에 있을 경우 같게 나타나는 문제가 있어 아래와 같이 alignItems()를 추가해주어 각자의 높이가 정상적으로 나타나도록 함.</li>
</ul>

<p>🍊 Simulator에서 layout이 정상적으로 보이지 않는 문제</p>
<ul>
  <li>Scroll view를 사용하는 뷰가 프리뷰에서는 정상적으로 보이나 시뮬레이터에서는 정상적으로 보이지 않음.</li>
  <li>코드 a와 b의 순서가 다른 것이 문제였음. scroll view를 pin하는 코드를 먼저 작성해주었더니 정상적으로 나타남.
    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">override</span> <span class="kd">func</span> <span class="nf">layoutSubviews</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">super</span><span class="o">.</span><span class="nf">layoutSubviews</span><span class="p">()</span>
  <span class="n">scrollView</span><span class="o">.</span><span class="n">pin</span><span class="o">.</span><span class="nf">top</span><span class="p">()</span><span class="o">.</span><span class="nf">bottom</span><span class="p">()</span><span class="o">.</span><span class="nf">left</span><span class="p">()</span><span class="o">.</span><span class="nf">right</span><span class="p">()</span> <span class="c1">// scroll view를 pin하는 코드 a</span>
  <span class="n">rootFlexContainer</span><span class="o">.</span><span class="n">pin</span><span class="o">.</span><span class="nf">top</span><span class="p">()</span><span class="o">.</span><span class="nf">left</span><span class="p">()</span><span class="o">.</span><span class="nf">right</span><span class="p">()</span> <span class="c1">// rootFlexContainer를 pin하는 코드 b</span>
  <span class="n">rootFlexContainer</span><span class="o">.</span><span class="n">flex</span><span class="o">.</span><span class="nf">layout</span><span class="p">(</span><span class="nv">mode</span><span class="p">:</span> <span class="o">.</span><span class="n">adjustHeight</span><span class="p">)</span>
  <span class="n">scrollView</span><span class="o">.</span><span class="n">contentSize</span> <span class="o">=</span> <span class="n">rootFlexContainer</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">size</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>Mirae</name></author><category term="TIL" /><summary type="html"><![CDATA[이 포스팅은 PinLayout &amp; FlexLayout 사용하여 프로젝트를 진행하며 기억해두고 싶은 것을 적어두는 것에 목적을 두고 있습니다.]]></summary></entry><entry><title type="html">UIKit 튜토리얼 따라가보기</title><link href="http://localhost:4000/til/2024-06-09-UIKit-toturial.html" rel="alternate" type="text/html" title="UIKit 튜토리얼 따라가보기" /><published>2024-06-09T00:00:00+09:00</published><updated>2024-06-09T00:00:00+09:00</updated><id>http://localhost:4000/til/UIKit-toturial</id><content type="html" xml:base="http://localhost:4000/til/2024-06-09-UIKit-toturial.html"><![CDATA[<h1 id="creating-a-list-view">Creating a list view</h1>
<blockquote>
  <p>Add a collention view controller</p>
</blockquote>

<p>뷰컨트롤러(이하 ‘뷰컨’)는 뷰와 데이터 모델 사이에 다리 역할을 한다.<br />
  각 뷰컨은 하나의 뷰 계층을 관리하는 역할을 담당한다. 뷰의 컨텐츠를 업데이트하고, UI에 일어난 이벤트를 관리한다.<br />
  Interface Builder를 사용하여 컬렉션 뷰컨트롤러를 생성해보자.<br />
  컬렉션뷰는 그리드, 행, 열, 또는 테이블의 형태로 셀을 보여준다.</p>

<ul>
  <li>Collection view controller scene을 추가한다.</li>
  <li>생성된 collection view의 cell 템플릿을 제거한다. (셀을 코드에서 정의할 것이기 때문.)</li>
  <li>Attribute inspector에서 is initial view controller 체크박스를 체크하여 해당 씬을 스토리보드의 엔트리 포인트로 설정 (앱이 스토리보드를 로드할 때 가장 먼저 로드됨.)</li>
</ul>

<blockquote>
  <p>Create a reminder model</p>
</blockquote>

<p>structure를 사용하여 모델을 생성한다. Swift 컴파일러가 자동으로 스트럭처에 멤버에 해당하는 이니셜라이저를 생성하기 때문에 따로 이니셜라이저를 생성할 필요가 없다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if DEBUG</span>
<span class="kd">extension</span> <span class="kt">Reminder</span> <span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</code></pre></div></div>
<ul>
  <li>#if DEBUG 블락을 사용하여 디버그 모드에서만 컴파일되는 코드를 작성할 수 있다.</li>
  <li>디버그 빌드에서 테스팅을 위한 코드를 작성하거나, 샘플 테스트 데이터를 작성할 때 사용할 수 있다.</li>
  <li>나는 아래와 같이 내 앱 데이터에 해당하는 샘플 데이터를 생성했다.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if DEBUG</span>
<span class="kd">extension</span> <span class="kt">LottoWinPointModel</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">sampleLottoWinPoints</span> <span class="o">=</span> <span class="p">[</span>
        <span class="kt">LottoWinPointModel</span><span class="p">(</span><span class="nv">currentCount</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nv">data</span><span class="p">:</span> <span class="kt">LottoWinPointModelData</span><span class="o">.</span><span class="n">sampleLottoWinPointsData</span><span class="p">,</span> <span class="nv">matchCount</span><span class="p">:</span> <span class="mi">330</span><span class="p">,</span> <span class="nv">page</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">perPage</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nv">totalCount</span><span class="p">:</span> <span class="mi">330</span><span class="p">)</span>
    <span class="p">]</span>
<span class="p">}</span>
<span class="kd">extension</span> <span class="kt">LottoWinPointModelData</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">sampleLottoWinPointsData</span> <span class="o">=</span> <span class="p">[</span>
        <span class="kt">LottoWinPointModelData</span><span class="p">(</span><span class="nv">firstPrizeWinsCount</span><span class="p">:</span> <span class="s">"5"</span><span class="p">,</span> <span class="nv">storeName</span><span class="p">:</span> <span class="s">"일등복권편의점"</span><span class="p">,</span> <span class="nv">orderNumber</span><span class="p">:</span> <span class="s">"1"</span><span class="p">,</span> <span class="nv">region</span><span class="p">:</span> <span class="s">"대구 달서구"</span><span class="p">),</span>
        <span class="kt">LottoWinPointModelData</span><span class="p">(</span><span class="nv">firstPrizeWinsCount</span><span class="p">:</span> <span class="s">"3"</span><span class="p">,</span> <span class="nv">storeName</span><span class="p">:</span> <span class="s">"오케이상사"</span><span class="p">,</span> <span class="nv">orderNumber</span><span class="p">:</span> <span class="s">"2"</span><span class="p">,</span> <span class="nv">region</span><span class="p">:</span> <span class="s">"서울 서초구"</span><span class="p">),</span>
        <span class="kt">LottoWinPointModelData</span><span class="p">(</span><span class="nv">firstPrizeWinsCount</span><span class="p">:</span> <span class="s">"2"</span><span class="p">,</span> <span class="nv">storeName</span><span class="p">:</span> <span class="s">"세진전자통신"</span><span class="p">,</span> <span class="nv">orderNumber</span><span class="p">:</span> <span class="s">"3"</span><span class="p">,</span> <span class="nv">region</span><span class="p">:</span> <span class="s">"대구 서구"</span><span class="p">),</span>
        <span class="kt">LottoWinPointModelData</span><span class="p">(</span><span class="nv">firstPrizeWinsCount</span><span class="p">:</span> <span class="s">"2"</span><span class="p">,</span> <span class="nv">storeName</span><span class="p">:</span> <span class="s">"라이프마트"</span><span class="p">,</span> <span class="nv">orderNumber</span><span class="p">:</span> <span class="s">"4"</span><span class="p">,</span> <span class="nv">region</span><span class="p">:</span> <span class="s">"인천 중구"</span><span class="p">),</span>
        <span class="kt">LottoWinPointModelData</span><span class="p">(</span><span class="nv">firstPrizeWinsCount</span><span class="p">:</span> <span class="s">"2"</span><span class="p">,</span> <span class="nv">storeName</span><span class="p">:</span> <span class="s">"스파"</span><span class="p">,</span> <span class="nv">orderNumber</span><span class="p">:</span> <span class="s">"5"</span><span class="p">,</span> <span class="nv">region</span><span class="p">:</span> <span class="s">"서울 노원구"</span><span class="p">),</span>
        <span class="kt">LottoWinPointModelData</span><span class="p">(</span><span class="nv">firstPrizeWinsCount</span><span class="p">:</span> <span class="s">"2"</span><span class="p">,</span> <span class="nv">storeName</span><span class="p">:</span> <span class="s">"노다지복권방"</span><span class="p">,</span> <span class="nv">orderNumber</span><span class="p">:</span> <span class="s">"6"</span><span class="p">,</span> <span class="nv">region</span><span class="p">:</span> <span class="s">"인천 미추홀구"</span><span class="p">),</span>
        <span class="kt">LottoWinPointModelData</span><span class="p">(</span><span class="nv">firstPrizeWinsCount</span><span class="p">:</span> <span class="s">"2"</span><span class="p">,</span> <span class="nv">storeName</span><span class="p">:</span> <span class="s">"흥부네박터졌네"</span><span class="p">,</span> <span class="nv">orderNumber</span><span class="p">:</span> <span class="s">"7"</span><span class="p">,</span> <span class="nv">region</span><span class="p">:</span> <span class="s">"인천 계양구"</span><span class="p">),</span>
        <span class="kt">LottoWinPointModelData</span><span class="p">(</span><span class="nv">firstPrizeWinsCount</span><span class="p">:</span> <span class="s">"2"</span><span class="p">,</span> <span class="nv">storeName</span><span class="p">:</span> <span class="s">"오천억복권방"</span><span class="p">,</span> <span class="nv">orderNumber</span><span class="p">:</span> <span class="s">"8"</span><span class="p">,</span> <span class="nv">region</span><span class="p">:</span> <span class="s">"광주 서구"</span><span class="p">),</span>
        <span class="kt">LottoWinPointModelData</span><span class="p">(</span><span class="nv">firstPrizeWinsCount</span><span class="p">:</span> <span class="s">"2"</span><span class="p">,</span> <span class="nv">storeName</span><span class="p">:</span> <span class="s">"해피+24시편의점"</span><span class="p">,</span> <span class="nv">orderNumber</span><span class="p">:</span> <span class="s">"9"</span><span class="p">,</span> <span class="nv">region</span><span class="p">:</span> <span class="s">"광주 북구"</span><span class="p">),</span>
        <span class="kt">LottoWinPointModelData</span><span class="p">(</span><span class="nv">firstPrizeWinsCount</span><span class="p">:</span> <span class="s">"2"</span><span class="p">,</span> <span class="nv">storeName</span><span class="p">:</span> <span class="s">"토큰박스"</span><span class="p">,</span> <span class="nv">orderNumber</span><span class="p">:</span> <span class="s">"10"</span><span class="p">,</span> <span class="nv">region</span><span class="p">:</span> <span class="s">"경기 남양주시"</span><span class="p">),</span>
    <span class="p">]</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</code></pre></div></div>

<blockquote>
  <p>Configure the collection as a list</p>
</blockquote>

<p>Compositional layout을 사용하여 컬렉션 뷰의 appearance를 설정하기.<br />
  컴포지셔널 레이아웃은 sections, groups, items와 같은 컴포넌트를 조합하여 뷰를 생성함.<br />
  아이템이 가장 작은 단위, 아이템의 그룹이 group, 가장 큰 단위가 section.</p>

<ul>
  <li>스토리보드의 Collection view controller를 backing code에 연결하기.</li>
  <li>UICollectionViewController를 상속하는 뷰컨 클래스를 생성.</li>
  <li>스토리보드의 Custom Class의 클래스를 해당 파일로 변경해주어 클래스 인스턴스에 엑세스할 수 있도록 함.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">func</span> <span class="nf">listLayout</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">UICollectionViewCompositionalLayout</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">listConfiguration</span> <span class="o">=</span> <span class="kt">UICollectionLayoutListConfiguration</span><span class="p">(</span><span class="nv">appearance</span><span class="p">:</span> <span class="o">.</span><span class="n">grouped</span><span class="p">)</span>
    <span class="n">listConfiguration</span><span class="o">.</span><span class="n">showsSeparators</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="n">listConfiguration</span><span class="o">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="o">.</span><span class="n">clear</span>
    <span class="k">return</span> <span class="kt">UICollectionViewCompositionalLayout</span><span class="o">.</span><span class="nf">list</span><span class="p">(</span><span class="nv">using</span><span class="p">:</span> <span class="n">listConfiguration</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>UICollectionLayoutListConfiguration은 리스트의 섹션 부분을 생성함.</li>
  <li>생성한 list configuration을 사용하여 UICollectionViewCompositionalLayout을 리턴함.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
    
    <span class="k">let</span> <span class="nv">listLayout</span> <span class="o">=</span> <span class="nf">listLayout</span><span class="p">()</span>
    <span class="n">collectionView</span><span class="o">.</span><span class="n">collectionViewLayout</span> <span class="o">=</span> <span class="n">listLayout</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>뷰컨이 자신의 뷰 계층을 메모리에 로드한 후, 시스템이 ViewDidLoad() 함수를 호출함.</li>
  <li>viewDidLoad() 함수 안에서 리스트 레이아웃을 생성한 뒤 collectionViewLayout에 할당함.</li>
</ul>

<blockquote>
  <p>Configure the data source</p>
</blockquote>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">cellResistration</span> <span class="o">=</span> <span class="kt">UICollectionView</span><span class="o">.</span><span class="kt">CellRegistration</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">cell</span><span class="p">:</span> <span class="kt">UICollectionViewListCell</span><span class="p">,</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">,</span> <span class="nv">itemIdentifier</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">let</span> <span class="nv">lottoWinPoint</span> <span class="o">=</span> <span class="kt">LottoWinPointModelData</span><span class="o">.</span><span class="n">sampleLottoWinPointsData</span><span class="p">[</span><span class="n">indexPath</span><span class="o">.</span><span class="n">item</span><span class="p">]</span>
    <span class="k">var</span> <span class="nv">contentConfiguration</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="nf">defaultContentConfiguration</span><span class="p">()</span>
    <span class="n">contentConfiguration</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">lottoWinPoint</span><span class="o">.</span><span class="n">storeName</span>
    <span class="n">cell</span><span class="o">.</span><span class="n">contentConfiguration</span> <span class="o">=</span> <span class="n">contentConfiguration</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>CellRegistration을 사용하여 셀의 스타일과 내용(데이터)를 설정한다.</li>
  <li>defaultContentConfiguration()은 시스템 디폴트 스타일의 셀을 리턴함.</li>
  <li>contentConfigutation.text는 primary 스타일의 텍스트를 셀에 나타냄.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">typealias</span> <span class="kt">DataSource</span> <span class="o">=</span> <span class="kt">UICollectionViewDiffableDataSource</span><span class="o">&lt;</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="o">&gt;</span>
    
<span class="k">var</span> <span class="nv">dataSource</span><span class="p">:</span> <span class="kt">DataSource</span><span class="o">!</span>

<span class="n">dataSource</span> <span class="o">=</span> <span class="kt">DataSource</span><span class="p">(</span><span class="nv">collectionView</span><span class="p">:</span> <span class="n">collectionView</span><span class="p">,</span> <span class="nv">cellProvider</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="nv">collectionView</span><span class="p">:</span> <span class="kt">UICollectionView</span><span class="p">,</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">,</span> <span class="nv">itemIdentifier</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">collectionView</span><span class="o">.</span><span class="nf">dequeueConfiguredReusableCell</span><span class="p">(</span><span class="nv">using</span><span class="p">:</span> <span class="n">cellResistration</span><span class="p">,</span> <span class="nv">for</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">,</span> <span class="nv">item</span><span class="p">:</span> <span class="n">itemIdentifier</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div></div>

<ul>
  <li>typealias를 사용하여 길게 표현된 타입을 짧게 줄일 수 있음.</li>
  <li>dataSource 변수는 implicitly unwrapped optional 인데, (!를 사용하여 강제로 언래핑) 이것은 위에서처럼 값이 언제나 있을때만 사용해야 함.</li>
  <li>새로운 셀을 계속해서 생성할수도 있지만 앱 퍼포먼스를 위하여 리유저블 셀을 사용함.</li>
</ul>

<blockquote>
  <p>Apply a snapshot</p>
</blockquote>

<ul>
  <li>Diffable 데이터 소스는 스냅샷을 사용하여 데이터의 상태를 관리함.</li>
  <li>스냅샵은 특정 시간 지점의 데이터 상태를 보여줌.</li>
  <li>스냅샷을 사용하여 데이터를 보여주기 위해서, 스냅샷을 생성, 보여주길 원하는 데이터의 상태로 스냅샷을 채우고, 스냅샷을 UI에 적용함.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">typealias</span> <span class="kt">SnapShot</span> <span class="o">=</span> <span class="kt">NSDiffableDataSourceSnapshot</span><span class="o">&lt;</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="o">&gt;</span>

<span class="k">var</span> <span class="nv">snapshot</span> <span class="o">=</span> <span class="kt">SnapShot</span><span class="p">()</span> <span class="c1">// 스냅샷 생성</span>
<span class="n">snapshot</span><span class="o">.</span><span class="nf">appendSections</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span> <span class="c1">// 하나의 섹션 추가</span>
<span class="n">snapshot</span><span class="o">.</span><span class="nf">appendItems</span><span class="p">(</span><span class="kt">LottoWinPointModelData</span><span class="o">.</span><span class="n">sampleLottoWinPointsData</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">storeName</span> <span class="p">})</span> <span class="c1">// 샘플데이터 중 storeName으로 배열을 생성하여 아이템으로 추가</span>
<span class="n">dataSource</span><span class="o">.</span><span class="nf">apply</span><span class="p">(</span><span class="n">snapshot</span><span class="p">)</span> <span class="c1">// 데이터 소스에 적용하여 데이터의 변경사항이 UI에 적용되도록 함.</span>
<span class="n">collectionView</span><span class="o">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="n">dataSource</span> <span class="c1">// 컬렉션 뷰에 데이터소스 적용.</span>
</code></pre></div></div>

<h1 id="displaying-cell-info">Displaying cell info</h1>

<blockquote>
  <p>Organize view controllers</p>
</blockquote>

<p>UIKit 앱에서 뷰컨은 여러가지 역할을 담당한다. 데이터 소스와 관련된 behavior를 다른 파일로 분리시켜 뷰컨의 역할을 정리해보자.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">UIKit</span>

<span class="kd">extension</span> <span class="kt">WinPointsListViewController</span> <span class="p">{</span>
    <span class="kd">typealias</span> <span class="kt">DataSource</span> <span class="o">=</span> <span class="kt">UICollectionViewDiffableDataSource</span><span class="o">&lt;</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="o">&gt;</span>
    <span class="kd">typealias</span> <span class="kt">SnapShot</span> <span class="o">=</span> <span class="kt">NSDiffableDataSourceSnapshot</span><span class="o">&lt;</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="o">&gt;</span>
    
    <span class="kd">func</span> <span class="nf">cellRegistrationHandler</span><span class="p">(</span><span class="nv">cell</span><span class="p">:</span> <span class="kt">UICollectionViewListCell</span><span class="p">,</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">,</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">lottoWinPoints</span> <span class="o">=</span> <span class="kt">LottoWinPointModelData</span><span class="o">.</span><span class="n">sampleLottoWinPointsData</span><span class="p">[</span><span class="n">indexPath</span><span class="o">.</span><span class="n">item</span><span class="p">]</span>
        <span class="k">var</span> <span class="nv">contentConfiguration</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="nf">defaultContentConfiguration</span><span class="p">()</span>
        <span class="n">contentConfiguration</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">lottoWinPoints</span><span class="o">.</span><span class="n">storeName</span>
        <span class="n">contentConfiguration</span><span class="o">.</span><span class="n">secondaryText</span> <span class="o">=</span> <span class="s">"1등 당첨 횟수: </span><span class="se">\(</span><span class="n">lottoWinPoints</span><span class="o">.</span><span class="n">firstPrizeWinsCount</span><span class="se">)</span><span class="s">"</span>
        <span class="n">contentConfiguration</span><span class="o">.</span><span class="n">secondaryTextProperties</span><span class="o">.</span><span class="n">font</span> <span class="o">=</span> <span class="kt">UIFont</span><span class="o">.</span><span class="nf">preferredFont</span><span class="p">(</span><span class="nv">forTextStyle</span><span class="p">:</span> <span class="o">.</span><span class="n">caption1</span><span class="p">)</span>
        <span class="n">cell</span><span class="o">.</span><span class="n">contentConfiguration</span> <span class="o">=</span> <span class="n">contentConfiguration</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>WinPointsListViewController+DataSource라는 이름의 파일을 생성.</li>
  <li>cellRegistrationHandler 함수를 작성.</li>
  <li>WinPointsListViewController에 있는 cell registration 부분의 trailing closure를 아래 코드로 대체.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">cellResistration</span> <span class="o">=</span> <span class="kt">UICollectionView</span><span class="o">.</span><span class="kt">CellRegistration</span><span class="p">(</span><span class="nv">handler</span><span class="p">:</span> <span class="n">cellRegistrationHandler</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>뷰컨은 많은 역할을 담당하므로 그 코드가 길어질 수 있기 때문에, 위와 같이 extension을 사용하여 역할 별로 구분된 파일을 생성하여 에러를 찾기 쉽고 새 기능을 쉽게 추가할 수 있도록 해야함.</li>
</ul>

<h1 id="making-reminders-identifiable">Making reminders identifiable</h1>

<p>Diffable data source는 컬렉션 뷰의 아이템들이 가지는 identifier를 담은 리스트를 가지고 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">LottoWinPointModelData</span><span class="p">:</span> <span class="kt">Codable</span><span class="p">,</span> <span class="kt">LottoWinPoint</span><span class="p">,</span> <span class="kt">Identifiable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kt">UUID</span><span class="p">()</span><span class="o">.</span><span class="n">uuidString</span>
<span class="p">}</span>

<span class="kt">LottoWinPointModelData</span><span class="o">.</span><span class="kt">ID</span>
</code></pre></div></div>

<ul>
  <li>Identifiable 프로토콜을 사용하려면 id 속성이 필수로 필요.</li>
  <li>structure이름.ID는 Identifiable 프로토콜의 연관속성으로 위 코드에서는 String의 type alias가 됨.</li>
</ul>

<blockquote>
  <p>Create functions for accessing the model</p>
</blockquote>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// extension Array where Element == LottoWinPointModelData</span>
<span class="kd">extension</span> <span class="p">[</span><span class="kt">LottoWinPointModelData</span><span class="p">]</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">indexOfWinPoint</span><span class="p">(</span><span class="n">widhId</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">LottoWinPointModelData</span><span class="o">.</span><span class="kt">ID</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">Self</span><span class="o">.</span><span class="kt">Index</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="nf">firstIndex</span><span class="p">(</span><span class="nv">where</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span> <span class="p">})</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">fatalError</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">index</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">lottoWinPoint</span><span class="p">(</span><span class="n">withId</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">LottoWinPointModelData</span><span class="o">.</span><span class="kt">ID</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">LottoWinPointModelData</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="n">lottoWinPoints</span><span class="o">.</span><span class="nf">indexOfWinPoint</span><span class="p">(</span><span class="nv">widhId</span><span class="p">:</span> <span class="n">id</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lottoWinPoints</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">updateLottoWinPoint</span><span class="p">(</span><span class="n">_</span> <span class="nv">lottoWinPoint</span><span class="p">:</span> <span class="kt">LottoWinPointModelData</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="n">lottoWinPoints</span><span class="o">.</span><span class="nf">indexOfWinPoint</span><span class="p">(</span><span class="nv">widhId</span><span class="p">:</span> <span class="n">lottoWinPoint</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
    <span class="n">lottoWinPoints</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">lottoWinPoint</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>커스텀 타입 ‘LottoWinPointModelData’ 타입 배열의 extension 생성.</li>
  <li>배열의 요소가 LottoWinPointModelData 타입일 경우 이 익스텐션 안에 작성된 indexOfWinPoint(withId:) 함수를 사용하여 해당 아이디를 가진 요소의 index를 얻을 수 있게 됨.</li>
  <li>lottoWinPoint(withId:), updateLottoWinPoint() 함수를 사용하여 각 lottoWinPoint의 id 값으로 배열안의 인덱스 값을 얻을 수 있음. 이 방식으로 lotto win point 데이터를 가져오거나 업데이트 하도록 함.</li>
</ul>

<blockquote>
  <p>Wire a target-action pair</p>
</blockquote>

<p>Target-action은 디자인 패턴인데, 이벤트가 발생하면 한 객체가 이벤트를 실행하기 위해 다른 객체에 메세지를 보낸다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">UIKit</span>

<span class="kd">class</span> <span class="kt">LottoWinPointLikedButton</span><span class="p">:</span> <span class="kt">UIButton</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">LottoWinPoint</span><span class="o">.</span><span class="kt">ID</span><span class="p">?</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>커스텀 UIButton 클래스를 생성한 뒤, id 속성을 추가한다.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Foundation</span>

<span class="kd">extension</span> <span class="kt">WinPointsListViewController</span> <span class="p">{</span>
    <span class="kd">@objc</span> <span class="kd">func</span> <span class="nf">didPressLikedButton</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">LottoWinPointLikedButton</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">id</span> <span class="o">=</span> <span class="n">sender</span><span class="o">.</span><span class="n">id</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="nf">likeLottoWinPoint</span><span class="p">(</span><span class="nv">withId</span><span class="p">:</span> <span class="n">id</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>WinPointsListViewController+Actions 파일을 생성한 뒤, 뷰컨의 액션 관련 코드를 분리해줍니다.</li>
  <li>didPressLikedButton() 함수를 작성하여 해당 버튼의 id를 가져와서 likeLottoWinPoint()를 실행.</li>
</ul>

<blockquote>
  <p>Breakpoint 사용해보기</p>
</blockquote>

<ul>
  <li>liked button을 탭 했을 때 아무일도 일어나지 않아서 이 action이 동작하는지 확인이 필요함.</li>
  <li>버튼이 탭 되었을 때 업데이트하는 함수 call 부분에 breakpoint를 추가하고 다시 동작시킴.</li>
  <li>break point에 멈추기 때문에 함수가 호출된다는 것은 알 수 있음.</li>
  <li>함수 호출이 문제가 아니라, 변경된 사항을 보여주기 위해 새 스냅샷을 생성해야 함.</li>
</ul>

<blockquote>
  <p>Update the snapshot</p>
</blockquote>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">updateSnapshot</span><span class="p">(</span><span class="n">reloading</span> <span class="nv">ids</span><span class="p">:</span> <span class="p">[</span><span class="kt">LottoWinPoint</span><span class="o">.</span><span class="kt">ID</span><span class="p">]</span> <span class="o">=</span> <span class="p">[])</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">snapshot</span> <span class="o">=</span> <span class="kt">SnapShot</span><span class="p">()</span>
    <span class="n">snapshot</span><span class="o">.</span><span class="nf">appendSections</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">snapshot</span><span class="o">.</span><span class="nf">appendItems</span><span class="p">(</span><span class="n">lottoWinPoints</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">id</span> <span class="p">})</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">ids</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
        <span class="n">snapshot</span><span class="o">.</span><span class="nf">reloadItems</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">dataSource</span><span class="o">.</span><span class="nf">apply</span><span class="p">(</span><span class="n">snapshot</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>파라미터에 빈 배열을 기본값으로 줌으로써 viewDidLoad() 함수에서 ids 값 없이 호출할 수 있도록 함. viewDidLoad()에서는 ids 값없이 호출하여 스냅샷이 리로드되지 않고, updateSnapshot(reloading: [id]) 와 같이 id 값이 파라미터로 들어와 호출되면 스냅샷이 리로드 되도록 함.</li>
</ul>

<blockquote>
  <p>Make the action accessible</p>
</blockquote>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">lottoWinPointLikedValue</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="kt">NSLocalizedString</span><span class="p">(</span><span class="s">"Liked"</span><span class="p">,</span> <span class="nv">comment</span><span class="p">:</span> <span class="s">"Lotto win point liked value"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">lottoWinPointNotLikedValue</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="kt">NSLocalizedString</span><span class="p">(</span><span class="s">"Not Liked"</span><span class="p">,</span> <span class="nv">comment</span><span class="p">:</span> <span class="s">"Lotto win point not liked value"</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">cellRegistrationHandler</span><span class="p">(</span><span class="nv">cell</span><span class="p">:</span> <span class="kt">UICollectionViewListCell</span><span class="p">,</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">,</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">LottoWinPoint</span><span class="o">.</span><span class="kt">ID</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">lottoWinPoint</span> <span class="o">=</span> <span class="nf">lottoWinPoint</span><span class="p">(</span><span class="nv">withId</span><span class="p">:</span> <span class="n">id</span><span class="p">)</span>
    
    <span class="n">cell</span><span class="o">.</span><span class="n">accessibilityCustomActions</span> <span class="o">=</span> <span class="p">[</span><span class="nf">likedButtonAccessibilityAction</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">lottoWinPoint</span><span class="p">)]</span>
    <span class="n">cell</span><span class="o">.</span><span class="n">accessibilityValue</span> <span class="o">=</span> <span class="n">lottoWinPoint</span><span class="o">.</span><span class="n">isLiked</span> <span class="p">?</span> <span class="nv">lottoWinPointLikedValue</span> <span class="p">:</span> <span class="n">lottoWinPointNotLikedValue</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kd">func</span> <span class="nf">likedButtonAccessibilityAction</span><span class="p">(</span><span class="k">for</span> <span class="nv">lottoWinPoint</span><span class="p">:</span> <span class="kt">LottoWinPoint</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UIAccessibilityCustomAction</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">name</span> <span class="o">=</span> <span class="kt">NSLocalizedString</span><span class="p">(</span><span class="s">"Toggle completion"</span><span class="p">,</span> <span class="nv">comment</span><span class="p">:</span> <span class="s">"Lotto win point accessibility label"</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">action</span> <span class="o">=</span> <span class="kt">UIAccessibilityCustomAction</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">action</span> <span class="k">in</span>
        <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="nf">likeLottoWinPoint</span><span class="p">(</span><span class="nv">withId</span><span class="p">:</span> <span class="n">lottoWinPoint</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">action</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>위와 같이 Accessibility를 추가하고 Accessibility inspector를 사용하여 시뮬레이터로 테스트할 수 있음.</li>
</ul>

<h1 id="displaying-reminder-details">Displaying reminder details</h1>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">LottoWinPointViewController</span><span class="p">:</span> <span class="kt">UICollectionViewController</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">lottoWinPoint</span><span class="p">:</span> <span class="kt">LottoWinPoint</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">lottoWinPoint</span><span class="p">:</span> <span class="kt">LottoWinPoint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">lottoWinPoint</span> <span class="o">=</span> <span class="n">lottoWinPoint</span>
        <span class="k">var</span> <span class="nv">listConfiguration</span> <span class="o">=</span> <span class="kt">UICollectionLayoutListConfiguration</span><span class="p">(</span><span class="nv">appearance</span><span class="p">:</span> <span class="o">.</span><span class="n">insetGrouped</span><span class="p">)</span>
        <span class="n">listConfiguration</span><span class="o">.</span><span class="n">showsSeparators</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="k">let</span> <span class="nv">listLayout</span> <span class="o">=</span> <span class="kt">UICollectionViewCompositionalLayout</span><span class="o">.</span><span class="nf">list</span><span class="p">(</span><span class="nv">using</span><span class="p">:</span> <span class="n">listConfiguration</span><span class="p">)</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">collectionViewLayout</span><span class="p">:</span> <span class="n">listLayout</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Swift의 서브클래스는 초기화 과정에서 슈퍼클래스의 designated initializers를 호출해야 함.</li>
</ul>

<blockquote>
  <p>Display the detail view</p>
</blockquote>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">override</span> <span class="kd">func</span> <span class="nf">collectionView</span><span class="p">(</span><span class="n">_</span> <span class="nv">collectionView</span><span class="p">:</span> <span class="kt">UICollectionView</span><span class="p">,</span> <span class="n">shouldSelectItemAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">id</span> <span class="o">=</span> <span class="n">lottoWinPoints</span><span class="p">[</span><span class="n">indexPath</span><span class="o">.</span><span class="n">item</span><span class="p">]</span><span class="o">.</span><span class="n">id</span>
    <span class="nf">pushDetailViewForLottoWinPoint</span><span class="p">(</span><span class="nv">withId</span><span class="p">:</span> <span class="n">id</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">pushDetailViewForLottoWinPoint</span><span class="p">(</span><span class="n">withId</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">LottoWinPoint</span><span class="o">.</span><span class="kt">ID</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">reminder</span> <span class="o">=</span> <span class="nf">reminder</span><span class="p">(</span><span class="nv">withId</span><span class="p">:</span> <span class="n">id</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">viewController</span> <span class="o">=</span> <span class="kt">LottoWinPointViewController</span><span class="p">(</span><span class="nv">lottoWinPoint</span><span class="p">:</span> <span class="n">lottoWinPoint</span><span class="p">)</span>
    <span class="n">navigationController</span><span class="p">?</span><span class="o">.</span><span class="nf">pushViewController</span><span class="p">(</span><span class="n">viewController</span><span class="p">,</span> <span class="nv">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>디테일 뷰는 리스트의 셀을 선택하면 보여짐.</li>
  <li>해당 Lotto win point의 아이디 값을 사용하여 디테일 정보를 가져옴.</li>
  <li>생성해둔 LottoWinPointViewController(디테일 뷰)에 lotto win point 정보를 넣어 view controller 인스턴스를 생성.</li>
  <li>네비게이션 스택에 푸시해주기.</li>
  <li>collectionView(_ collectionView: UICollectionView, shouldSelectItemAt indexPath: IndexPath) 함수를 사용하여 해당 셀이 선택되었을 때 pushDetailViewForLottoWinPoint 함수가 실행되도록 함. 이때 선택이 되었는지를 표시하지 않기 때문에 false를 리턴함.</li>
  <li>Main 스토리보드로 이동하여 Win point list view controller scene을 선택하고 Editor - Embed in - navigation controller를 선택하여 네비게이션 컨트롤러를 생성</li>
  <li>빌드하여 디테일 뷰를 확인하기.</li>
</ul>

<h1 id="getting-ready-for-editing">Getting ready for editing</h1>

<blockquote>
  <p>Add an edit button</p>
</blockquote>

<ul>
  <li>UIViewController의 서브클래스는 editButtonItem 속성을 가지고 있습니다. 이 속성을 사용하여 편집 모드를 껐다/켰다 할 수 있습니다.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
    
    <span class="n">navigationItem</span><span class="o">.</span><span class="n">rightBarButtonItem</span> <span class="o">=</span> <span class="n">editButtonItem</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>유저가 Edit 버튼을 탭하면 시스템은 setEditing(_:animated:) 함수를 호출합니다. 이 함수를 override하여 디테일뷰를 뷰/편집 모드로 전환합니다.</li>
</ul>

<h1 id="using-content-views">Using Content Views</h1>

<blockquote>
  <p>Create a reusable layout function</p>
</blockquote>

<p>UIKit view는 UI를 생성하기 위해 사용되는 아주 기초적인 빌딩블럭이다. UIKit이 제공하는 subclass를 사용하여 라벨, 버튼 등의 일반적인 인터페이스 요소들을 만들 수 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">UIView</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">addPinnedSubview</span><span class="p">(</span>
        <span class="n">_</span> <span class="nv">subview</span><span class="p">:</span> <span class="kt">UIView</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="kt">CGFloat</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">,</span>
        <span class="nv">insets</span><span class="p">:</span> <span class="kt">UIEdgeInsets</span> <span class="o">=</span> <span class="kt">UIEdgeInsets</span><span class="p">(</span><span class="nv">top</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="nv">bottom</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="mi">8</span><span class="p">)</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="nf">addSubview</span><span class="p">(</span><span class="n">subview</span><span class="p">)</span>
        <span class="n">subview</span><span class="o">.</span><span class="n">translatesAutoresizingMaskIntoConstraints</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="n">subview</span><span class="o">.</span><span class="n">topAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">topAnchor</span><span class="p">,</span> <span class="nv">constant</span><span class="p">:</span> <span class="n">insets</span><span class="o">.</span><span class="n">top</span><span class="p">)</span><span class="o">.</span><span class="n">isActive</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="n">subview</span><span class="o">.</span><span class="n">leadingAnchor</span><span class="o">.</span><span class="nf">constraint</span><span class="p">(</span><span class="nv">equalTo</span><span class="p">:</span> <span class="n">leadingAnchor</span><span class="p">,</span> <span class="nv">constant</span><span class="p">:</span> <span class="n">insets</span><span class="o">.</span><span class="n">left</span><span class="p">)</span><span class="o">.</span><span class="n">isActive</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>UIView의 addSubview(_:) 메서드는 슈퍼뷰의 가장 아래 계층에 sub view를 추가함.</li>
  <li>시스템이 자동으로 constraint를 생성하지만, 환경(사이즈, 스크린 방향)에 따라 다른 contraint를 뷰에 적용하지 않기 때문에 false 처리 해줌.</li>
  <li>UIKit의 constraint syntax를 사용하여 슈퍼뷰의 top 부분에 sub view를 pin함.</li>
</ul>

<blockquote>
  <p>Create a custom view with a text field</p>
</blockquote>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">UIKit</span>

<span class="kd">class</span> <span class="kt">TextFieldContentView</span><span class="p">:</span> <span class="kt">UIView</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">textField</span> <span class="o">=</span> <span class="kt">UITextField</span><span class="p">()</span>
    
    <span class="k">override</span> <span class="k">var</span> <span class="nv">intrinsicContentSize</span><span class="p">:</span> <span class="kt">CGSize</span> <span class="p">{</span>
        <span class="kt">CGSize</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">44</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">frame</span><span class="p">:</span> <span class="o">.</span><span class="n">zero</span><span class="p">)</span> <span class="c1">// 1</span>
        <span class="nf">addPinnedSubView</span><span class="p">(</span><span class="n">textField</span><span class="p">,</span> <span class="nv">insets</span><span class="p">:</span> <span class="kt">UIEdgeInsets</span><span class="p">(</span><span class="nv">top</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="nv">bottom</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="mi">16</span><span class="p">))</span> <span class="c1">// 2</span>
    <span class="p">}</span>
    
    <span class="kd">required</span> <span class="nf">init</span><span class="p">?(</span><span class="nv">coder</span><span class="p">:</span> <span class="kt">NSCoder</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">fatalError</span><span class="p">(</span><span class="s">"init(coder:) has not been implemented"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <ol>
      <li>처음에는 프레임 사이즈 없이 텍스트 필드를 초기화 함.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>텍스트 필드는 top에 pin되고, 16의 horizontal padding을 가짐. top, bottom inset이 0이기 때문에 super view의 height 만큼 늘어나게 됨.</li>
    </ol>
  </li>
</ul>

<blockquote>
  <p>Create a custom view with a text field</p>
</blockquote>

<ul>
  <li>이 앱에서는, UIView의 서브클래스를 커스텀하여 편집화면에서 사용할 컨트롤을 만든다.</li>
  <li>
    <p>UIKit configurations의 스타일과 power를 사용하기 위해서 커스텀 서브 클래스가 UIContentView 프로토콜을 따라야 한다.</p>

    <blockquote>
      <p><b>Configurations</b><br />
  Configurations를 사용하여 셀과 뷰의 내용, appearance를 상세히 정할 수 있다.<br />
  뷰의 상태가 변경될 때 자동으로 업데이트되어 뷰가 해당 상태의 새로운 스타일을 반영할 수 있도록 함.</p>
    </blockquote>
  </li>
</ul>

<blockquote>
  <p>Conform to the content view protocol</p>
</blockquote>

<ul>
  <li>UIContentView 프로토콜을 따르는 객체는 UIContentConfiguration 타입의 configuration 속성을 가져야 한다.</li>
  <li>이 앱에서 사용할 configuration은 텍스트 필드의 값인 text 속성을 가진다. text 속성을 가진 커스텀 UIContentConfiguration 타입을 생성하자.</li>
</ul>

<h1 id="editing-reminders">Editing reminders</h1>

<ul>
  <li>workingReminder 라는 변수를 생성. 사용자가 편집 모드에서 workingReminder에 변경 사항을 일으키면 이 변경된 사항을 reminder에 복사해서 뷰 모드에서 그 데이터들이 보여지도록 함.</li>
</ul>]]></content><author><name>Mirae</name></author><category term="TIL" /><summary type="html"><![CDATA[Creating a list view Add a collention view controller 뷰컨트롤러(이하 ‘뷰컨’)는 뷰와 데이터 모델 사이에 다리 역할을 한다. 각 뷰컨은 하나의 뷰 계층을 관리하는 역할을 담당한다. 뷰의 컨텐츠를 업데이트하고, UI에 일어난 이벤트를 관리한다. Interface Builder를 사용하여 컬렉션 뷰컨트롤러를 생성해보자. 컬렉션뷰는 그리드, 행, 열, 또는 테이블의 형태로 셀을 보여준다. Collection view controller scene을 추가한다. 생성된 collection view의 cell 템플릿을 제거한다. (셀을 코드에서 정의할 것이기 때문.) Attribute inspector에서 is initial view controller 체크박스를 체크하여 해당 씬을 스토리보드의 엔트리 포인트로 설정 (앱이 스토리보드를 로드할 때 가장 먼저 로드됨.)]]></summary></entry><entry><title type="html">SwiftUI Tutorials</title><link href="http://localhost:4000/til/2024-04-09-swiftui-concepts-tutorials.html" rel="alternate" type="text/html" title="SwiftUI Tutorials" /><published>2024-04-09T00:00:00+09:00</published><updated>2024-04-09T00:00:00+09:00</updated><id>http://localhost:4000/til/swiftui-concepts-tutorials</id><content type="html" xml:base="http://localhost:4000/til/2024-04-09-swiftui-concepts-tutorials.html"><![CDATA[<h1 id="색-정의하기">색 정의하기</h1>
<blockquote>
  <p>Define colors in the asset catalog</p>
</blockquote>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="c1">// global property</span>
<span class="k">let</span> <span class="nv">gradientColors</span><span class="p">:</span> <span class="p">[</span><span class="kt">Color</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="o">.</span><span class="n">gradientTop</span><span class="p">,</span>
    <span class="o">.</span><span class="n">gradientBottom</span>
<span class="p">]</span>

<span class="kd">struct</span> <span class="kt">ContentView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>에셋 카탈로그에 ‘GradientTop’, ‘GradientBottom’라는 이름의 Color set을 추가했습니다.<br />
Xcode가 자동으로 카멜케이스 스타일의 컬러 밸류를 생성합니다. (.gradientTop, .gradientBottom)</p>
<blockquote>
  <p>‘Gradient_Top’이라는 이름도 .gradientTop으로 변환됩니다.
gradientColors 속성은 최상단 레벨에 작성되었고 이런 프로퍼티(=속성)을 글로벌 프로퍼티라고 합니다.<br />
글로벌 프로퍼티는 모든 파일, 모든 코드에서 사용할 수 있게 됩니다.</p>
</blockquote>

<h1 id="text-뷰">Text 뷰</h1>

<p>Text 뷰는 읽기 전용 텍스트를 보여주는 뷰입니다. 텍스트 뷰는 타이틀과 같은 짧은 String, 또는 글의 내용과 같이 긴 String을 컨텐츠로 가질 수 있습니다.</p>

<h1 id="mutating-함수">mutating 함수</h1>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 뷰가 새 레시피를 추가하는 화면을 보이도록 상태를 변경하는 함수</span>
<span class="k">mutating</span> <span class="kd">func</span> <span class="nf">presentAddRecipe</span><span class="p">(</span><span class="nv">sidebar</span><span class="p">:</span> <span class="kt">SidebarItem</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">recipe</span> <span class="o">=</span> <span class="kt">Recipe</span><span class="o">.</span><span class="nf">emptyRecipe</span><span class="p">()</span>
    <span class="c1">// ...</span>
    <span class="n">shouldSaveChanges</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="n">isPresented</span> <span class="o">=</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div></div>
<p>함수가 위치한 structure 안에 정의된 변수인 shouldSaveChanges, isPresented의 값을 변경시키기 때문에 mutating 키워드를 사용하여 작성함</p>

<h1 id="sheet-modifier">.Sheet modifier</h1>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="nf">sheet</span><span class="p">(</span><span class="nv">isPresented</span><span class="p">:</span> <span class="err">$</span><span class="n">recipeEditorConfig</span><span class="o">.</span><span class="n">isPresented</span><span class="p">,</span>
<span class="nv">onDismiss</span><span class="p">:</span> <span class="n">didDismissEditor</span><span class="p">)</span> <span class="p">{</span>
<span class="kt">RecipeEditor</span><span class="p">(</span><span class="nv">config</span><span class="p">:</span> <span class="err">$</span><span class="n">recipeEditorConfig</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>위의 sheet modifier는 recipeEditorConfig.isPresented 값을 바인딩으로 받는다.<br />
그러므로 isPresented 값을 read / write 할 수 있게 된다. 만약 사용자가 아래 방향으로 스와이핑하여 시트가 아래로 내려가면,<br />
isPresented의 값이 false로 변경되고, SwiftUI가 뷰를 다시 초기화하고, 다시 그린다. 그러하여 더이상 sheet가 올라와있지 않게 된다.</p>

<h1 id="design-a-custom-control">Design a custom control</h1>

<p>커스텀 컨트롤을 구현하기 전에 생각해 볼 것이 있다.<br />
어떤 데이터가 필요한지, 그 데이터를 사용하여 뭘 하는지, 그리고 데이터를 뷰에 어떻게 보여줄 것인지이다.</p>

<h1 id="specifying-the-source-of-truth">Specifying the source of truth</h1>

<p>이 샘플 앱은 커스텀 뷰인 DetailView에서 레시피의 세부사항을 보여주는데, DetailView는 레시피의 id만 알고 있다. 
레시피의 세부사항은 recipe box라는 데이터 스토어에 담겨 있는데, 이 세부사항을 가져와 DetailView에서 보여주기 위해 커스텀 바인딩을 사용한다.
DetailView에서 State를 사용하여 원천데이터를 정의하는 것이 아니고, 데이터 스토어에서 커스텀 바인딩과 id를 통해 데이터를 가져오는 것이다.</p>

<blockquote>
  <p>Note
커스텀을 바인딩은 state 변수로 원천데이터를 정의할 수 없을 떄, state object를 사용하여 모델 데이터를 공유할 수 없을 때만 사용한다.</p>
</blockquote>

<h2 id="여기서는-왜-커스텀-바인딩을-사용했는가">여기서는 왜 커스텀 바인딩을 사용했는가?</h2>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="k">var</span> <span class="nv">recipe</span><span class="p">:</span> <span class="kt">Binding</span><span class="o">&lt;</span><span class="kt">Recipe</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kt">Binding</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">id</span> <span class="o">=</span> <span class="n">recipeId</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">recipeBox</span><span class="o">.</span><span class="nf">recipe</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">id</span><span class="p">)</span> <span class="p">??</span> <span class="kt">Recipe</span><span class="o">.</span><span class="nf">emptyRecipe</span><span class="p">()</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kt">Recipe</span><span class="o">.</span><span class="nf">emptyRecipe</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="nv">set</span><span class="p">:</span> <span class="p">{</span> <span class="n">updatedRecipe</span> <span class="k">in</span>
            <span class="n">recipeBox</span><span class="o">.</span><span class="nf">update</span><span class="p">(</span><span class="n">updatedRecipe</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>state 변수를 정의하는 대신, recipe라는 computed property를 선언했다.
recipe는 Recipe를 리턴하지 않고, Recipe 타입의 커스텀 바인딩을 리턴한다.</p>

<h2 id="내가-작성한-코드와-다른점">내가 작성한 코드와 다른점</h2>

<ul>
  <li>
    <p>이 샘플 앱은 총 3개의 네비게이션 층을 가지고 있다. 카테고리 등을 선택할 수 있는 side bar 부분, 레시피 리스트 부분, 레시피 디테일 부분. 이 세가지의 네비게이션 층을 파일로 생성하였다. 그리고 그 안에서 세부 뷰들을 나눠 파일을 만들었다. 그렇게 하므로써 선언형 코드의 장점을 극대화했다. 전에 내가 작성했던 코드는 물론 더 복잡한 네비게이션 계층을 가지고 있기 때문에 똑같이 작성할 수는 없겠지만, 뷰에 적용될 데이터를 가져오지 못했거나 없을 경우 나타나는 뷰와 데이터가 있을 경우 나타나는 뷰를 한 파일에 작성하고 (DetailView), 데이터가 있을 경우 나타나는 뷰 (RecipeDetailView)를 따로 작성하여, 데이터 유무에 따라 어떤 뷰가 나타날지 한번에 볼 수 있도록 코드를 작성한 것이 눈에 띄였다. (나도 데이터가 없을 경우 나타나는 뷰를 따로 작성하긴 했지만, 데이터가 있을 경우의 뷰는 동일 파일에 작성했었다.)</p>
  </li>
  <li>
    <p>RecipeDetailView와 같은 경우 아래와 같이 작성되었는데, TopView(), BottomView() 구조체를 같은 파일에 private struct 로 작성한 뒤 각 뷰의 필요한 구조체는 따로 다른 파일에 작성하여 한눈에 볼 수 있도록 한 것이 인상 깊었다.</p>
    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">RecipeDetailView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
  <span class="kd">@Binding</span> <span class="k">var</span> <span class="nv">recipe</span><span class="p">:</span> <span class="kt">Recipe</span>
    
  <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
      <span class="kt">VStack</span> <span class="p">{</span>
          <span class="kt">TopView</span><span class="p">(</span><span class="nv">recipe</span><span class="p">:</span> <span class="err">$</span><span class="n">recipe</span><span class="p">)</span>
          <span class="kt">ScrollView</span> <span class="p">{</span>
              <span class="kt">BottomView</span><span class="p">(</span><span class="nv">recipe</span><span class="p">:</span> <span class="n">recipe</span><span class="p">)</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>Mirae</name></author><category term="TIL" /><summary type="html"><![CDATA[색 정의하기 Define colors in the asset catalog]]></summary></entry><entry><title type="html">앱 Scrumdinger 튜토리얼을 따라가며 정리</title><link href="http://localhost:4000/til/2023-10-10-Scrumdinger.html" rel="alternate" type="text/html" title="앱 Scrumdinger 튜토리얼을 따라가며 정리" /><published>2023-10-10T00:00:00+09:00</published><updated>2023-10-10T00:00:00+09:00</updated><id>http://localhost:4000/til/Scrumdinger</id><content type="html" xml:base="http://localhost:4000/til/2023-10-10-Scrumdinger.html"><![CDATA[<p><a href="https://developer.apple.com/tutorials/app-dev-training/managing-data-flow-between-views">Scrumdinger app tutorial</a></p>
<blockquote>
  <p>이 글은 위 튜토리얼을 따라가며 정리한 내용입니다.</p>
</blockquote>

<h1 id="create-a-color-theme">Create a color theme</h1>

<p>앱 전체에 일관된 스타일을 주기 위해 컬러 테마를 생성하기.</p>

<ul>
  <li>
    <p>뷰 파일이 아니지만 Foundation을 제거하고 SwiftUI를 import (SwiftUI 프레임워크의 Color을 사용하기 때문)</p>

    <blockquote>
      <p>SwiftUI는 컬러를 뷰 계층에 바로 추가할 수 있는 하나의 뷰 인스턴스로 취급함.</p>
    </blockquote>
  </li>
  <li>
    <p>String 타입의 값을 raw value로 가지는 enum 생성</p>
  </li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Theme</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">bubblegum</span>
    <span class="k">case</span> <span class="n">buttercup</span>
    <span class="k">case</span> <span class="n">indigo</span>
    <span class="k">case</span> <span class="n">lavender</span>
    
    <span class="k">var</span> <span class="nv">accentColor</span><span class="p">:</span> <span class="kt">Color</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="n">bubblegum</span><span class="p">,</span> <span class="o">.</span><span class="n">buttercup</span><span class="p">,</span> <span class="o">.</span><span class="nv">lavender</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="n">black</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">indigo</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="n">white</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<blockquote>
  <p>위와 같이 case 이름만 작성해주면 Swift가 자동으로 스트링 타입의 raw value를 생성함. 
enum 안에 switch self를 사용하여 case 별로 값을 리턴하는 컬러 프로퍼티를 생성</p>
</blockquote>

<h1 id="managing-data-flow-between-views">Managing data flow between views</h1>
<h2 id="source-of-truth">Source of truth</h2>
<blockquote>
  <p>source of truth == 원천데이터</p>
</blockquote>

<p>원천데이터를 사용하지 않으면 뷰에 나타나는 데이터가 불일치하는 버그가 생길 수 있음.<br />
데이터를 가지고 있는 요소를 한 장소에 보관하고 뷰들이 그 데이터에 접근하도록 함.<br />
앱 전체 코드를 통하는 원천데이터를 생성할 수도 있음. 원천 데이터를 정의하는 방식과 위치는 여러 뷰들 사이에서 공유되는 데이터인지, 변하는 데이터인지에 따라 다름.</p>

<h2 id="swift-property-wrappers">Swift property wrappers</h2>
<p>스위프트의 프로퍼티 래퍼를 사용하여 특정 행동을 하는 속성을 만들 수 있음.<br />
일반적으로 많이 사용되는 속성의 동작들을 캡슐화 해놓은 것.</p>

<p><b>State</b>는 그런 프로퍼티 래퍼중 하나로 뷰 안에서 원천데이터를 생성함.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@State</span>
</code></pre></div></div>
<p>사용자의 상호작용으로 @State 속성의 값이 변경될 수 있음. 이때 시스템은 이 새로운 값을 가진 버전의 뷰를 자동으로 다시 그림. state 속성은 일시적인 상태를 관리하는 것에 사용됨. (예: 버튼의 상태, 필터링 버튼, 현재 선택된 리스트 아이템..) 그렇기 떄문에 private으로 선언함. (한 뷰 안에서 일시적으로 변화되는 값들이기 때문에..) 같은 이유로 영속적으로 보관되어야 하는 데이터에는 사용하지 않음.</p>

<p>@State 프로퍼티 래퍼는 하나의 뷰 안에서 변경되는 원천 데이터를 담기 위해 사용되는데, 만약 여러개의 뷰 계층 속에서 같은 원천데이터를 사용하고 싶다면..?</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@Binding</span>
</code></pre></div></div>
<p><b>Binding</b>은 state 속성과 똑같이 원천데이터를 읽거나 값을 변경할 수 있음.<br />
@Binding은 데이터를 직접 담지 않고 원천 데이터와 뷰 사이에 양방향 커넥션을 생성함.<br />
이 커넥션은 하나의 데이터와 관련된 뷰들이 같은 데이터 상태를 가지도록 함. 
시스템은 원천데이터를 가진 부모뷰와 @Binding을 가진 자식뷰의 관계를 성립시킴.<br />
이때는 자식뷰, 부모뷰 모두 원천데이터를 읽거나, 수정할 수 있음. 만약 자식뷰가 read-only 속성을 가지고 있다면, 원천데이터를 보내기만 할 수 있음. (수정은 안됨.)
두 경우 모두, 프레임워크가 자동으로 뷰를 업데이트 함.</p>

<h1 id="making-classes-observable">Making classes observable</h1>
<h2 id="working-with-reference-types">Working with reference types</h2>
<p>@State 속성은 구조체나 열거형과 같은 value type 원천데이터만 정의할 수 있다.<br />
클래스와 같은 reference type인 원천데이터를 정의하려면 @State가 아닌 아래 세가지 프로퍼티 래퍼를 사용해야 한다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@ObservedObject</span> 
<span class="kd">@StateObject</span> 
<span class="kd">@EnvironmentObject</span>
</code></pre></div></div>
<p>이 프로퍼티 래퍼들을 사용하려면 먼저 원천데이터가 될 클래스를 observable한 상태로 만들어주어야 한다.</p>

<h2 id="making-a-class-observable">Making a class observable</h2>
<p>ObservableObject 프로토콜을 따르는 클래스를 생성하여 클래스를 observable 하도록 만들 수 있다. (observable의 사전적 의미 중 하나는 ‘관찰할 수 있는’이다. 클래스를 observable 하도록 만든다는 건, 다른 어떤 것들이 이 클래스를 관찰할 수 있도록 만든다는 것이다.)</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ScrumTimer</span><span class="p">:</span> <span class="kt">ObservableObject</span> <span class="p">{</span>
   <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">activeSpeaker</span> <span class="o">=</span> <span class="s">""</span>
   <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">secondsElapsed</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">secondsRemaining</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>이 클래스 안에서 위 세개의 속성들은 자신의 값이 변할 때 UI를 업데이트 해야한다. 이런 속성들은 @Published를 사용하여 정의한다. 이 published property의 값이 변경될 때 ScrumTimer가 자신을 관찰하고 있는 관찰자에게 이 변경사항을 알린다.</p>

<h2 id="monitoring-an-object-for-changes">Monitoring an object for changes</h2>
<p>ObservedObject, StateObject, EnvironmentObject 이 세가지의 속성 중 하나를 사용하여 SwiftUI가 observable 객체를 모니터링하도록 할 수 있다. 이 속성을 사용하여 정의된 프로퍼티는 원천데이터가 된다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">MeetingView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
   <span class="kd">@StateObject</span> <span class="k">var</span> <span class="nv">scrumTimer</span> <span class="o">=</span> <span class="kt">ScrumTimer</span><span class="p">()</span>
   <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>@StateObject 래퍼를 사용하여 observable 객체를 생성한다. App, Scene, View에서 스테이트 객체를 생성할 수 있다. 시스템이 스테이트 객체를 초기화하면 해당 스트럭처 또는 객체를 전달 받은 다른 뷰에서 해당 객체를 사용할 수 있다.</p>

<!--```swift-->
<!--struct ChildView: View {-->
<!--   @ObservedObject var timer: ScrumTimer-->
<!--   // ...-->
<!--}-->
<!--``` 여기부터 이어서 작성하기.. -->

<h1 id="managing-state-and-life-cycle">Managing state and life cycle</h1>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">MeetingFooterView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    
    <span class="k">let</span> <span class="nv">speakers</span><span class="p">:</span> <span class="p">[</span><span class="kt">ScrumTimer</span><span class="o">.</span><span class="kt">Speaker</span><span class="p">]</span>

    <span class="kd">private</span> <span class="k">var</span> <span class="nv">isLastSpeaker</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">speakers</span><span class="o">.</span><span class="nf">dropLast</span><span class="p">()</span><span class="o">.</span><span class="n">allSatisfy</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">isCompleted</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>🖍️ 이 뷰 안에서만 필요한 computed property이기 때문에 private으로 선언<br />
🖍️ dropLast()를 사용하여 speakers 배열의 마지막 요소를 제외한 배열을 리턴함.<br />
🖍️ allSatisfy()를 사용하여 마지막 speaker를 제외한 모든 speakers의 isCompleted 이 true라는 bool 값을 리턴함.</p>

<p><b>dropLast(_:)</b></p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="n">numbers</span><span class="o">.</span><span class="nf">dropLast</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="c1">// Prints "[1, 2, 3]"</span>
<span class="nf">print</span><span class="p">(</span><span class="n">numbers</span><span class="o">.</span><span class="nf">dropLast</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="c1">// Prints "[]"</span>
</code></pre></div></div>
<p>🖍️ 마지막 요소만 제외하거나, 제외할 요소의 수를 정할 수 있음. 위 코드에서는 2를 통과시켜 맨 뒤에서부터 배열의 요소 2개를 제외한 배열을 리턴
🖍️ 배열의 카운트보다 큰 수를 통과시킬 경우 빈 배열을 리턴</p>

<p><b>allSatisfy(_:)</b></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Sofia"</span><span class="p">,</span> <span class="s">"Camilla"</span><span class="p">,</span> <span class="s">"Martina"</span><span class="p">,</span> <span class="s">"Mateo"</span><span class="p">,</span> <span class="s">"Nicolás"</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">allHaveAtLeastFive</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">allSatisfy</span><span class="p">({</span> <span class="nv">$0</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">5</span> <span class="p">})</span>
<span class="c1">// allHaveAtLeastFive == true</span>
</code></pre></div></div>
<p>🖍️ 배열의 모든 요소가 5자 이상인 이름인지를 bool 값으로 리턴함.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Foundation</span>

<span class="c1">/// Keeps time for a daily scrum meeting. Keep track of the total meeting time, the time for each speaker, and the name of the current speaker.</span>

<span class="kd">@MainActor</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="kt">ScrumTimer</span><span class="p">:</span> <span class="kt">ObservableObject</span> <span class="p">{</span>
    <span class="c1">/// A struct to keep track of meeting attendees during a meeting.</span>
    <span class="kd">struct</span> <span class="kt">Speaker</span><span class="p">:</span> <span class="kt">Identifiable</span> <span class="p">{</span>
        <span class="c1">/// The attendee name.</span>
        <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
        <span class="c1">/// True if the attendee has completed their turn to speak.</span>
        <span class="k">var</span> <span class="nv">isCompleted</span><span class="p">:</span> <span class="kt">Bool</span>
        <span class="c1">/// Id for Identifiable conformance.</span>
        <span class="k">let</span> <span class="nv">id</span> <span class="o">=</span> <span class="kt">UUID</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>🖍️ 주석 /// 을 사용하여 Xcode에서 보여지는 문서를 작성할 수 있음</p>

<p><img src="/assets/images/writingDocs.png" alt="writingDocs" width="550" /><br /></p>

<h2 id="adopting-swift-concurrency">Adopting Swift Concurrency</h2>

<blockquote>
  <p>Swift 코드로 복잡한 비동기 작업을 단순화 해보자!</p>
</blockquote>

<p>SwiftUI 앱에서는 메인 스레드가 모든 UI 작업을 실행한다. 또, 탭하거나 스와이프하는 것과 같은 유저 이벤트를 처리한다. 앱이 제대로 작동하기 위해서는 모든 뷰 업데이트 작업과 이벤트 핸들러를 메인 스레드에서 실행해야 한다.<br />
하지만 만약 모든 작업을 메인 스레드에서 처리한다면 앱이 느린 것과 같이 느껴질 수 있다.<br />
만약 메인 스레드가 모든 코드를 처리하는 것을 기다려야 한다면, 앱이 느리거나 심지어 멈춘 것처럼 느껴질 수 있다.<br />
그렇기 때문에 가능한 작업은 백그라운드 스레드에서 실행하고, 꼭 필요한 작업을 메인 스레드에서 실행하며 균형을 맞춰야 한다.</p>

<p>디스크에 있는 데이터를 읽고, 디스크에 데이터를 입력하는 작업을 비동기적으로 작성해보자.<br />
이 작업에서는 스위프트의 비동기 함수, Task 타입, @MainActor 어노테이션을 사용할 것이다.</p>

<h3 id="defining-an-asynchronous-function">Defining an asynchronous function</h3>

<p>비동기 함수는 파라미터 리스트 뒤에 async 키워드를 추가하여 정의한다. 리턴값이 있을 경우 리턴 애로우 앞쪽에 표시한다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">UserStore</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">fetchParticipants</span><span class="p">()</span> <span class="n">asyns</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Participant</span><span class="p">]</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="calling-an-asynchronous-function">Calling an asynchronous function</h3>

<p>await 키워드를 사용하여 비동기 함수를 호출한다. await 키워드는 비동기적인 흐름, 문맥에서만 사용할 수 있다. 아래 UserStore 클래스는 비동기 함수인 refresh() 안에서 fetchParticipants() 함수를 await를 사용해서 호출하고 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">UserStore</span> <span class="p">{</span>

    <span class="kd">func</span> <span class="nf">refresh</span><span class="p">()</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">UserRecord</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">participants</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetchParticipants</span><span class="p">()</span>
        <span class="k">let</span> <span class="nv">records</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetchRecords</span><span class="p">(</span><span class="nv">participants</span><span class="p">:</span> <span class="n">participants</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">records</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="n">fetchParticipants</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Participant</span><span class="p">]</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
    <span class="kd">func</span> <span class="nf">fetchRecords</span><span class="p">(</span><span class="nv">participants</span><span class="p">:</span> <span class="p">[</span><span class="kt">Participant</span><span class="p">])</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">UserRecord</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>
<p>fetchParticipants()가 작업을 완료하는 동안 refresh() 함수는 잠시 멈춤. 
그동안 refresh()를 실행하는 스레드는 다른 작업을 할 수 있음. fetchParticipants()의 작업이 완료되면, 시스템은 refresh() 함수의 다음 라인을 실행함. fetchRecords(participants: participants) 함수가 호출할 때 fetchParticipants()의 리턴값을 사용할 수 있음. 비동기 함수를 사용하면 작성돼있는 순서로 코드를 실행함.</p>

<h3 id="creating-an-asynchronous-context">Creating an asynchronous context</h3>

<p>비동기 함수는 비동기적인 문맥상에서만 사용할 수 있다. 이 비동기적인 문맥은 거의 대부분 또 다른 비동기 함수나 클로저의 바디 부분이 될 것이다. 위 refresh() 함수가 비동기 함수로 작성되었기 때문에 또 다른 비동기 함수인 fetchParticipants()와 fetchRecords(participants:)를 호출할 수 있었다.<br />
동기적 문맥상에서 작동하는 API를 사용하는 것과 같은 동기적 문맥상에서 비동기 함수를 호출해야 하는 일이 빈번히 발생하는데, 이때 Task를 사용하여 비동기 함수를 호출 할 수 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">RefreshButton</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@Binding</span> <span class="k">var</span> <span class="nv">model</span><span class="p">:</span> <span class="kt">ViewModel</span>
    
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Buton</span><span class="p">(</span><span class="s">"Refresh"</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 버튼의 액션 부분에서는 비동기 함수를 호출 할 수 없다.</span>
            <span class="kt">Task</span> <span class="p">{</span>
                <span class="c1">// Task를 생성하여 액션 클로저 안에 비동기적 문맥을 생성하여 비동기 함수를 호출할 수 있다. </span>
                <span class="k">await</span> <span class="n">model</span><span class="o">.</span><span class="nf">refresh</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>refresh() 함수가 리턴값을 가지고 있지 않고, 에러를 던지고 있지 않기 때문에 위의 코드는 정상적으로 동작한다. Task { } 안에서 리턴값이나 에러에 대한 처리를 수동적으로 처리하지 않으면 코드가 정상적으로 작동하지 않을 수 있다.<br />
뷰 모더파이어인 onAppear(perform:)도 동기적 클로저의 또 다른 예다. SwiftUI의 task(priority:_:) 모더파이어를 사용하여 뷰가 나타날 때 비동기 함수를 실행할 수 있다. task의 생명주기는 task 모더파이어가 적용된 뷰의 생명주기와 같다. 뷰가 사라지면 진행중인 task가 취소된다.</p>

<h3 id="updating-the-user-interface">Updating the user interface</h3>

<p>@State 와 @Binding 속성의 값이 변경되면 뷰가 업데이트 된다. 그렇기 때문에 이 값들을 변경시키는 것은 메인 스레드에서 실행되어야 한다. 비동기 함수는 백그라운드 스레드에서 실행될 수 있기 때문에 위와 같은 동작을 하는 함수를 비동기 함수로 실행하는 것은 문제가 될 수 있다.<br />
Swift는 메인 스레드와의 상호작용을 돕기 위한 어노테이션인 @MainActor를 제공한다. @MainActor 어노테이션이 적용된 클래스의 속성의 변경은 모두 메인 스레드에서 다뤄지게 된다. 아래 코드에서 UserStore 는 ObservableObject이다. 그리고 users 는 퍼블리시드 속성이다. @MainActor를 사용했기 때문에 users 속성을 수정하는 동작은 메인스 스레드에서 일어나게 되고, 안전하게 뷰를 변경하는 @Binding과 함꼐 사용할 수 있게 된다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@MainActor</span>
<span class="kd">class</span> <span class="kt">UserStore</span><span class="p">:</span> <span class="kt">ObservableObject</span> <span class="p">{</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">users</span><span class="p">:</span> <span class="p">[</span><span class="kt">UserRecord</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="kd">func</span> <span class="nf">refresh</span><span class="p">()</span> <span class="k">async</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">participants</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetchParticipants</span><span class="p">()</span>
        <span class="k">let</span> <span class="nv">records</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetchRecords</span><span class="p">(</span><span class="nv">participants</span><span class="p">:</span> <span class="n">participants</span><span class="p">)</span>
        <span class="k">self</span><span class="o">.</span><span class="n">users</span> <span class="o">=</span> <span class="n">records</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">fetchParticipants</span><span class="p">()</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Participant</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[]</span> <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">fetchRecords</span><span class="p">(</span><span class="nv">participants</span><span class="p">:</span> <span class="p">[</span><span class="kt">Participant</span><span class="p">])</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">UserRecord</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[]</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="persisting-data">Persisting data</h3>

<ul>
  <li>커스텀 타입에 Codable conformance를 적용하려면 타입의 모든 stored properties가 Codable을 채택하고 있어야 함.</li>
  <li>@Published 속성은 뷰에 bind 되어 있음. binding을 사용하여 가장 최신의 데이터로 뷰를 업데이트 할 수 있음.</li>
  <li>ObservableObject 는 클래스에만 사용할 수 있는 프로토콜로, SwiftUI 뷰와 외부 모델 데이터를 연결함.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ScrumStore</span><span class="p">:</span> <span class="kt">ObservableObject</span> <span class="p">{</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">scrums</span><span class="p">:</span> <span class="p">[</span><span class="kt">DailyScrum</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="k">var</span> <span class="nv">fileURL</span><span class="p">()</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">URL</span> <span class="p">{</span>
        <span class="k">try</span> <span class="kt">FileManager</span><span class="o">.</span><span class="k">default</span><span class="o">.</span><span class="nf">url</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">documentDirectory</span><span class="p">,</span>
                                    <span class="nv">in</span><span class="p">:</span> <span class="o">.</span><span class="n">userDomainMask</span><span class="p">,</span>
                                    <span class="nv">appropriateFor</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
                                    <span class="nv">create</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">appendingPathComponent</span><span class="p">(</span><span class="s">"scrums.data"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>FileManager의 shared 인스턴스를 사용하여 현재 사용자의 문서 파일의 위치를 얻음.</li>
  <li>appendingPathComponent(_:) 함수를 호출하여 scrums.data 라는 이름의 파일의 URL을 리턴함</li>
  <li>파일 시스템의 데이터를 읽는 동작은 느릴 수 있음.</li>
  <li>파일 시스템으로부터 데이터를 읽어오는 동안, 시스템이 기다리지 않고 UI를 먼저 업데이트 하도록 함.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">load</span><span class="p">()</span> <span class="k">async</span> <span class="k">throws</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">task</span> <span class="o">=</span> <span class="kt">Tast</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>let constant에 Task를 담아서 후에 리턴값에 접근하거나 task로 부터 던져진 에러를 catch할 수 있도록 함.</li>
</ul>]]></content><author><name>Mirae</name></author><category term="TIL" /><summary type="html"><![CDATA[Scrumdinger app tutorial 이 글은 위 튜토리얼을 따라가며 정리한 내용입니다. Create a color theme]]></summary></entry><entry><title type="html">SwiftUI 이중 스티키 헤더</title><link href="http://localhost:4000/til/2023-09-06-stickyHeader.html" rel="alternate" type="text/html" title="SwiftUI 이중 스티키 헤더" /><published>2023-09-06T00:00:00+09:00</published><updated>2023-09-06T00:00:00+09:00</updated><id>http://localhost:4000/til/stickyHeader</id><content type="html" xml:base="http://localhost:4000/til/2023-09-06-stickyHeader.html"><![CDATA[<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">struct</span> <span class="kt">ContentView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">hidePointView</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">isFirstShown</span> <span class="o">=</span> <span class="kc">true</span>
    
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        
        <span class="kt">VStack</span><span class="p">(</span><span class="nv">spacing</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">ScrollView</span> <span class="p">{</span>
                <span class="kt">VStack</span><span class="p">(</span><span class="nv">spacing</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kt">LazyVStack</span><span class="p">(</span><span class="nv">pinnedViews</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">sectionHeaders</span><span class="p">],</span> <span class="nv">content</span><span class="p">:</span>  <span class="p">{</span>
                        <span class="kt">Section</span><span class="p">(</span><span class="nv">header</span><span class="p">:</span> <span class="n">tempClearHeader</span><span class="p">)</span> <span class="p">{</span>
                            <span class="n">videoView</span>
                        <span class="p">}</span>
                    <span class="p">})</span>
                    
                    <span class="kt">LazyVStack</span><span class="p">(</span><span class="nv">pinnedViews</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">sectionHeaders</span><span class="p">],</span> <span class="nv">content</span><span class="p">:</span> <span class="p">{</span>
                        
                        <span class="kt">Section</span><span class="p">(</span><span class="nv">header</span><span class="p">:</span> <span class="n">tabViewHeader</span><span class="p">)</span> <span class="p">{</span>
                            <span class="kt">Text</span><span class="p">(</span><span class="s">"리뷰 모아보기"</span><span class="p">)</span>
                                <span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="o">.</span><span class="nf">system</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="mi">18</span><span class="p">,</span> <span class="nv">weight</span><span class="p">:</span> <span class="o">.</span><span class="n">bold</span><span class="p">))</span>
                                <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="cm">/*@START_MENU_TOKEN@*/</span><span class="mi">100</span><span class="cm">/*@END_MENU_TOKEN@*/</span><span class="p">)</span>
                                <span class="o">.</span><span class="nf">padding</span><span class="p">(</span><span class="o">.</span><span class="n">horizontal</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
                        <span class="p">}</span>
                    <span class="p">})</span>
                    
                    <span class="kt">LazyVStack</span><span class="p">(</span><span class="nv">pinnedViews</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">sectionHeaders</span><span class="p">],</span> <span class="nv">content</span><span class="p">:</span> <span class="p">{</span>
                        <span class="kt">Section</span><span class="p">(</span><span class="nv">header</span><span class="p">:</span> <span class="n">categoryHeader</span><span class="p">)</span> <span class="p">{</span>
                            <span class="n">tabViewBody</span>
                        <span class="p">}</span>
                    <span class="p">})</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="o">.</span><span class="nf">overlay</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">top</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pointViewHeader</span>
                    <span class="o">.</span><span class="nf">opacity</span><span class="p">(</span><span class="n">hidePointView</span> <span class="p">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">padding</span><span class="p">(</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">background</span><span class="p">(</span><span class="o">.</span><span class="n">yellow</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">pointViewHeader</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">HStack</span> <span class="p">{</span>
            <span class="kt">Image</span><span class="p">(</span><span class="nv">systemName</span><span class="p">:</span> <span class="s">"globe"</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">imageScale</span><span class="p">(</span><span class="o">.</span><span class="n">large</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">foregroundStyle</span><span class="p">(</span><span class="o">.</span><span class="n">tint</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"PointView"</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">minWidth</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">maxWidth</span><span class="p">:</span> <span class="o">.</span><span class="n">infinity</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">50</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">foregroundColor</span><span class="p">(</span><span class="o">.</span><span class="n">white</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">background</span><span class="p">(</span><span class="o">.</span><span class="n">black</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">tabViewHeader</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">HStack</span> <span class="p">{</span>
            <span class="kt">Spacer</span><span class="p">()</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"영상 리뷰"</span><span class="p">)</span>
            <span class="kt">Spacer</span><span class="p">()</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"포토 리뷰"</span><span class="p">)</span>
            <span class="kt">Spacer</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">minWidth</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">maxWidth</span><span class="p">:</span> <span class="o">.</span><span class="n">infinity</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">50</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">foregroundColor</span><span class="p">(</span><span class="o">.</span><span class="n">white</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">background</span><span class="p">(</span><span class="o">.</span><span class="n">black</span><span class="p">)</span>
        
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">tabViewBody</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">ForEach</span><span class="p">(</span><span class="mi">0</span><span class="o">..&lt;</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span> <span class="n">row</span> <span class="k">in</span>
                <span class="kt">HStack</span><span class="p">(</span><span class="nv">spacing</span><span class="p">:</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kt">Spacer</span><span class="p">()</span>
                    <span class="kt">Rectangle</span><span class="p">()</span>
                        <span class="o">.</span><span class="nf">fill</span><span class="p">(</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
                        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">minWidth</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">maxWidth</span><span class="p">:</span> <span class="o">.</span><span class="n">infinity</span><span class="p">)</span>
                        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">240</span><span class="p">)</span>
                        <span class="o">.</span><span class="nf">padding</span><span class="p">([</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="o">.</span><span class="n">bottom</span><span class="p">])</span>
                    
                    
                    <span class="kt">Rectangle</span><span class="p">()</span>
                        <span class="o">.</span><span class="nf">fill</span><span class="p">(</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
                        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">minWidth</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">maxWidth</span><span class="p">:</span> <span class="o">.</span><span class="n">infinity</span><span class="p">)</span>
                        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">240</span><span class="p">)</span>
                        <span class="o">.</span><span class="nf">padding</span><span class="p">([</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="o">.</span><span class="n">bottom</span><span class="p">])</span>
                    
                    <span class="kt">Spacer</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">categoryHeader</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">HStack</span> <span class="p">{</span>
            <span class="kt">Spacer</span><span class="p">()</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"버튼"</span><span class="p">)</span>
            <span class="kt">Spacer</span><span class="p">()</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"버튼"</span><span class="p">)</span>
            <span class="kt">Spacer</span><span class="p">()</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"버튼"</span><span class="p">)</span>
            <span class="kt">Spacer</span><span class="p">()</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"버튼"</span><span class="p">)</span>
            <span class="kt">Spacer</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">minWidth</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">maxWidth</span><span class="p">:</span> <span class="o">.</span><span class="n">infinity</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">50</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">foregroundColor</span><span class="p">(</span><span class="o">.</span><span class="n">white</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">background</span><span class="p">(</span><span class="o">.</span><span class="n">green</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">videoView</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span><span class="p">(</span><span class="nv">spacing</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">Rectangle</span><span class="p">()</span>
                <span class="o">.</span><span class="nf">fill</span><span class="p">(</span><span class="o">.</span><span class="n">red</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">202</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">tempClearHeader</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">HStack</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"temp"</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">minWidth</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">maxWidth</span><span class="p">:</span> <span class="o">.</span><span class="n">infinity</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">50</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">foregroundColor</span><span class="p">(</span><span class="o">.</span><span class="n">white</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">background</span><span class="p">(</span><span class="o">.</span><span class="n">black</span><span class="p">)</span>
        <span class="o">.</span><span class="n">onDisappear</span> <span class="p">{</span>
            <span class="n">hidePointView</span><span class="o">.</span><span class="nf">toggle</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="n">onAppear</span> <span class="p">{</span>
            
            <span class="k">if</span> <span class="o">!</span><span class="n">isFirstShown</span> <span class="p">{</span>
                <span class="n">hidePointView</span><span class="o">.</span><span class="nf">toggle</span><span class="p">()</span>
            <span class="p">}</span>
            
            <span class="n">isFirstShown</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">ContentView_Previews</span><span class="p">:</span> <span class="kt">PreviewProvider</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">previews</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">ContentView</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>탭뷰 헤더는 VStack 사용해도 될 것 같음 -&gt; VStack 바깥에 ScrollView 있기 때문에 화면 밖으로 헤더가 사라져서 안됨.</li>
  <li>LazyVStack Pinned header를 특정 조건에 따라 나타나게 할 수 있을까?</li>
  <li>전체 LazyVStack을 pointView가 나타날때 아래로 내리면?</li>
  <li>header 부분만 내릴 수 있음</li>
  <li>all header pinned 가 되는 부분을 찾아야 함</li>
</ul>

<p><a href="https://stackoverflow.com/questions/73015997/swiftui-lazyvstack-pinnedviews-in-another">TrackableScrollView</a></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  ContentView.swift</span>
<span class="c1">//  StickyHeaderWithoutLazy</span>
<span class="c1">//</span>
<span class="c1">//  Created by Mirae on 9/6/23.</span>
<span class="c1">//  * overlay point view -&gt; 위 아래로 움직일 때 나타나는 뷰</span>
<span class="c1">//  * 맨 위에는 스티키로 하나 넣고</span>

<span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">struct</span> <span class="kt">ContentView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">allHeaderPinned</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">hidePointView</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">pullDownView</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">scrollOffset</span> <span class="o">=</span> <span class="mf">0.0</span>
    
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        
        <span class="kt">ScrollViewReader</span> <span class="p">{</span> <span class="n">scrollProxy</span> <span class="k">in</span>
            
            <span class="kt">OffsettableScrollView</span> <span class="p">{</span> <span class="n">offsetProxy</span> <span class="k">in</span>
                
                <span class="k">if</span> <span class="k">self</span><span class="o">.</span><span class="n">scrollOffset</span> <span class="o">&gt;</span> <span class="n">offsetProxy</span><span class="o">.</span><span class="n">y</span> <span class="p">{</span>
<span class="c1">//                    scrollState = true</span>
                    <span class="nf">print</span><span class="p">(</span><span class="s">"true"</span><span class="p">)</span> <span class="c1">// 스크롤</span>
                    <span class="n">withAnimation</span> <span class="p">{</span>
                        <span class="n">hidePointView</span> <span class="o">=</span> <span class="kc">true</span>
                        <span class="n">pullDownView</span> <span class="o">=</span> <span class="kc">true</span>
                    <span class="p">}</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="c1">//                    scrollState = false</span>
                    <span class="nf">print</span><span class="p">(</span><span class="s">"false"</span><span class="p">)</span> <span class="c1">// 역스크롤</span>
                    <span class="n">withAnimation</span> <span class="p">{</span>
                        <span class="n">hidePointView</span> <span class="o">=</span> <span class="kc">false</span>
                        <span class="n">pullDownView</span> <span class="o">=</span> <span class="kc">false</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                
                <span class="k">self</span><span class="o">.</span><span class="n">scrollOffset</span> <span class="o">=</span> <span class="n">offsetProxy</span><span class="o">.</span><span class="n">y</span>
                
            <span class="p">}</span> <span class="nv">content</span><span class="p">:</span> <span class="p">{</span>
            
                <span class="kt">LazyVStack</span><span class="p">(</span><span class="nv">spacing</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">pinnedViews</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">sectionHeaders</span><span class="p">],</span> <span class="nv">content</span><span class="p">:</span> <span class="p">{</span>
                    
                    <span class="c1">// pointViewHeader 자체에서 조건문으로 height 를 변경 (색 맞춰서 보이지 않게)</span>
                    <span class="kt">Section</span><span class="p">(</span><span class="nv">header</span><span class="p">:</span> <span class="n">pointViewHeader</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">videoView</span>
                    <span class="p">}</span>
                    
                    <span class="kt">VStack</span><span class="p">(</span><span class="nv">spacing</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="kt">LazyVStack</span><span class="p">(</span><span class="nv">pinnedViews</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">sectionHeaders</span><span class="p">],</span> <span class="nv">content</span><span class="p">:</span>  <span class="p">{</span>
                            <span class="c1">// on Disppear 시 hidePointView 변경됨)</span>
                            <span class="kt">Section</span><span class="p">(</span><span class="nv">header</span><span class="p">:</span> <span class="n">tempClearHeader</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
                        <span class="p">})</span>
                        
                        <span class="kt">LazyVStack</span><span class="p">(</span><span class="nv">spacing</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">pinnedViews</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">sectionHeaders</span><span class="p">],</span> <span class="nv">content</span><span class="p">:</span> <span class="p">{</span>
                            
                            <span class="kt">Section</span><span class="p">(</span><span class="nv">header</span><span class="p">:</span> <span class="n">tabViewHeader</span><span class="p">)</span> <span class="p">{</span>
                                <span class="kt">GeometryReader</span> <span class="p">{</span> <span class="n">geometry</span> <span class="k">in</span>
                                    <span class="kt">VStack</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">leading</span><span class="p">,</span> <span class="nv">spacing</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                                        <span class="kt">Text</span><span class="p">(</span><span class="s">"리뷰 모아보기"</span><span class="p">)</span>
                                            <span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="o">.</span><span class="nf">system</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="mi">18</span><span class="p">,</span> <span class="nv">weight</span><span class="p">:</span> <span class="o">.</span><span class="n">bold</span><span class="p">))</span>
                                        <span class="kt">Text</span><span class="p">(</span><span class="s">"💰위글 영상 리뷰보고 포인트 쌓자!"</span><span class="p">)</span>
                                            <span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="o">.</span><span class="nf">system</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span> <span class="nv">weight</span><span class="p">:</span> <span class="o">.</span><span class="n">regular</span><span class="p">))</span>
                                    <span class="p">}</span>
                                    <span class="o">.</span><span class="nf">padding</span><span class="p">(</span><span class="o">.</span><span class="n">horizontal</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
                                    <span class="o">.</span><span class="nf">offset</span><span class="p">(</span><span class="nv">y</span><span class="p">:</span> <span class="n">geometry</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>
                                    <span class="o">.</span><span class="nf">onChange</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">geometry</span><span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">.</span><span class="n">global</span><span class="p">)</span><span class="o">.</span><span class="n">minY</span><span class="p">)</span> <span class="p">{</span> <span class="n">minY</span> <span class="k">in</span>
                                        <span class="n">withAnimation</span> <span class="p">{</span>
                                            <span class="k">if</span> <span class="n">minY</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
                                                <span class="n">allHeaderPinned</span> <span class="o">=</span> <span class="kc">true</span>
                                            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                                                <span class="n">allHeaderPinned</span> <span class="o">=</span> <span class="kc">false</span>
                                            <span class="p">}</span>
                                        <span class="p">}</span>
                                        
                                        <span class="nf">print</span><span class="p">(</span><span class="s">"minY: </span><span class="se">\(</span><span class="n">minY</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
                                    <span class="p">}</span>
                                    <span class="c1">// let _ = print("\(geometry.size.height)") // PRINT: 10.0</span>
                                <span class="p">}</span>
                                <span class="o">.</span><span class="nf">padding</span><span class="p">(</span><span class="o">.</span><span class="n">vertical</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
                                
                                <span class="kt">LazyVStack</span><span class="p">(</span><span class="nv">pinnedViews</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">sectionHeaders</span><span class="p">],</span> <span class="nv">content</span><span class="p">:</span> <span class="p">{</span>
                                    <span class="kt">Section</span><span class="p">(</span><span class="nv">header</span><span class="p">:</span> <span class="n">categoryHeader</span><span class="p">)</span> <span class="p">{</span>
                                        <span class="n">tabViewBody</span>
                                    <span class="p">}</span>
                                <span class="p">})</span>
                            <span class="p">}</span>
                        <span class="p">})</span>
                        <span class="o">.</span><span class="nf">offset</span><span class="p">(</span><span class="nv">y</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">})</span>
                <span class="o">.</span><span class="nf">background</span><span class="p">(</span><span class="o">.</span><span class="n">yellow</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="o">.</span><span class="nf">overlay</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">top</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">withAnimation</span> <span class="p">{</span>
                    <span class="n">pointViewHeader</span>
                        <span class="o">.</span><span class="nf">opacity</span><span class="p">((</span><span class="n">allHeaderPinned</span> <span class="o">==</span> <span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="n">hidePointView</span><span class="p">)</span> <span class="p">?</span> <span class="mi">10</span> <span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="c1">// overlay는 pinned header들이 아래로 밀리지 않아서 사용할 수 없음</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="o">.</span><span class="nf">padding</span><span class="p">(</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">pointViewHeader</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">HStack</span> <span class="p">{</span>
            <span class="kt">Image</span><span class="p">(</span><span class="nv">systemName</span><span class="p">:</span> <span class="s">"globe"</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">imageScale</span><span class="p">(</span><span class="o">.</span><span class="n">large</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">foregroundStyle</span><span class="p">(</span><span class="o">.</span><span class="n">tint</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"2,759"</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="o">.</span><span class="nf">system</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="mi">18</span><span class="p">,</span> <span class="nv">weight</span><span class="p">:</span> <span class="o">.</span><span class="n">bold</span><span class="p">))</span>
            <span class="kt">Spacer</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">minWidth</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">maxWidth</span><span class="p">:</span> <span class="o">.</span><span class="n">infinity</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">50</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">foregroundColor</span><span class="p">(</span><span class="o">.</span><span class="n">white</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">background</span><span class="p">(</span><span class="o">.</span><span class="n">black</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">pointViewHeaderOverlay</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">HStack</span> <span class="p">{</span>
            <span class="kt">Image</span><span class="p">(</span><span class="nv">systemName</span><span class="p">:</span> <span class="s">"globe"</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">imageScale</span><span class="p">(</span><span class="o">.</span><span class="n">large</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">foregroundStyle</span><span class="p">(</span><span class="o">.</span><span class="n">tint</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"2,759"</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="o">.</span><span class="nf">system</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="mi">18</span><span class="p">,</span> <span class="nv">weight</span><span class="p">:</span> <span class="o">.</span><span class="n">bold</span><span class="p">))</span>
            <span class="kt">Spacer</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">minWidth</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">maxWidth</span><span class="p">:</span> <span class="o">.</span><span class="n">infinity</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">50</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">foregroundColor</span><span class="p">(</span><span class="o">.</span><span class="n">white</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">background</span><span class="p">(</span><span class="o">.</span><span class="n">blue</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">tabViewHeader</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">HStack</span> <span class="p">{</span>
            <span class="kt">Spacer</span><span class="p">()</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"영상 리뷰"</span><span class="p">)</span>
            <span class="kt">Spacer</span><span class="p">()</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"포토 리뷰"</span><span class="p">)</span>
            <span class="kt">Spacer</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">minWidth</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">maxWidth</span><span class="p">:</span> <span class="o">.</span><span class="n">infinity</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">50</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">foregroundColor</span><span class="p">(</span><span class="o">.</span><span class="n">white</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">background</span><span class="p">(</span><span class="o">.</span><span class="n">black</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">offset</span><span class="p">(</span><span class="nv">y</span><span class="p">:</span> <span class="p">(</span><span class="n">allHeaderPinned</span> <span class="o">==</span> <span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="n">pullDownView</span><span class="p">)</span> <span class="p">?</span> <span class="mi">50</span> <span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">tabViewBody</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">ForEach</span><span class="p">(</span><span class="mi">0</span><span class="o">..&lt;</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span> <span class="n">row</span> <span class="k">in</span>
                <span class="kt">HStack</span><span class="p">(</span><span class="nv">spacing</span><span class="p">:</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kt">Spacer</span><span class="p">()</span>
                    <span class="kt">Rectangle</span><span class="p">()</span>
                        <span class="o">.</span><span class="nf">fill</span><span class="p">(</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
                        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">minWidth</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">maxWidth</span><span class="p">:</span> <span class="o">.</span><span class="n">infinity</span><span class="p">)</span>
                        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">240</span><span class="p">)</span>
                        <span class="o">.</span><span class="nf">padding</span><span class="p">([</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="o">.</span><span class="n">bottom</span><span class="p">])</span>
                    
                    
                    <span class="kt">Rectangle</span><span class="p">()</span>
                        <span class="o">.</span><span class="nf">fill</span><span class="p">(</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
                        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">minWidth</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">maxWidth</span><span class="p">:</span> <span class="o">.</span><span class="n">infinity</span><span class="p">)</span>
                        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">240</span><span class="p">)</span>
                        <span class="o">.</span><span class="nf">padding</span><span class="p">([</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="o">.</span><span class="n">bottom</span><span class="p">])</span>
                    
                    <span class="kt">Spacer</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">categoryHeader</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">HStack</span> <span class="p">{</span>
            <span class="kt">Spacer</span><span class="p">()</span>
            <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span>
                <span class="c1">//</span>
            <span class="p">},</span> <span class="nv">label</span><span class="p">:</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Button"</span><span class="p">)</span>
            <span class="p">})</span>
            <span class="kt">Spacer</span><span class="p">()</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"버튼"</span><span class="p">)</span>
            <span class="kt">Spacer</span><span class="p">()</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"버튼"</span><span class="p">)</span>
            <span class="kt">Spacer</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">minWidth</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">maxWidth</span><span class="p">:</span> <span class="o">.</span><span class="n">infinity</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">50</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">foregroundColor</span><span class="p">(</span><span class="o">.</span><span class="n">white</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">background</span><span class="p">(</span><span class="o">.</span><span class="n">green</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">padding</span><span class="p">(</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span> <span class="c1">// 카테고리 헤더가 탭뷰 헤더 아래에 붙도록 패딩 조정</span>
        <span class="o">.</span><span class="nf">offset</span><span class="p">(</span><span class="nv">y</span><span class="p">:</span> <span class="p">(</span><span class="n">allHeaderPinned</span> <span class="o">==</span> <span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="n">pullDownView</span><span class="p">)</span> <span class="p">?</span> <span class="mi">50</span> <span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">videoView</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span><span class="p">(</span><span class="nv">spacing</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">Rectangle</span><span class="p">()</span>
                <span class="o">.</span><span class="nf">fill</span><span class="p">(</span><span class="o">.</span><span class="n">red</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">202</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">var</span> <span class="nv">tempClearHeader</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">HStack</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">""</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">minWidth</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">maxWidth</span><span class="p">:</span> <span class="o">.</span><span class="n">infinity</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">height</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">foregroundColor</span><span class="p">(</span><span class="o">.</span><span class="n">white</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">background</span><span class="p">(</span><span class="o">.</span><span class="n">yellow</span><span class="p">)</span> <span class="c1">// 배경이랑 같은 색으로 맞추기</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">ContentView_Previews</span><span class="p">:</span> <span class="kt">PreviewProvider</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">previews</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">ContentView</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>


</code></pre></div></div>]]></content><author><name>Mirae</name></author><category term="TIL" /><summary type="html"><![CDATA[```swift]]></summary></entry><entry><title type="html">SwiftUI 업데이트</title><link href="http://localhost:4000/til/2023-07-03-SwiftUIUpdates.html" rel="alternate" type="text/html" title="SwiftUI 업데이트" /><published>2023-07-03T00:00:00+09:00</published><updated>2023-07-03T00:00:00+09:00</updated><id>http://localhost:4000/til/SwiftUIUpdates</id><content type="html" xml:base="http://localhost:4000/til/2023-07-03-SwiftUIUpdates.html"><![CDATA[<h1 id="onchangeofinitial_">onChange(of:initial:_:)</h1>

<h2 id="파라미터">파라미터</h2>

<ul>
  <li>
    <p>value : of 뒤에 작성되는 값으로, value의 값에 변화가 생기면 onChange 클로저가 실행됨</p>
  </li>
  <li>
    <p>initial : initial에 해당하는 뷰가 먼저 나타나면 onChange 속 동작이 실행됨</p>
  </li>
  <li>
    <p>action : value 값이 변경되었을 때 실행되는 클로저</p>
  </li>
  <li>
    <p>oldValue : 비교 체크를 실패한 예전 값 또는 처음 값</p>
  </li>
  <li>
    <p>newValue : 비교 체크를 실패한 새로운 값</p>
  </li>
</ul>

<h2 id="리턴값">리턴값</h2>

<ul>
  <li>특정 value가 변경될 때 어떤 동작을 실행하는 뷰를 리턴함</li>
</ul>

<h2 id="discussion">Discussion</h2>

<ul>
  <li>onChange를 사용하여 특정 값이 변경되었을 때 어떤 동작이 일어나도록 할 수 있음.</li>
  <li>긴 시간동안 실행되는 테스크에 사용하는 것은 피해야 함</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">PlayerView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">episode</span><span class="p">:</span> <span class="kt">Episode</span>
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">playState</span><span class="p">:</span> <span class="kt">PlayState</span> <span class="o">=</span> <span class="o">.</span><span class="n">paused</span>


    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="n">episode</span><span class="o">.</span><span class="n">title</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="n">episode</span><span class="o">.</span><span class="n">showTitle</span><span class="p">)</span>
            <span class="kt">PlayButton</span><span class="p">(</span><span class="nv">playState</span><span class="p">:</span> <span class="err">$</span><span class="n">playState</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">onChange</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">playState</span><span class="p">)</span> <span class="p">{</span> <span class="n">oldState</span><span class="p">,</span> <span class="n">newState</span> <span class="k">in</span>
            <span class="n">model</span><span class="o">.</span><span class="nf">playStateDidChange</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">oldState</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="n">newState</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="매크로">매크로</h1>

<p>매크로를 사용하면 반복적으로 사용되는 코드를 컴파일 할 때 생성할 수 있음. 반복적인 코드를 짧게 줄일 수 있으므로 더 읽기 편해짐.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Slopes in my favorite ski resort.</span>
<span class="kd">enum</span> <span class="kt">Slope</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">beginnersParadise</span>
    <span class="k">case</span> <span class="n">practiceRun</span>
    <span class="k">case</span> <span class="n">livingRoom</span>
    <span class="k">case</span> <span class="n">olympicRun</span>
    <span class="k">case</span> <span class="n">blackBeauty</span>
<span class="p">}</span>

<span class="c1">/// Slopes suitable for beginners. Subset of `Slopes`.</span>
<span class="kd">enum</span> <span class="kt">EasySlope</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">beginnersParadise</span>
    <span class="k">case</span> <span class="n">practiceRun</span>

    <span class="nf">init</span><span class="p">?(</span><span class="n">_</span> <span class="nv">slope</span><span class="p">:</span> <span class="kt">Slope</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">slope</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">beginnersParadise</span><span class="p">:</span> <span class="k">self</span> <span class="o">=</span> <span class="o">.</span><span class="n">beginnersParadise</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">practiceRun</span><span class="p">:</span> <span class="k">self</span> <span class="o">=</span> <span class="o">.</span><span class="n">practiceRun</span>
        <span class="k">default</span><span class="p">:</span> <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">slope</span><span class="p">:</span> <span class="kt">Slope</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">beginnersParadise</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="n">beginnersParadise</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">practiceRun</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="n">practiceRun</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>Slope 타입에 있는 case 중 초보자에게 적합한 slope이 있을 경우, EasySlope 타입으로 변환함.</li>
  <li>이때 초보자에게 적합한 slope을 추가하기 위해서는 Slope 타입의 case, EasySlope 타입의 case, 이니셜라이저, computed property인 slope에 총 네번 코드를 추가해 주어야 함.</li>
  <li>위 작업을 매크로를 사용해서 줄일 수 있는지 알아보겠음.
    <ul>
      <li>이니셜라이저와 컴퓨티드 프로퍼티는 EasySlope 타입의 멤버임. -&gt; attached member 매크로를 정의할 것</li>
      <li>매크로를 구현할 컴파일러 플러그인을 생성해야 함.</li>
      <li>매크로가 원하는대로 동작하는지 확인하기 위해서 test driven way로 코드를 작성.</li>
      <li>정상적으로 코드를 작성할 시, 이니셜라이저에 해당되는 코드를 제거하고, 이니셜라이저 코드를 컴파일 타임에 생성할 매크로를 추가하게 됨.</li>
    </ul>
  </li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// EasySlope의 멤버인 이니셜라이저를 생성할 매크로</span>
<span class="kd">@attached</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="nv">names</span><span class="p">:</span> <span class="nf">named</span><span class="p">(</span><span class="kd">init</span><span class="p">))</span>
<span class="c1">// SlopeSubset은 매크로의 이름</span>
<span class="kd">public</span> <span class="n">macro</span> <span class="kt">SlopeSubset</span><span class="p">()</span> <span class="o">=</span> <span class="err">#</span><span class="nf">externalMacro</span><span class="p">(</span><span class="nv">module</span><span class="p">:</span> <span class="s">"MyMacroMacros"</span><span class="p">,</span> <span class="nv">type</span><span class="p">:</span> <span class="s">"SlopeSubsetMacro"</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li>여기까지는 매크로의 정의. 아직 implementation 부분을 작성한 것은 아님. (실행될 코드 부분을 expansion이라고 함.)</li>
  <li>“SlopeSubsetMacro” 타입을 생성해야 함.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// attached member 매크로는 MemberMacro 프로토콜을 따라야 함.</span>
<span class="c1">// MemberMacro 요구사항은 하나 -&gt; expansion() 함수</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">SlopeSubsetMacro</span><span class="p">:</span> <span class="kt">MemberMacro</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">expansion</span><span class="p">(</span>
        <span class="n">of</span> <span class="nv">attribute</span><span class="p">:</span> <span class="kt">AttributeSyntax</span><span class="p">,</span>
        <span class="n">providingMembersOf</span> <span class="nv">declaration</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">DeclGroupSyntax</span><span class="p">,</span>
        <span class="k">in</span> <span class="nv">context</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">MacroExpansionContext</span>
    <span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">DeclSyntax</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// providingMacros 프로퍼티를 작성하여 컴파일러가 작성한 매크로를 감지할 수 있도록 함.</span>
<span class="kd">@main</span>
<span class="kd">struct</span> <span class="kt">WWDCPlugin</span><span class="p">:</span> <span class="kt">CompilerPlugin</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">providingMacros</span><span class="p">:</span> <span class="p">[</span><span class="kt">Macro</span><span class="o">.</span><span class="k">Type</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="kt">SlopeSubsetMacro</span><span class="o">.</span><span class="k">self</span>
    <span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>#stringify : 스트링이파이 매크로</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">calculations</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"1 + 1"</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"3 * 2"</span><span class="p">),</span>
<span class="p">]</span>

<span class="k">let</span> <span class="nv">calculations</span> <span class="o">=</span> <span class="p">[</span>
    <span class="cp">#stringify(1 + 1)</span>
    <span class="cp">#stringify(3 * 2)</span>
<span class="p">]</span>
</code></pre></div></div>

<p>// 매크로 정의</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@freestanding</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span> <span class="c1">// 2</span>
<span class="n">macro</span> <span class="nf">stringify</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span> <span class="c1">// 1</span>

</code></pre></div></div>
<ul>
  <li>// 1: function 정의와 비슷함. Int 값을 파라미터로 받고 output 값으로 Int, String을 반환함.</li>
  <li>
    <p>// 2: freestanding expression macro role을 사용하여 정의되었는데, 이것은 expression을 사용하는 곳엔 어디서든 매크로를 사용할 수 있도록 한다는 의미.</p>

    <ul>
      <li>파라미터의 타입이 일치하는지 체크하고 (제네릭 타입 매크로도 작성 가능), 컴파일러는 macro expansion 실행 (macro expansion은 매크로가 실행되고 값을 리턴하는 과정을 말함)</li>
    </ul>
  </li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@freestanding</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span> 

<span class="kd">@attached</span><span class="p">(</span><span class="n">member</span><span class="p">)</span> 
</code></pre></div></div>

<!--- MemberMacro 프로토콜은 하나의 요구사항을 가짐. 이 요구사항은 'expansion' 함수인데, -->]]></content><author><name>Mirae</name></author><category term="TIL" /><summary type="html"><![CDATA[onChange(of:initial:_:)]]></summary></entry></feed>