{"/pages/about/": {
    "title": "About",
    "keywords": "Jekyll",
    "url": "/pages/about/",
    "body": "This is an about page."
  },"/pages/contact/": {
    "title": "Contact",
    "keywords": "Jekyll",
    "url": "/pages/contact/",
    "body": "This is an contact page."
  },"/pages/design/draft/": {
    "title": "Design Draft",
    "keywords": "Jekyll",
    "url": "/pages/design/draft/",
    "body": "This is an draft page."
  },"/til/2022-08-14-myBoxes.html": {
    "title": "My Boxes",
    "keywords": "TIL",
    "url": "/til/2022-08-14-myBoxes.html",
    "body": "앱 프로젝트 작은 개인 프로젝트 시작했습니다. ## NavigationView 네비게이션 뷰를 사용하여 뷰 사이를 이동 ## Edit View 사용자가 아이템을 등록/수정할 뷰 타입을 새로 하나 만들어서 편집할 때는 거기에 담아두고 완료 버튼을 누르면 그때 뷰에 업데이트 되도록 함"
  },"/til/2022-07-30-demystifySwiftUI.html": {
    "title": "Demystify SwiftUI / WWDC21",
    "keywords": "TIL",
    "url": "/til/2022-07-30-demystifySwiftUI.html",
    "body": "Demystify SwiftUI 이 글의 모든 정보의 출처는 위 링크의 WWDC21 영상입니다. 디미스티파이가 뭔지 먼저 검색해봅니다. 사전에는 to make a subject that seems difficult or complicated easier to understand, especially by explaining it in simpler language. 라고 나와 있습니다. 어렵거나 복잡해보이는 주제를 쉬운 언어를 사용하여 이해하기 쉽도록 만드는 것이라고 하는데요. Demystify SwiftUI! 라고하니… 어렵고, 복잡해보이는 SwiftUI를 쉽게 이해해보자는 것 같습니다. Declarative UI SwiftUI가 선언형 UI 라는 말을 들어보셨을 겁니다. 원하는 UI를 하이레벨 언어로 묘사하면 SwiftUI가 어떻게 그것을 이루어낼건지 결정합니다. 대부분 이것은 잘 작동합니다. 하지만 가끔은 의도하지 않은 방식으로 작동할 떄가 있죠. 그리고 바로 그때, SwiftUI가 보이지 않는 곳에서, 우리가 원하는 결과를 얻기 위해 무엇을 하고 있는지 이해하는 것이 도움이 될 것입니다. SwiftUI가 우리의 코드를 볼 때, 뭐가 보일까? Identity : 아이덴티티는 SwiftUI가 요소를 구별하는 방법입니다. 같은가? 다른가? Lifetime : 라이프타임은 SwiftUI가 시간에 지남에 따라 달라지는 뷰와 데이터의 존재유무를 추적하는 방법입니다. Dependencies : SwiftUI가 언제 우리의 인터페이스가 업데이트 되야하는지, 그리고 왜 업데이트 되야하는지 이해하는 방법입니다. 이 세 가지를 통해 SwiftUI는 뭐가, 언제, 어떻게 바뀌어야 하는지를 알 수 있습니다. 결과적으로 우리는 화면에서 동적인 사용자 인터페이스의 형태로 이것을 확인 할 수 있죠. 이 세 가지에 대해 좀 더 깊이 알아봅시다. Identity 먼저 아이덴티티에 대해 알아봅니다. 아래 캡처한 이미지에는 두개의 강아지 발바닥 뷰가 있습니다. 저 두 뷰는 색과 위치만 다른 같은 뷰일까요? 아니면 아예 다른 뷰일까요? 이 두 차이는 중요합니다. 왜냐하면, 이 차이로 인해 뷰가 어떤 한 상태에서 다른 상태로 바뀌는 방법이 바뀌기 떄문입니다. 두 아이콘이 다른 두개의 뷰라면 하나가 나타나고 사라지고, 또 다른 하나가 사라지고 나타나는 방식으로 뷰를 변경시킬 것입니다. 반대로 두 뷰가 같은 뷰라면, 슬라이딩과 같은 방식으로 뷰를 움직일 것입니다. #### View Identity 같은 아이덴티티를 공유하는 뷰들은 같은 컨셉의 UI 요소의 다른 상태를 보여줍니다. 위의 강아지 발바닥 아이콘을 예로 들면, 같은 컨셉의 아이콘이지만 색과 위치라는 상태가 다르게 나타나죠. 두 아이콘을 같은 뷰라고 가정하면 이 둘은 같은 아이덴티티를 가지고 있는 것이겠죠. 반대로 두 아이콘이 다른 아이덴티티를 가졌다면 다른 두 뷰인 것입니다. 그렇다면 코드 속에서 아이덴티티가 어떻게 나타나는지 알아봅시다. SwiftUI가 사용하는 두가지 방식을 집중적으로 알아봅시다. Types of identity Explicit identity : 이름과 같은 assigning name 또는 identifier Structural identity : 타입, 위치, 계층(view hierarchy)으로 구별 Explicit identity의 예로는 포인터가 있습니다. AppKit과 UIKit은 포인터를 사용합니다. SwiftUI는 포인터를 사용하지 않지만 포인터에 대해 알아보는 것이 SwiftUI가 어떤 방식으로, 그리고 왜 다른지 이해하는 것에 도움이 되기 때문에 잠깐 포인터에 대해 알아봅시다. UIView와 NSView는 클래스이기 때문에 각 뷰가 메모리의 할당에 대한 고유한 포인터를 가지고 있습니다. 포인터를 사용하여 각각의 뷰를 참조할 수 있고 만약 두 뷰가 같은 포인터를 공유한다면 그들이 동일한 뷰라는 것을 확신할 수 있습니다. SwiftUI의 뷰는 일반적으로 class가 아닌 struct로 표현되는 value type이기 때문에 포인터를 사용하지 않습니다. 포인터를 사용하지 않는다는 것은 뷰의 영구적인 아이덴티티로 사용할 표준 참조 기준이 없다는 것이죠. SwiftUI는 포인터가 대신 다른 형태의 explicit 아이덴티티를 사용합니다. SwiftUI가 왜 Value type을 사용하는지는 wwdc19 SwiftUI essentials에 자세한 설명이 있다고 하여 그 영상의 내용을 정리해봅니다. SwiftUI Essentials (wwdc19) 뷰는 사용자 인터페이스의 기본적인 빌딩 블럭입니다. 고레벨에서 뷰는 UI의 한 부분을 정의하는 어떤 것입니다. 위 캡처에 보이는 앱 화면의 모든 것들이 뷰로 선언됩니다. Order 버튼과 같은 individual control은 뷰입니다. 이것들을 담고 있는 컨테이너도 뷰입니다. 이 뷰들을 계층 형식으로 결합하여 사용자 인터페이스를 구성합니다. Vertical Stack은 Container로 root 에 위치하고 text, shape, image 등의 뷰들은 bottom 부분입니다. 뷰가 코드 안에서 표현되는 방식이 우리가 익숙한 방식과는 좀 다를 수 있습니다. 코드를 보겠습니다. 샘플 앱은 Text와 Controls를 포함한 VStack으로 작성되어 있습니다. 코드를 읽으면서 바로 이해가 되도록 잘 보이게 쓰여져 있죠. 그리고 위에 있던 뷰 계층 다이어그램과도 비슷합니다. add subviews와 같은 function을 호출하는 부분은 없는데요. 뷰 계층을 하나하나 쌓는게 아니라 완전하게 구성된 스트럭쳐로써 초기화하기 때문입니다. SwiftUI는 뷰를 명령형이 아닌 선언적으로 정의하기 때문입니다. Imperative code(명령형의 코드)는 직접적으로 명령들을 보내 결과를 생성해 냅니다. 이 과정은 마치 친구에게 전화로 아보카도 토스트를 만드는 방법을 설명하는 것과 비슷합니다. 어떤 재료가 필요한지, 어떤 조리 기구가 필요한지, 빵을 굽는 방법과 아보카도를 자르는 방법을 설명해야 하죠. 그리고 이 아보카도 토스트를 만든는 것을 지시하는 과정은 좀 길고 지루할 것입니다. 그리고 만약 당신의 친구가 빵을 굽는 것을 깜빡하는 것과 같은 실수를 한다면 아보카도 토스트는 제대로 완성되지 않을 것입니다. 이제 declaratively(선언적)한 방법으로 아보카도 토스트를 만들어 보겠습니다. Declarative code(선언적 코드)는 우리가 원하는 것을 묘사하고 그것을 어떻게 만들지 알아내는 것은 다른 누군가에게 맡깁니다. 아보카도 전문가에게 아보카도 토스트를 주문하는 것과 비슷하죠. 우리의 코드로 돌아가서 SwiftUI는 우리를 도울 준비가 되어있는 전문가 역할을 합니다. 코드의 형태에서 우리는 관계들을 코드화하는 structure를 이니셜라이징 함으로써 뷰들 사이의 계층 관계를 선업합니다. structure를 initializing 한 다는게 갑자기 헷갈려서 검색! Initialization은 사용하기 위해 class, structure, enumeration의 인스턴스를 준비하는 과정 그러니까 위에서는 뷰 계층을 구성하는데 사용되는 structure의 인스턴스를 준비한다는 것 우리가 위와 같은 코드를 작성하면, SwiftUI는 그 코드를 화면에 렌더링 된 결과물로 변환하는 어려운 작업을 해줍니다. Container views 컨테이너 뷰는 각자의 내용을 가지고 있는 다른 뷰들의 조합으로 이루어집니다. 이 컨텐트 뷰는 view builder라는 특별한 종류의 클로저안에서 선언됩니다. 예를 들어, 앞의 예시 코드에서 봤던 VStack은 컨테이너의 한 예입니다. 뷰 빌더는 클로저의 바디 부분에 우리가 선언형의 코드를 작성할 수 있도록 합니다. AddSubview와 같은 함수를 호출하는 대신 우리는 그냥 이 클로저 안에 우리의 컨텐츠를 쭉 작성해 내려갑니다. 이것이 어떻게 작동하는지 좀 더 알아보기 위해 VStack의 실제 API를 들여다 봅시다. 클로저로 정의된 컨텐트 패러미터를 볼 수 있습니다. ViewBuilder 어트리뷰트로 표시되어 있죠. Swift의 컴파일러는 이 어트리뷰트로 표시된 클로저를 스택안에 있는 모든 컨텐츠를 보여주는 싱글뷰를 반환하는 새 클로저로 변환합니다. 이런식으로 SwiftUI는 Swift의 기능을 사용하여 우리가 더 적은 양의 코드를 작성할 수 있도록 돕습니다. VStack과 비슷한 뷰들은 content 패러미터 뿐 아니라 다른 패러미터도 가지고 있습니다."
  },"/til/2022-07-30-today.html": {
    "title": "iOS 개발 튜토리얼 / UIKit essentials / 앱 Today",
    "keywords": "TIL",
    "url": "/til/2022-07-30-today.html",
    "body": "iOS App Dev Tutorials: UIKit Essential 위 공식 UIKit 개발 튜토리얼을 따라가며 그 과정을 정리해 봅니다. Creating a List View 이 부분에서는 앱의 root view를 생성합니다. 리스트 레이아웃의 콜렉션 뷰로 사용자의 데일리 리마인더를 화면에 보여줍니다. 리스트를 보여줄 콜렉션 뷰를 생성하고 content configuration object를 사용하여 셀들의 외형을 정합니다. 그리고 그 셀들을 diffable 데이터 소스에 연결하여 데이터가 변경될 때 사용자의 인터페이스도 함께 변경되도록 합니다. Section 1 - Create a Project 이 모듈의 전체 과정을 거쳐 앱을 만들어가며 앱 개발의 가장 중요한 부분들을 배울 것입니다. Xcode와 UIKit을 사용하는 일반적인 프로그래밍 패턴에 대해 알아볼 것입니다. 먼저, Xcode 템플릿을 사용여 iOS 앱 프로젝트를 생성해 봅니다. (프로젝트 생성과 시뮬레이터 사용에 대해서는 알고 있기 때문에 스킵합니다.) Section 2 - Add a Collection View Controller 뷰 컨트롤러를 스토리보드에 추가함으로써 앱 Today 만들기를 시작합니다. 뷰 컨트롤러는 데이터 모델과 뷰 사이에서 다리 역할을 합니다. 각 컨트롤러는 뷰 계층을 관리하고, 뷰의 컨텐츠를 업데이트하고, UI의 이벤트에 응답합니다. 콜렉션 뷰를 생성하기 위해 Interface Builder를 사용할 것입니다. 콜렉션 뷰는 그리드, 컬럼, 로우, 테이블의 형태로 셀을 나타낼 수 있습니다. Step 1 Main 스토리보드에 프로젝트 생성 시 자동으로 생성되어 있는 View Controller Scene을 삭제해줍니다. (선택 후 키보드 delete ⌫ 키 누르기) 이 뷰 컨트롤러를 리스트를 보여 줄 뷰 컨트롤러로 대체 할 것입니다. Step 2 오른쪽 위에 + 아이콘(라이브러리 아이콘)을 클릭한 뒤 Collection View Controller를 검색합니다. Step 3 콜렉션 뷰 컨트롤러를 캔바스로 드래그하여 새로운 콜렉션 뷰를 생성합니다. Step 4 Attributes inspector에서 Is initial View Controller 체크박스를 선택하여 해당 Scene을 스토리보드 엔트리 포인트로 설정합니다. initial view controller 값은 앱이 스토리보드를 로드할 때 어떤 뷰 컨트롤러가 로드될 지 결정합니다. NOTE: 앱은 여러개의 스토리보드를 가질 수 있습니다. 앱의 프로젝트 파일 안에 있는 Main Interface setting은 어떤 스토리보드가 앱이 처음 실행되었을 때 로드될 지 결정합니다. (Step 5 생략) 여기까지 콜렉션 뷰 컨트롤러를 생성하고 initial view로 설정하였습니다. 다음으로는, 리마인더를 담을 데이터 모델을 생성하여 데이터 설정을 해보도록 하겠습니다. Section 3 - Create a Reminder Model 앱 Today는 MVC(모델-뷰-컨트롤러) 구조 패턴을 사용할 것입니다. UIKit 앱에서 주로 사용되는 패턴입니다. 뷰 객체는 데이터가 나타나는 모습에 대한 것을 제공합니다. 모델 객체는 앱의 데이터와 비즈니스 로직을 관리합니다. 위에서 생성한 뷰 컨트롤러는 모델이 직접적으로 뷰를 변경시키거나, 뷰가 직접적으로 모델에 영향을 끼치지 않도록 합니다. 이제 데이터 모델을 생성하여 리스트의 리마인더를 보여줄 것입니다. Step 1 Xcode의 왼쪽에 있는 프로젝트 네비게이터에서 Models라는 새 그룹을 생성합니다. (프로젝트 네비게이터 아래 부분에 있는 + 버튼 클릭 → New Group) Step 2 Models에 Reminder.swift 라는 새 파일을 생성하고 struct Reminder를 생성합니다. import Foundation struct Reminder { var title: String var dueDate: Date var notes: String? = nil var isComplete: Bool = false } #if DEBUG extension Reminder { } #endif Step 3 title, dueDate 속성을 선언합니다. Step 4. 옵셔널 스트링 속성인 notes를 선언하고 기본값으로 nil을 줍니다. Step 5 불리언 타입의 속성 isComplete을 선언하고 기본 값으로 false를 줍니다. Step 6 파일의 아래 부분에 샘플 데이터를 담을 extension을 추가합니다. 그리고 #if. DEBUG 블락안에 extexsion을 위치시킵니다. #If DEBUG flag 는 compilation directive인데 이 플래그로 감싼 코드는 출시된 앱을 빌드할 때 컴파일되지 않습니다. 디버그 빌드 시 코드를 테스트하기 위해 사용하거나 샘플 테스트 데이터를 제공하기 위해 사용할 수 있습니다. 이 단계에서는 샘플 데이터를 제공하기 위해 사용합니다. Step 7 샘플 리마인더 정보를 가진 static 배열을 정의합니다. import Foundation struct Reminder { var title: String var dueDate: Date var notes: String? = nil var isComplete: Bool = false } #if DEBUG extension Reminder { static var sampleData = [ Reminder(title: \"예약한 책 확인하기\", dueDate: Date().addingTimeInterval(800.0), notes: \"전자 도서관 앱에서 확인하기\"), Reminder(title: \"도시락 구입하기\", dueDate: Date().addingTimeInterval(14000.0), notes: \"B마트 쿠폰 확인하기\", isComplete: true), Reminder(title: \"선인장 물주기\", dueDate: Date().addingTimeInterval(24000.0), notes: \"물주고 통풍 신경쓰기\"), Reminder(title: \"블로그 글 정리하기\", dueDate: Date().addingTimeInterval(60000.0), notes: \"조금이라도 하기\"), Reminder(title: \"요가 일주일 테스트 신청\", dueDate: Date().addingTimeInterval(72000.0), notes: \"요일도 생각해보기\"), Reminder(title: \"보고 피피티 끝내기\", dueDate: Date().addingTimeInterval(3200.0), notes: \"너무 늦지 않게 끝내기\") ] } #endif addingTimeInterval(_:) 특정 시간만큼의 간격을 더하여 새로운 날짜 값을 생성합니다. 패러미터 값으로는 초(seconds)를 사용합니다. 여기까지, 프로젝트와 스토리보드를 설정하고 데이타 스트럭쳐를 생성하였습니다. 이제부터는 콜렉션 뷰의 컴포넌트에 대해 알아보며 콜렉션 뷰의 외형에 대해 알아보겠습니다. Section 4 - Configure the Collection as a List 컴포지셔널 레이아웃을 사용하여 콜렉션 뷰 설정을 시작합니다. 컴포지셔널 레이아웃은 섹션, 그룹, 아이템이라는 컴포넌트들을 결합하여 뷰를 그립니다. 섹션은 아이템들을 가지고 있는 그룹을 담고 있는 컨테이너 뷰를 화면에 보여줍니다. 스토리 보드의 콜렉션 뷰 컨트롤러를 backing code에 연결하며 시작해 봅니다. Step 1 프로젝트 생성 시 자동으로 생성되었던 ViewController.swift 파일에 있는 클래스 ViewController의 이름을 컨트롤 + 클릭합니다. Refactor &gt; Rename 하여 클래스의 이름을 ReminderListViewController로 변경합니다. 그리고 슈퍼 클래스를 UIViewController에서 UICollectionViewControllerfh 로 변경합니다. Step 2 Main.storyboard를 열고 오른쪽의 inspector 중 Identity inspector에서 Custom Class - Class를 ReminderListViewController로 변경합니다. 뷰 컨트롤러의 indentity를 변경해줌으로써, ReminderListViewController의 속성과 메서드에 접근 권한을 얻습니다. 앱 Today는 리스트의 형태로 리마인더를 보여줍니다. 미리 정의되어 있는 배치(Configuration)를 사용하여 리스트의 외형을 정의해 봅시다. Step 3 ReminderListViewController.swift 안에 listLayout()이라는 function을 생성합니다. 새 리스트의 외형을 담을 변수를 grouped appearance를 사용하여 생성합니다. func listLayout() -&gt; UICollectionViewCompositionalLayout { var listConfiguration = UICollectionLayoutListConfiguration(appearance: .grouped) listConfiguration.showsSeparators = false listConfiguration.backgroundColor = .clear return UICollectionViewCompositionalLayout.list(using: listConfiguration } UICollectionLayoutListConfiguration는 리스트 레이아웃 형태의 섹션을 생성합니다. Step 4 구분선이 나타나지 않도록 하고 배경색을 .clear로 설정합니다. Step 5 리스트 형태의 컴포지셔널 레이아웃을 리턴합니다. Step 6 ViewDidLoad() 메서드 안에 새 리스트 레이아웃을 생성합니다. 뷰 컨트롤러가 자신의 뷰 계층 구조를 메모리에 로드한 뒤 시스템이 viewDidLoad()를 호출합니다. override func viewDidLoad() { super.viewDidLoad() let listLayout = listLayout() collectionView.collectionViewLayout = listLayout // collectionView는 현재 뷰 컨트롤러가 관리하는 콜렉션뷰 객체 } Step 7 listLayout을 콜렉션 뷰 레이아웃에 할당합니다. Section 5 - Configure the Data Source 컴포지셔널 레이아웃을 사용하여 콜렉션 뷰에 리스트 섹션을 생성했습니다. 콜렉션 뷰에 셀을 등록하고 content configuration을 사용하여 셀의 모양을 정의할 것입니다. 그리고나서 데이터 소스와 셀을 연결합니다. 데이터가 변경될 때마다 사용자 인터페이스를 업데이트하고 움직임을 줄 diffable 데이타 소스를 사용할 것입니다. Step 1 새로운 cell registration을 생성합니다. Cell Registration은 셀의 속성(내용과 모양)을 구성하는 방법을 지정해 줍니다. override func viewDidLoad() { super.viewDidLoad() let listLayout = listLayout() collectionView.collectionViewLayout = listLayout // collectionView는 현재 뷰 컨트롤러가 관리하는 콜렉션뷰 객체 let cellRegistration = UICollectionView.CellRegistration { (cell: UICollectionViewListCell, indexPath: IndexPath, itemIdentifier: String) in let reminder = Reminder.sampleData[indexPath.item] var contentConfiguration = cell.defaultContentConfiguration() contentConfiguration.text = reminder.title cell.contentConfiguration = contentConfiguration } } Step 2 item에 연결된 리마인더를 가져옵니다. Step 3 셀의 default content configuration을 가져옵니다. defaultContentConfiguration() 메서드는 미리 정의되어 있는 시스템 스타일을 생성합니다. Step 4 샘플 데이터인 reminder의 타이틀을 content configuration에 할당합니다. 리스트는 configuration 텍스트를 셀의 프라이머리 텍스트로 보여줍니다. Step 5 설정한 content configuration을 셀에 할당합니다. 여기 까지 셀의 내용과 모양을 설정했습니다. 이제부터는 diffable data 소스에 셀을 연결해 봅시다. Step 6 Diffable data source를 위해 type alias를 추가합니다. Type alias는 이미 있는 타입을 좀 더 명확하게 나타내는 이름으로 사용할 수 있도록 합니다. 아래와 같이 길고 알아보기 어려운 타입의 이름을 DataSource처럼 알아보기 쉬운 이름으로 사용할 수 있습니다. typealias DataSource = UICollectionViewDiffableDataSource&lt;Int, String&gt; var dataSource: DataSource! Step 7 dataSource 라는 이름의 속성을 추가합니다. DataSource가 확실히 있다는 예상하에 implicitly하게 언래핑해 줍니다. 옵셔널이 값을 가진다는 것을 확실히 알 때에만 이렇게 언래핑합니다. 만약 값이 없다면 앱을 중단시키는 런타임 에러를 발생시키기 때문에 주의해야 합니다."
  },"/til/2022-07-30-closures.html": {
    "title": "Closures? 그러니까,, 클로저가 뭐냐면,,",
    "keywords": "TIL",
    "url": "/til/2022-07-30-closures.html",
    "body": "📑 아래 모든 정보의 출처는 The swift programming language guide이며 개인의 학습 용도로만 사용되었음을 밝힙니다. { } Closures는 기능을 담고 있는 자체적으로 완전한 블락으로 패러미터로 전달되거나 코드 안에서 사용되며 상수(Constants)와 변수(Variables)의 references를 찾아내고 담을 수 있습니다. 이것을 *closing over* 이라고 합니다. &lt;!-- 먼 말이야..? 예시좀.. --&gt; Swift가 capturing과 관련된 모든 메모리 관리를 처리해줍니다. Functions and Closures 전역범위의 functions 그리고 nested funtions는 모두 사실 특별한 케이스의 클로저입니다. 클로저는 세가지 형태로 나눠집니다. Global functions는 이름을 가지고 있지만 어떤 값도 capture하지 않는 클로저입니다. Nested functions는 이름을 가지고 있고 자신을 감싸고 있는 function의 값을 capture할 수 있는 클로저입니다. Closure expressions는 주변의 값을 캡처할 수 있고, 단순화된 syntax로 쓰여진, 이름이 없는 클로저입니다. Closure Expressions Swift의 closure expressions는 간결하고 깔끔하게 최적화된 syntax와 함께 명확한 스타일을 가지고 있습니다. 이 최적화 과정에는 아래 네가지 사항이 포함됩니다. 패러미터와 리턴 값의 타입을 문맥의 흐름으로부터 추론합니다. single-expressions closures로부터의 키워드로 표현되지 않은 returns 약칭으로 된 argument의 이름 Trailing closure syntax Closure expressions는 인라인 클로저를 짧고 집중된 형태의 syntax로 작성하는 방식입니다. 💡 inline은 사용되기 전에 중간 변수에 할당되지 않고 바로 사용되는 것을 말합니다. Closure expressions는 정확함과 의도를 잃지 않으면서 closures를 단축된 형태로 작성하기 위한 몇몇개의 syntax 최적화를 제공합니다. The Sorted Method Swift의 표준 라이브러리는 sorted(by:)를 제공합니다. 타입이 명확한 값을 가지고 있는 배열을 정렬해주는 메서드입니다. sorting closure의 출력결과를 기반으로 배열의 값을 정렬합니다. 정렬하는 과정이 완료되면 sorted(by:) 메서드는 조건대로 정렬된 새로운 배열을 리턴합니다. 이 정렬된 새 배열은 원배열과 같은 타입과 사이즈를 가집니다. 원배열이 수정되는 것이 아니라 새 배열을 리턴합니다. 아래의 예제는 closure expressions로 문자열 타입의 값을 가진 names라는 배열을 알파벳 순서의 반대로 정렬할 것입니다. let names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"] sorted(by:)메서드의 클로저는 배열의 요소와 같은 타입의 인자(arguments) 두 개를 받아들입니다. 그리고 값들이 정렬되었을 때 첫번째 값(인자로 들어온)이 두번째 값(역시 인자로 들어온)의 전, 또는 후에 나타나야 한다는 것을 알려주는 Bool 값을 리턴합니다. 이 sorting closure는 첫번째 값이 두번째 값 전에 나타나야 한다면 true를 리턴합니다. 그리고 반대 상황에서는 false를 리턴합니다. 이 예시는 문자열 타입의 값을 가진 배열을 정렬하는 것이므로 sorting closure는 (String, String) -&gt; Bool 타입의 function이 됩니다. The sorting closure: 방식1 일반적인 방식으로 function을 작성하고 sorted(by:)메서드의 인자로 통과시키는 방법이 있습니다. func backward(_ s1: String, _ s2: String) -&gt; Bool { return s1 &gt; s2 } var reversedNames = names.sorted(by: backward) // reversedNames = [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"] 만약 첫번째 문자열(s1)이 두번째 문자열(s2)보다 크다면, backward function은 true를 리턴합니다. 이것은 정렬된 배열에서 s1이 s2전에 나타나야 한다는 것을 나타냅니다. 알파벳에서는 뒤로 갈수록 큰 값이기 때문에 알파벳의 역순으로 정렬됩니다. 위의 방법은 꼭 필요한 single expression function (a &gt; b)를 작성한 긴 버전의 방법이었습니다. The sorting closure: 방식2 Closure Expression Syntax를 이용해서 inline 방식으로 sorting closure를 작성하는 것이 더 나은 방식이 될 것입니다. 클로저 표현식 syntax의 일반적인 형태: { ( parameters ) -&gt; return type in statements } Closure expression syntax의 패러미터는 in-out 패러미터 둘 다 될 수 있습니다. 하지만 default 값은 가질 수 없습니다. 아래의 예시는 closure expression 버전의 backward function입니다. reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 }) 위의 inline closure의 패러미터와 리턴 타입을 정의한 방식은 backward function의 정의한 방식과 똑같습니다. 둘다 (s1: String, s2: String) -&gt; Bool 이라고 쓰였습니다. 하지만 inline closure expression에서는 { } 밖이 아니라 안에 작성되었다는 차이점이 있습니다. 그리고 바디 부분의 시작을 in 키워드로 알렸습니다. in 키워드는 클로저의 패러미터와 리턴 타입의 정의가 끝났다는 것을 알려주고 바디 부분이 시작된다는 것을 나타냅니다. Inferring Type From Context 위의 sorting closure가 sorted(by:) 메서드의 argument로 통과되기 때문에 Swift는 sorting closure의 패러미터의 타입과 리턴 값의 타입을 추측할 수 있습니다. 그렇기 때문에 패러미터와 리턴 값의 타입은 작성될 필요가 없어집니다. 모든 타입들이 추측 가능해짐으로 return arrow(-&gt;)와 패러미터를 감싸는 괄호 또한 생략 가능해집니다. reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } ) Function이나 method에 closure를 통과시킬때는 언제나 패러미터 타입과 리턴 값의 타입을 추측하는 것이 가능합니다. 그렇기 때문에 function이나 method의 인자로써 inline closure을 사용할 때는 완전한 형태로 작성할 필요가 없어집니다. 그럼에도 불구하고, 원한다면 자료형을 명시할 수 있습니다. 만약 코드를 읽어야하는 사람들을 위해 모호한 부분을 피하고 싶다면 자료형을 명시하는 것은 좋은 방법이 될 것입니다. Implicit Returns from Single-Expression closures Single-expression closures는 return 키워드를 생략하고 single expression의 결과를 리턴할 수 있습니다. reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } ) Shorthand Argument Names Swift는 inline closures의 argument 이름을 간단하게 전달하는 방법을 제공합니다. $0, $1, $2 등으로 클로저의 인자값을 나타낼 때 사용됩니다. 만약 closure expression에서 이 shorthand argument names를 사용한다면, 클로저의 argument list를 생략할 수 있습니다. shorthand argument names의 자료형은 사용되길 예상되는 function의 자료형으로부터 추측 가능하고, 가장 높은 수의 shorthand argument는 해당 클로저가 사용할 argument의 개수를 결정합니다. 이 closure expression의 전체가 바디부분으로 이루어져 있음으로 in 키워드도 생략이 가능합니다. reversedNames = names.sorted(by: { $0 &gt; $1 } ) 위의 예시에서, $0은 첫번째 String argument를 $1 은 두번째 String argument를 나타냅니다. $1이 가장 높은 숫자의 shorthand argument라는 것은 해당 클로저가 두개의 arguments를 사용하는 것을 나타냅니다. Operator Methods 심지어 더 짧은 방식으로 closure expression을 작성할 수 있습니다. Swift의 String type은 greater-than operator(&gt;)의 특정 이행 메서드를 가지고 있습니다. 이 메서드의 패러미터 타입과 리턴 타입이 sorted(by:)메서드에게 필요한 패러미터 타입, 그리고 리턴 타입과 정확히 일치하기 때문에 단순히 &gt; 하나만 통과시키더라도 Swift는 String 타입의 string-specific implementation을 사용하길 원한다는 것을 추론할 수 있을 것입니다. reversedNames = names.sorted(by: &gt; ) Trailing closures 클로저 표현식(Closure expression)을 어떤 함수의 마지막 인지로 통과시켜야 하고 그 클로저 표현식이 길다면, 해당 closure expression을 trailing closure로 작성하는 것이 유용한 방법이 될 수 있습니다. 사용하는 trailing closure가 function의 argument이더라도 function call의 () 뒤에 trailing closure을 작성합니다. 이 trailing closure syntax를 사용할때는 function을 호출할 때 첫번째 closure의 argument label (closure: // 같은)은 작성하지 않습니다. 아래의 예제는 single trailing closure를 사용하고 있지만 하나의 function call이 여러개의 trailing closures를 포함할 수 잇습니다. func someFunctionThatTakesAClosure(closure: () -&gt; Void) { // funtion body 부분 } // trailing closure를 사용하지 않고 위의 function을 호출하는 방법 someFunctionThatTakesAClosure(closure: { // closure의 바디 부분 }) // trailing closure 사용 someFunctionThatTakesAClosure() { // trailing closure의 바디 부분 } 위에서 작성해보았던 string-sorting closure도 sorted(by:)메서드의 괄호 밖에서 trailing closure로 작성될 수 있습니다. reversedNames = names.sorted() { $0 &gt; $1 } 만약 closure expression이 function이나 method의 유일한 argument이고 trailing closure로 작성한다면 ()를 생략할 수 있습니다. reversedNames = names.sorted { $0 &gt; $1 } Trailing closures는 어떤 closure가 한 줄 위에 inline 형식으로 작성이 어려울 정도로 길이가 길 때 가장 유용하게 사용됩니다. 예를 들어, Swift의 Array type은 map(_:) 메서드를 가지고 있습니다. 이 메서드는 하나의 closure expression을 argument로 가집니다. 해당 클로저는 배열의 각 아이템마다 한번씩 호출됩니다. 그리고 해당 item을 다르게 mapped된 value를 리턴합니다. (다른 타입일 수 있습니다.) map(_:) 메서드에 통과시킬 클로저 안에 코드를 작성함으로써 mapping의 종류와 리턴 값의 타입을 특정 짓습니다. 주어진 클로저를 배열의 각 요소마다 적용한 뒤에, map(_:) 메서드는 새로 mapped된 값을 원래의 연결된 배열의 값과 같은 순서로 담고 있는 새 배열을 리턴합니다. 아래 예시는 map(_:)메서드와 trailing closure를 사용하여 Int 타입의 값을 가지고 있는 배열을 String 타입의 값을 가진 배열로 변환하는 방법을 설명합니다. 배열 [16, 58, 510]은 새로운 배열인 [“OneSix”, “FiveEight”, “FiveOneZero”]를 생성하기 위해 사용되었습니다. let digitNames = [ 0: \"Zero\", 1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\" ] let numbers = [16, 58, 510] 위의 코드는 숫자와 영어 버전의 숫자 이름을 맵핑한 dictionary를 생성합니다. 문자열 배열로 변환될 numbers 배열도 정의합니다. Array 타입의 map(_:)메서드에 trailing clousre로 closure expression을 통과시켜 numbers 배열을 문자열 배열로 만들어 봅니다. let string = numbers.map { (number) -&gt; String in var number = number var output = \"\" repeat { output = digitNames[number % 10]! + output number /= 10 } while number &gt; 0 return output } // strings 상수의 타입은 [String]으로 추론됩니다. // 값은 [\"OneSix\", \"FiveEight\", \"FiveOneZero\"] 입니다. map(_:) 메서드는 numbers 배열안의 각 item마다 closure expression을 호출합니다. 맵핑될 배열의 값으로부터 타입을 추론할 수 있기 때문에 클로저의 인풋 패러미터인 number의 타입을 특정지을 필요가 없습니다. 위의 예시에서 var number는 초기값으로 closure의 패러미터인 number를 가집니다. 이렇게 함으로써 클로저의 바디안에서 그 값이 변경될 수 있게 됩니다. (function 또는 closures의 패러미터는 언제나 constants 이기 때문에) 이 closure expression은 또한 mapped output 배열안의 담길 값의 타입을 나타내기위해 리턴 타입을 String으로 특정 지었습니다. 위의 closure expression은 호출될 때마다 ouput이라는 이름의 문자열을 만듭니다. 이것은 remainder operator (number % 10)을 사용하여 number의 마지막 수를 찾아내고 이렇게 찾아낸 숫자를 digitNames dictionary에서 키 값으로 가지는 값을 찾기 위해 사용합니다. 그리고 찾은 문자열 값을 현재 output 문자열과 합칩니다. 이 클로저는 0보다 큰 어떤 숫자를 문자 형식으로 나타내기 위해 사용될 수 있습니다. 클로저가 output 값으로 만들어진 새로운 배열이 map(_:) 메서드로부터 만들어집니다. 위의 예시에서의 trailing closure의 사용은 클로저가 사용된 function 바로 뒤에 클로저의 기능을 바로 요약해서 나타내줍니다. map(_:)의 괄호로 감쌀 필요가 없습니다. 만약 어떤 function이 여러개의 closures를 취한다면, 첫번째 trailing closure의 argument label은 생략하고 나머지 trailing closures의 argument label은 적어줍니다. 아래의 function은 photo gallery를 위해 사진을 가져옵니다. func loadPicture(from server: Server, completion: (Picture) -&gt; Void, onFailure: () -&gt; Void) { if let picture = download(\"photo.jpg\", from: server) { completion(picture) } else { onFailure() } } 사진을 가져오기 위해 위의 function을 호출하면, 두개의 closures를 사용할 수 있다. 첫번째 클로저는 completion handler다. 이 클로저는 성공적인 사진 다운로드 후에 사진을 보여준다. 두번째 클로저는 error handler이다. 이 클로저는 사용자에게 에러를 보여준다. loadPicture(from: someServer) { picture in someView.currentPicture = picture } onFailure: { print(\"Couldn't download the next picture.\") } 위의 예제에서 loadPicture(from:completion:onFailure:) function은 network task를 백그라운드로 보내고 그 network task가 완료되었을 때 두개의 completion handlers 중 하나를 호출합니다. 이런 방식으로 function을 작성하는 것은 성공적으로 다운로드 후 UI를 업데이트 하는 코드를 network failure를 다루는 코드로부터 분리시킵니다. Capturing Values 클로저는 constants나 variables가 정의된 곳 안에서 constants나 variables를 capture할 수 있습니다. 그리고나서 해당 클로저의 바디 안에서 캡쳐한 해당 값을 조회하거나 수정할 수 있습니다. 심지어 해당 constants나 variables가 더이상 원래의 범위안에 존재하지 않더라도 클로저는 해당 값을 조회, 수정할 수 있습니다. Swift에서 값을 capture할 수 있는 가장 간단한 형태의 클로저는 바로 다른 function의 바디부분에 작성된 ested function 입니다. nested function은 바깥쪽 function의 argument를 capture할 수 있고 바깥쪽 function 안에 정의된 constants나 variables를 capture할 수 있습니다. 아래 예제는 makeIncrementer이라는 function입니다. incrementer이라는 nested function을 담고 있습니다. 이 nested function인 incrementer()는 자신을 둘러싸고 있는 코드의 전후 관계로부터 runningTotal과 amount라는 두개의 값을 capture합니다. 이 두개의 값을 capturing 한 후, incrementer는 makeIncrementer로부터 클로저로 리턴됩니다. incrementer 클로저는 호출 될 때마다 runningTotal를 amount의 수만큼 증가시킵니다. func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int { var runningTotal = 0 func incrementer() -&gt; Int { runningTotal += amount return runningTotal } return incrementer } makeIncrementer function의 리턴 타입은 () -&gt; Int 입니다. 이것은 makeIncrementer function이 단순한 값이 아니라 function을 리턴한다는 것을 의미합니다. 이 예제에서는 리턴되는 function이 패러미터를 가지고 있지 않고 호출될 때마다 Int 타입의 값을 리턴합니다. makeIncrementer(forIncrement:)는 runningTotal이라는 integer variable을 정의합니다. 이것은 리턴될 incrementer의 현재 runningTotal을 담을 것입니다. 초기값은 0입니다. makeIncrementer(forIncrement:) function은 하나의 Int 패러미터를 가지고 있습니다. 이 패러터는 forIncrement라는 argument lable을 가지고 있죠. amount는 패러미터의 이름입니다. 이 패러미터로 통과된 argument의 값은 리턴된 incrementer function이 호출될 때마다 runningTotal이 얼만큼 증가 될지를 조건으로 지정합니다. makeIncrementer function은 incrementer이라는 이름의 nested function을 정의합니다. 이 function이 실제로 수의 증가를 실행합니다. 이 function은 단순히 amount를 runningTotal에 더하고 그 결과를 리턴합니다. 이 nested function을 따로 떼어놓고 본다면, 이것은 조금 특이해 보일 수 있습니다. func incrementer() -&gt; Int { runningTotal += amount retrun runningTotal } 이 incrementer() function은 패러미터를 가지고 있지 않습니다. 그리고 runningTotal과 amount를 function의 바디부분 안에서 참조하고 있습니다. 이것은 감싸고 있는 function으로부터 runningTotal과 amount의 reference를 capturing 하고 그것을 function의 바디부분에서 사용는 방식으로 이용됩니다. Reference를 capturing하는 것은 makeIncrementer에 대한 호출이 끝났을 때도 runningTotal과 amount가 사라지지 않는 것을 보증합니다. 그리고 또 runningTotal이 incrementer function이 다음에 또 호출될 때도 이용 가능하도록 합니다. 아래는 function makeIncrementer의 사용 예시입니다. let incrementByTen = makeIncrementer(forIncrement: 10) 이 예시는 incrementByTen이라는 constant를 설정하고 incrementer fuction을 참조합니다. 이 function은 호출될 때마다 10을 runningTotal에 더합니다. 아래는 여러번 이 function을 리턴했을 때의 코드입니다. incrementByTen() // 값 10을 리턴 incrementByTen() // 값 20을 리턴 incrementByTen() // 값 30을 리턴 두번째 incrementer을 생성한다면, 그것은 그것만의 분리된 새로운 runningTotal 변수의 reference를 가지게 됩니다. let incrementBySeven = makeIncrementer(forIncrement: 7) incrementBySeven() // 값 7을 리턴 원래의 incrementer인 incrementByTen을 다시 호출하는 것은 계속해서 그것이 참조한 runningTotal의 값을 증가시킵니다. 그리고 incrementBySeven으로부터 capture된 값에는 영향을 미치지 않습니다. incrementByTen() // 값 40을 리턴 Closures Are Reference Types 위의 예시에서, incrementByTen과 incrementBySeven은 constants입니다. 하지만 이 constants가 나타내는 클로저는 여전히 캡쳐한 runningTotal 변수를 증가 시킬 수 있습니다. 이것이 functions와 closures가 reference type인 이유입니다. function이나 closure를 constant나 variable에 할당할 때마다 실제로는 해당 constant와 variable을 function이나 closure의 reference가 되도록 설정하는 것입니다. 두개의 다른 contents나 variables에 하나의 클로저를 할당한다면, 두개 모두 똑같은 클로저를 나타내게 됩니다. let alsoIncrementByTen = incrementByTen alsoIncrementByTen() // 50을 리턴 incrementByTen() // 60을 리턴 위의 예시는 alsoIncrementByTen를 호출하는 것은 incrementByTen을 호출하는 것과 같다는 것을 보여줍니다. 두 개가 같은 클로저를 참조하고 있기 때문에 둘 다 같은 runningTotal을 증가시키고 리턴합니다. Escaping Closures var completionHandlers: [() -&gt; Void] = [] func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) { completionHandlers.append(completionHandler) } 함수가 리턴된 뒤에 해당 함수의 인자로써 통과된 클로저가 호출되는 것을 클로저가 escape한다고 합니다. 클로저를 취하는 패러미터의 타입 앞에 @escaping이라고 적어주면 해당 클로저가 escape된다는 것을 나타낼 수 있습니다. someFunctionWithEscapingClosure(_:) function은 argument로 closure를 가집니다."
  },"/til/2022-06-18-sceneKit.html": {
    "title": "SceneKit 3D Programming for iOS: Getting Started",
    "keywords": "learning 공부 기록 Swift TIL",
    "url": "/til/2022-06-18-sceneKit.html",
    "body": "SceneKit 3D Programming for iOS: Getting Started 아래 모든 정보의 출처는 위의 웹페이지이며 개인의 학습 용도로만 사용되었음을 밝힙니다. Loading a Scene var body: some View { ZStack { SceneView( // 1 scene: scene, // 2 pointOfView: setUpCamera(planet: viewModel.selectedPlanet), // 3 options: .allowsCameraControl ) // 4 .background(ColorPalette.secondary) .edgesIgnoringSafeArea(.all) ... } body부분에 SceneView를 추가해주어 비어있던 앱의 백그라운드를 SceneView로 바꾸어줍니다. // 1 : 어떤 scene을 추가할 것인지 선택합니다. 이 프로젝트에서는 아래와 같이 function을 작성하여 scene 변수에 SCNScene 타입의 값을 할당해두었습니다. 미리 생성해둔(과정 생략, 추가 예정) Solar Scene이라는 이름의 SceneKit Scene File을 이용했습니다. // Create the scene from the scene file static func makeScene() -&gt; SCNScene? { let scene = SCNScene(named: \"Solar Scene.scn\") return scene } // Call makeScene() to load the scene var scene = makeScene() // 2 : pointOfView는 화면에 scene을 비춰줄(보여줄) 카메라입니다. 어떤 게임들은 이 속성을 이용하여 여러개의 카메라를 이동하며 현재 보고 있는 화면의 시점을 바꿀 수 있습니다. // Get a reference to the camera node func setUpCamera(planet: Planet?) -&gt; SCNNode? { let cameraNode = scene?.rootNode .childNode(withName: \"camera\", recursively: false) return cameraNode } // 3 : 여기서는 .allowsCameraControl 옵션을 사용하여 사용자가 카메라를 조정할 수 있도록 하였습니다. 이 외에도 여러가지 옵션을 이용하여 SceneView의 동작을 제어할 수 있습니다. Scene view가 로딩되는 동안 보일 화면의 색을 설정하고, 화면 전체에 scene view가 보여지도록 합니다. 짠 아래처럼 scene이 나타난 화면을 볼 수 있습니다. Adding Object SceneKit이 제공하는 도형을 사용하거나 Metal과 같은 다른 3D 모델링 도구를 이용하여 만든 커스텀 도형을 사용하여 오브젝트를 추가할 수 있습니다. 이 튜토리얼에서는 SceneKit이 제공하는 기본 오브젝트 중 Sphere을 추가하여 태양의 형태를 만들어 봅니다. 오른쪽 위의 + 버튼을 클릭하여 Library를 엽니다. Sphere을 검색하여 찾은 뒤 scene graph에 드래그하여 추가합니다. Modifying Materials 추가한 구의 material을 수정하여 조금 더 태양처럼 보이도록 합니다. Inspectors panel - Materials inspector 을 선택합니다. Diffuse의 색을 클릭하여 컬러 픽커를 가져온 뒤. 색을 선택합니다. Material의 diffuse는 오브젝트의 기본 색상으로 생각하면 됩니다. Illumination 색을 흰색으로 변경합니다. Material의 illumination은 빛이 오브젝트에 닿는 방식을 결정합니다. Attributes inspector에서 구의 반지름을 조정하여 크기를 키웁니다. 크기를 띄운 뒤 앱을 빌드하고 실행하면 태양이 사라져있습니다. 사이즈가 커져서 카메라를 가리게 됩니다. 카메라의 거리를 변경해야 합니다. Setting Up the Camera Node camera 노트를 선택하고 Node inspector(상자 모양)을 선택합니다. camera 노드의 포지션을 변경하는 것은 camera 노드에 첨부된 카메라의 포지션도 변경합니다. (노드에 일어난 변경은 첨부된 것에도 똑같이 일어남.) 모든 Node는 아래의 속성들을 가지고 있습니다. 이 속성들은 Node inspector에서 변경할 수 있습니다. Identity: 노드의 이름. 코드에서 이 이름을 이용하여 노드에 접근합니다. Position: scene에서 노드의 위치 Euler: 노드의 회전 Scale: 각 축에 따른 사이즈를 변경할 수 있음 Node inspector의 position / Euler 값을 변경 Attributes inspector의 Z Clipping 값을 변경 Creating Planets 아래 다섯개의 행성을 추가합니다. Mercury 수성 Venus 금성 Earth 지구 Mars 화성 Saturn 토성 위에서 생성한 태양과 마찬가지로 구(sphere)입니다. 색과 크기, 위치와 같은 디테일을 설정할 것입니다. Mercury 먼저 Objects Library에서 구 하나를 생성해 줍니다. Node inspector에서 x:0 y:0 z:25 그리고 이름을 mercury로 변경합니다. Material inspector에서 Diffuse를 #BBBBBB로 변경합니다. Roughness 값을 1로 변경합니다. 이 값을 변경하면 물체를 빛나게 하거나 그 반대로 설정할 수 있습니다. 0이 가장 빛나는 값 -&gt; 1이 빛을 가장 적게 반사하는 값입니다. 빌드하고 실행시켜봅니다! SceneKit으로 우리의 첫 번째 행성을 렌더링 해 보았습니다."
  }}
