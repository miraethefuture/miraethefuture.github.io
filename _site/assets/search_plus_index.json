{"/pages/about/": {
    "title": "About",
    "keywords": "Jekyll",
    "url": "/pages/about/",
    "body": "This is an about page."
  },"/pages/contact/": {
    "title": "Contact",
    "keywords": "Jekyll",
    "url": "/pages/contact/",
    "body": "This is an contact page."
  },"/pages/design/draft/": {
    "title": "Design Draft",
    "keywords": "Jekyll",
    "url": "/pages/design/draft/",
    "body": "This is an draft page."
  },"/til/2023-10-10-Scrumdinger.html": {
    "title": "앱 Scrumdinger 튜토리얼을 따라가며 정리",
    "keywords": "TIL",
    "url": "/til/2023-10-10-Scrumdinger.html",
    "body": "Scrumdinger app tutorial 이 글은 위 튜토리얼을 따라가며 정리한 내용입니다. Create a color theme 앱 전체에 일관된 스타일을 주기 위해 컬러 테마를 생성하기. 뷰 파일이 아니지만 Foundation을 제거하고 SwiftUI를 import (SwiftUI 프레임워크의 Color을 사용하기 때문) SwiftUI는 컬러를 뷰 계층에 바로 추가할 수 있는 하나의 뷰 인스턴스로 취급함. String 타입의 값을 raw value로 가지는 enum 생성 enum Theme: String { case bubblegum case buttercup case indigo case lavender var accentColor: Color { switch self { case .bubblegum, .buttercup, .lavender: return .black case .indigo: return .white } } } 위와 같이 case 이름만 작성해주면 Swift가 자동으로 스트링 타입의 raw value를 생성함. enum 안에 switch self를 사용하여 case 별로 값을 리턴하는 컬러 프로퍼티를 생성 Managing data flow between views Source of truth source of truth == 원천데이터 원천데이터를 사용하지 않으면 뷰에 나타나는 데이터가 불일치하는 버그가 생길 수 있음. 데이터를 가지고 있는 요소를 한 장소에 보관하고 뷰들이 그 데이터에 접근하도록 함. 앱 전체 코드를 통하는 원천데이터를 생성할 수도 있음. 원천 데이터를 정의하는 방식과 위치는 여러 뷰들 사이에서 공유되는 데이터인지, 변하는 데이터인지에 따라 다름. Swift property wrappers 스위프트의 프로퍼티 래퍼를 사용하여 특정 행동을 하는 속성을 만들 수 있음. 일반적으로 많이 사용되는 속성의 동작들을 캡슐화 해놓은 것. State는 그런 프로퍼티 래퍼중 하나로 뷰 안에서 원천데이터를 생성함. @State 사용자의 상호작용으로 @State 속성의 값이 변경될 수 있음. 이때 시스템은 이 새로운 값을 가진 버전의 뷰를 자동으로 다시 그림. state 속성은 일시적인 상태를 관리하는 것에 사용됨. (예: 버튼의 상태, 필터링 버튼, 현재 선택된 리스트 아이템..) 그렇기 떄문에 private으로 선언함. (한 뷰 안에서 일시적으로 변화되는 값들이기 때문에..) 같은 이유로 영속적으로 보관되어야 하는 데이터에는 사용하지 않음. @State 프로퍼티 래퍼는 하나의 뷰 안에서 변경되는 원천 데이터를 담기 위해 사용되는데, 만약 여러개의 뷰 계층 속에서 같은 원천데이터를 사용하고 싶다면..? @Binding Binding은 state 속성과 똑같이 원천데이터를 읽거나 값을 변경할 수 있음. @Binding은 데이터를 직접 담지 않고 원천 데이터와 뷰 사이에 양방향 커넥션을 생성함. 이 커넥션은 하나의 데이터와 관련된 뷰들이 같은 데이터 상태를 가지도록 함. 시스템은 원천데이터를 가진 부모뷰와 @Binding을 가진 자식뷰의 관계를 성립시킴. 이때는 자식뷰, 부모뷰 모두 원천데이터를 읽거나, 수정할 수 있음. 만약 자식뷰가 read-only 속성을 가지고 있다면, 원천데이터를 보내기만 할 수 있음. (수정은 안됨.) 두 경우 모두, 프레임워크가 자동으로 뷰를 업데이트 함. Making classes observable Working with reference types @State 속성은 구조체나 열거형과 같은 value type 원천데이터만 정의할 수 있다. 클래스와 같은 reference type인 원천데이터를 정의하려면 @State가 아닌 아래 세가지 프로퍼티 래퍼를 사용해야 한다. @ObservedObject @StateObject @EnvironmentObject 이 프로퍼티 래퍼들을 사용하려면 먼저 원천데이터가 될 클래스를 observable한 상태로 만들어주어야 한다. Making a class observable ObservableObject 프로토콜을 따르는 클래스를 생성하여 클래스를 observable 하도록 만들 수 있다. (observable의 사전적 의미 중 하나는 ‘관찰할 수 있는’이다. 클래스를 observable 하도록 만든다는 건, 다른 어떤 것들이 이 클래스를 관찰할 수 있도록 만든다는 것이다.) class ScrumTimer: ObservableObject { @Published var activeSpeaker = \"\" @Published var secondsElapsed = 0 @Published var secondsRemaining = 0 // ... } 이 클래스 안에서 위 세개의 속성들은 자신의 값이 변할 때 UI를 업데이트 해야한다. 이런 속성들은 @Published를 사용하여 정의한다. 이 published property의 값이 변경될 때 ScrumTimer가 자신을 관찰하고 있는 관찰자에게 이 변경사항을 알린다. Monitoring an object for changes ObservedObject, StateObject, EnvironmentObject 이 세가지의 속성 중 하나를 사용하여 SwiftUI가 observable 객체를 모니터링하도록 할 수 있다. 이 속성을 사용하여 정의된 프로퍼티는 원천데이터가 된다. struct MeetingView: View { @StateObject var scrumTimer = ScrumTimer() // ... } @StateObject 래퍼를 사용하여 observable 객체를 생성한다. App, Scene, View에서 스테이트 객체를 생성할 수 있다. 시스템이 스테이트 객체를 초기화하면 해당 스트럭처 또는 객체를 전달 받은 다른 뷰에서 해당 객체를 사용할 수 있다. Managing state and life cycle struct MeetingFooterView: View { let speakers: [ScrumTimer.Speaker] private var isLastSpeaker: Bool { return speakers.dropLast().allSatisfy { $0.isCompleted } } } 🖍️ 이 뷰 안에서만 필요한 computed property이기 때문에 private으로 선언 🖍️ dropLast()를 사용하여 speakers 배열의 마지막 요소를 제외한 배열을 리턴함. 🖍️ allSatisfy()를 사용하여 마지막 speaker를 제외한 모든 speakers의 isCompleted 이 true라는 bool 값을 리턴함. dropLast(_:) let numbers = [1, 2, 3, 4, 5] print(numbers.dropLast(2)) // Prints \"[1, 2, 3]\" print(numbers.dropLast(10)) // Prints \"[]\" 🖍️ 마지막 요소만 제외하거나, 제외할 요소의 수를 정할 수 있음. 위 코드에서는 2를 통과시켜 맨 뒤에서부터 배열의 요소 2개를 제외한 배열을 리턴 🖍️ 배열의 카운트보다 큰 수를 통과시킬 경우 빈 배열을 리턴 allSatisfy(_:) let names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"] let allHaveAtLeastFive = names.allSatisfy({ $0.count &gt;= 5 }) // allHaveAtLeastFive == true 🖍️ 배열의 모든 요소가 5자 이상인 이름인지를 bool 값으로 리턴함. import Foundation /// Keeps time for a daily scrum meeting. Keep track of the total meeting time, the time for each speaker, and the name of the current speaker. @MainActor final class ScrumTimer: ObservableObject { /// A struct to keep track of meeting attendees during a meeting. struct Speaker: Identifiable { /// The attendee name. let name: String /// True if the attendee has completed their turn to speak. var isCompleted: Bool /// Id for Identifiable conformance. let id = UUID() } // ... } 🖍️ 주석 /// 을 사용하여 Xcode에서 보여지는 문서를 작성할 수 있음 Adopting Swift Concurrency Swift 코드로 복잡한 비동기 작업을 단순화 해보자! SwiftUI 앱에서는 메인 스레드가 모든 UI 작업을 실행한다. 또, 탭하거나 스와이프하는 것과 같은 유저 이벤트를 처리한다. 앱이 제대로 작동하기 위해서는 모든 뷰 업데이트 작업과 이벤트 핸들러를 메인 스레드에서 실행해야 한다. 하지만 만약 모든 작업을 메인 스레드에서 처리한다면 앱이 느린 것과 같이 느껴질 수 있다. 만약 메인 스레드가 모든 코드를 처리하는 것을 기다려야 한다면, 앱이 느리거나 심지어 멈춘 것처럼 느껴질 수 있다. 그렇기 때문에 가능한 작업은 백그라운드 스레드에서 실행하고, 꼭 필요한 작업을 메인 스레드에서 실행하며 균형을 맞춰야 한다. 디스크에 있는 데이터를 읽고, 디스크에 데이터를 입력하는 작업을 비동기적으로 작성해보자. 이 작업에서는 스위프트의 비동기 함수, Task 타입, @MainActor 어노테이션을 사용할 것이다. Defining an asynchronous function 비동기 함수는 파라미터 리스트 뒤에 async 키워드를 추가하여 정의한다. 리턴값이 있을 경우 리턴 애로우 앞쪽에 표시한다. final class UserStore { func fetchParticipants() asyns -&gt; [Participant] {...} } Calling an asynchronous function await 키워드를 사용하여 비동기 함수를 호출한다. await 키워드는 비동기적인 흐름, 문맥에서만 사용할 수 있다. 아래 UserStore 클래스는 비동기 함수인 refresh() 안에서 fetchParticipants() 함수를 await를 사용해서 호출하고 있다. final class UserStore { func refresh() async -&gt; [UserRecord] { let participants = await fetchParticipants() let records = await fetchRecords(participants: participants) return records } func fetchParticipants async -&gt; [Participant] {...} func fetchRecords(participants: [Participant]) async -&gt; [UserRecord] } fetchParticipants()가 작업을 완료하는 동안 refresh() 함수는 잠시 멈춤. 그동안 refresh()를 실행하는 스레드는 다른 작업을 할 수 있음. fetchParticipants()의 작업이 완료되면, 시스템은 refresh() 함수의 다음 라인을 실행함. fetchRecords(participants: participants) 함수가 호출할 때 fetchParticipants()의 리턴값을 사용할 수 있음. 비동기 함수를 사용하면 작성돼있는 순서로 코드를 실행함."
  },"/til/2023-09-06-stickyHeader.html": {
    "title": "SwiftUI 이중 스티키 헤더",
    "keywords": "TIL",
    "url": "/til/2023-09-06-stickyHeader.html",
    "body": "import SwiftUI struct ContentView: View { @State private var hidePointView = false @State private var isFirstShown = true var body: some View { VStack(spacing: 0) { ScrollView { VStack(spacing: 0) { LazyVStack(pinnedViews: [.sectionHeaders], content: { Section(header: tempClearHeader) { videoView } }) LazyVStack(pinnedViews: [.sectionHeaders], content: { Section(header: tabViewHeader) { Text(\"리뷰 모아보기\") .font(.system(size: 18, weight: .bold)) .frame(height: /*@START_MENU_TOKEN@*/100/*@END_MENU_TOKEN@*/) .padding(.horizontal, 20) } }) LazyVStack(pinnedViews: [.sectionHeaders], content: { Section(header: categoryHeader) { tabViewBody } }) } } .overlay(alignment: .top) { pointViewHeader .opacity(hidePointView ? 0 : 10) } } .padding(.top, 1) .background(.yellow) } var pointViewHeader: some View { HStack { Image(systemName: \"globe\") .imageScale(.large) .foregroundStyle(.tint) Text(\"PointView\") } .frame(minWidth: 0, maxWidth: .infinity) .frame(height: 50) .foregroundColor(.white) .background(.black) } var tabViewHeader: some View { HStack { Spacer() Text(\"영상 리뷰\") Spacer() Text(\"포토 리뷰\") Spacer() } .frame(minWidth: 0, maxWidth: .infinity) .frame(height: 50) .foregroundColor(.white) .background(.black) } var tabViewBody: some View { VStack { ForEach(0..&lt;3) { row in HStack(spacing: 20) { Spacer() Rectangle() .fill(.gray) .frame(minWidth: 0, maxWidth: .infinity) .frame(height: 240) .padding([.top, .bottom]) Rectangle() .fill(.gray) .frame(minWidth: 0, maxWidth: .infinity) .frame(height: 240) .padding([.top, .bottom]) Spacer() } } } } var categoryHeader: some View { HStack { Spacer() Text(\"버튼\") Spacer() Text(\"버튼\") Spacer() Text(\"버튼\") Spacer() Text(\"버튼\") Spacer() } .frame(minWidth: 0, maxWidth: .infinity) .frame(height: 50) .foregroundColor(.white) .background(.green) } var videoView: some View { VStack(spacing: 0) { Rectangle() .fill(.red) .frame(height: 202) } } var tempClearHeader: some View { HStack { Text(\"temp\") } .frame(minWidth: 0, maxWidth: .infinity) .frame(height: 50) .foregroundColor(.white) .background(.black) .onDisappear { hidePointView.toggle() } .onAppear { if !isFirstShown { hidePointView.toggle() } isFirstShown = false } } } struct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView() } } 탭뷰 헤더는 VStack 사용해도 될 것 같음 -&gt; VStack 바깥에 ScrollView 있기 때문에 화면 밖으로 헤더가 사라져서 안됨. LazyVStack Pinned header를 특정 조건에 따라 나타나게 할 수 있을까? 전체 LazyVStack을 pointView가 나타날때 아래로 내리면? header 부분만 내릴 수 있음 all header pinned 가 되는 부분을 찾아야 함 TrackableScrollView // // ContentView.swift // StickyHeaderWithoutLazy // // Created by Mirae on 9/6/23. // * overlay point view -&gt; 위 아래로 움직일 때 나타나는 뷰 // * 맨 위에는 스티키로 하나 넣고 import SwiftUI struct ContentView: View { @State private var allHeaderPinned = false @State private var hidePointView = false @State private var pullDownView = false @State private var scrollOffset = 0.0 var body: some View { ScrollViewReader { scrollProxy in OffsettableScrollView { offsetProxy in if self.scrollOffset &gt; offsetProxy.y { // scrollState = true print(\"true\") // 스크롤 withAnimation { hidePointView = true pullDownView = true } } else { // scrollState = false print(\"false\") // 역스크롤 withAnimation { hidePointView = false pullDownView = false } } self.scrollOffset = offsetProxy.y } content: { LazyVStack(spacing: 0, pinnedViews: [.sectionHeaders], content: { // pointViewHeader 자체에서 조건문으로 height 를 변경 (색 맞춰서 보이지 않게) Section(header: pointViewHeader) { videoView } VStack(spacing: 0) { LazyVStack(pinnedViews: [.sectionHeaders], content: { // on Disppear 시 hidePointView 변경됨) Section(header: tempClearHeader) { } }) LazyVStack(spacing: 0, pinnedViews: [.sectionHeaders], content: { Section(header: tabViewHeader) { GeometryReader { geometry in VStack(alignment: .leading, spacing: 2) { Text(\"리뷰 모아보기\") .font(.system(size: 18, weight: .bold)) Text(\"💰위글 영상 리뷰보고 포인트 쌓자!\") .font(.system(size: 14, weight: .regular)) } .padding(.horizontal, 20) .offset(y: geometry.size.height) .onChange(of: geometry.frame(in: .global).minY) { minY in withAnimation { if minY &lt; 0 { allHeaderPinned = true } else { allHeaderPinned = false } } print(\"minY: \\(minY)\") } // let _ = print(\"\\(geometry.size.height)\") // PRINT: 10.0 } .padding(.vertical, 10) LazyVStack(pinnedViews: [.sectionHeaders], content: { Section(header: categoryHeader) { tabViewBody } }) } }) .offset(y: -1) } }) .background(.yellow) } .overlay(alignment: .top) { withAnimation { pointViewHeader .opacity((allHeaderPinned == true &amp;&amp; hidePointView) ? 10 : 0) // overlay는 pinned header들이 아래로 밀리지 않아서 사용할 수 없음 } } .padding(.top, 1) } } var pointViewHeader: some View { HStack { Image(systemName: \"globe\") .imageScale(.large) .foregroundStyle(.tint) Text(\"2,759\") .font(.system(size: 18, weight: .bold)) Spacer() } .frame(minWidth: 0, maxWidth: .infinity) .frame(height: 50) .foregroundColor(.white) .background(.black) } var pointViewHeaderOverlay: some View { HStack { Image(systemName: \"globe\") .imageScale(.large) .foregroundStyle(.tint) Text(\"2,759\") .font(.system(size: 18, weight: .bold)) Spacer() } .frame(minWidth: 0, maxWidth: .infinity) .frame(height: 50) .foregroundColor(.white) .background(.blue) } var tabViewHeader: some View { HStack { Spacer() Text(\"영상 리뷰\") Spacer() Text(\"포토 리뷰\") Spacer() } .frame(minWidth: 0, maxWidth: .infinity) .frame(height: 50) .foregroundColor(.white) .background(.black) .offset(y: (allHeaderPinned == true &amp;&amp; pullDownView) ? 50 : 0) } var tabViewBody: some View { VStack { ForEach(0..&lt;5) { row in HStack(spacing: 20) { Spacer() Rectangle() .fill(.gray) .frame(minWidth: 0, maxWidth: .infinity) .frame(height: 240) .padding([.top, .bottom]) Rectangle() .fill(.gray) .frame(minWidth: 0, maxWidth: .infinity) .frame(height: 240) .padding([.top, .bottom]) Spacer() } } } } var categoryHeader: some View { HStack { Spacer() Button(action: { // }, label: { Text(\"Button\") }) Spacer() Text(\"버튼\") Spacer() Text(\"버튼\") Spacer() } .frame(minWidth: 0, maxWidth: .infinity) .frame(height: 50) .foregroundColor(.white) .background(.green) .padding(.top, 50) // 카테고리 헤더가 탭뷰 헤더 아래에 붙도록 패딩 조정 .offset(y: (allHeaderPinned == true &amp;&amp; pullDownView) ? 50 : 0) } var videoView: some View { VStack(spacing: 0) { Rectangle() .fill(.red) .frame(height: 202) } } var tempClearHeader: some View { HStack { Text(\"\") } .frame(minWidth: 0, maxWidth: .infinity) .frame(height: 1) .foregroundColor(.white) .background(.yellow) // 배경이랑 같은 색으로 맞추기 } } struct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView() } }"
  },"/til/2023-07-04-CodingTestTIL.html": {
    "title": "Coding Test TIL",
    "keywords": "TIL",
    "url": "/til/2023-07-04-CodingTestTIL.html",
    "body": "백준 10811번: 바구니 뒤집기 import Foundation let input = readLine()!.components(separatedBy: \" \") let n = Int(input[0])! let m = Int(input[1])! var originArray = Array(1...n) for _ in 1...m { let indices = readLine()!.components(separatedBy: \" \") let startIndex = Int(indices[0])! let endIndex = Int(indices[1])! // 왜 ... 가 아니고 ..&lt; 이거지? let slicedAndReversed = originArray[startIndex-1..&lt;endIndex-1].reversed() let slicedAndReversedArr = Array(slicedAndReversed) originArray.removeSubrange(startIndex-1..&lt;endIndex-1) originArray.insert(contentsOf: slicedAndReversedArr, at: startIndex) } // 틀린 부분 print(originArray) // 틀린 부분 수정 originArray.forEach { print($0, terminator: \" \") } // print의 terminator 파라미터는 기본값으로 \"\\n\"을 가짐 // 프린트 되는 값 뒤에 함께 프린트 되는 값으로 기본값이 \\n이기 때문에 forEach를 사용하여 여러개의 값을 프린트하면 // line break와 함께 출력됨 // 위 예시 코드에서는 각 요소가 출력 될 때마다 space를 출력함 프로그래머스 : 내적 import Foundation func solution(_ a:[Int], _ b:[Int]) -&gt; Int { let n = a.count var array: [Int] = [] for index in 0..&lt;n { array.append(a[index] * b[index]) } let sumResult = array.reduce(.zero, +) return sumResult } forEach 문은 느리기 때문에 시간제한에 걸릴 수 있음."
  },"/til/2023-07-03-SwiftUIUpdates.html": {
    "title": "SwiftUI 업데이트",
    "keywords": "TIL",
    "url": "/til/2023-07-03-SwiftUIUpdates.html",
    "body": "onChange(of:initial:_:) 파라미터 value : of 뒤에 작성되는 값으로, value의 값에 변화가 생기면 onChange 클로저가 실행됨 initial : initial에 해당하는 뷰가 먼저 나타나면 onChange 속 동작이 실행됨 action : value 값이 변경되었을 때 실행되는 클로저 oldValue : 비교 체크를 실패한 예전 값 또는 처음 값 newValue : 비교 체크를 실패한 새로운 값 리턴값 특정 value가 변경될 때 어떤 동작을 실행하는 뷰를 리턴함 Discussion onChange를 사용하여 특정 값이 변경되었을 때 어떤 동작이 일어나도록 할 수 있음. 긴 시간동안 실행되는 테스크에 사용하는 것은 피해야 함 struct PlayerView: View { var episode: Episode @State private var playState: PlayState = .paused var body: some View { VStack { Text(episode.title) Text(episode.showTitle) PlayButton(playState: $playState) } .onChange(of: playState) { oldState, newState in model.playStateDidChange(from: oldState, to: newState) } } } 매크로 매크로를 사용하면 반복적으로 사용되는 코드를 컴파일 할 때 생성할 수 있음. 반복적인 코드를 짧게 줄일 수 있으므로 더 읽기 편해짐. /// Slopes in my favorite ski resort. enum Slope { case beginnersParadise case practiceRun case livingRoom case olympicRun case blackBeauty } /// Slopes suitable for beginners. Subset of `Slopes`. enum EasySlope { case beginnersParadise case practiceRun init?(_ slope: Slope) { switch slope { case .beginnersParadise: self = .beginnersParadise case .practiceRun: self = .practiceRun default: return nil } } var slope: Slope { switch self { case .beginnersParadise: return .beginnersParadise case .practiceRun: return .practiceRun } } } Slope 타입에 있는 case 중 초보자에게 적합한 slope이 있을 경우, EasySlope 타입으로 변환함. 이때 초보자에게 적합한 slope을 추가하기 위해서는 Slope 타입의 case, EasySlope 타입의 case, 이니셜라이저, computed property인 slope에 총 네번 코드를 추가해 주어야 함. 위 작업을 매크로를 사용해서 줄일 수 있는지 알아보겠음. 이니셜라이저와 컴퓨티드 프로퍼티는 EasySlope 타입의 멤버임. -&gt; attached member 매크로를 정의할 것 매크로를 구현할 컴파일러 플러그인을 생성해야 함. 매크로가 원하는대로 동작하는지 확인하기 위해서 test driven way로 코드를 작성. 정상적으로 코드를 작성할 시, 이니셜라이저에 해당되는 코드를 제거하고, 이니셜라이저 코드를 컴파일 타임에 생성할 매크로를 추가하게 됨. // EasySlope의 멤버인 이니셜라이저를 생성할 매크로 @attached(member, names: named(init)) // SlopeSubset은 매크로의 이름 public macro SlopeSubset() = #externalMacro(module: \"MyMacroMacros\", type: \"SlopeSubsetMacro\") 여기까지는 매크로의 정의. 아직 implementation 부분을 작성한 것은 아님. (실행될 코드 부분을 expansion이라고 함.) “SlopeSubsetMacro” 타입을 생성해야 함. // attached member 매크로는 MemberMacro 프로토콜을 따라야 함. // MemberMacro 요구사항은 하나 -&gt; expansion() 함수 public struct SlopeSubsetMacro: MemberMacro { public static func expansion( of attribute: AttributeSyntax, providingMembersOf declaration: some DeclGroupSyntax, in context: some MacroExpansionContext ) throws -&gt; [DeclSyntax] { return [] } } // providingMacros 프로퍼티를 작성하여 컴파일러가 작성한 매크로를 감지할 수 있도록 함. @main struct WWDCPlugin: CompilerPlugin { let providingMacros: [Macro.Type] = [ SlopeSubsetMacro.self ] } #stringify : 스트링이파이 매크로 let calculations = [ (1 + 1, \"1 + 1\"), (3 * 2, \"3 * 2\"), ] let calculations = [ #stringify(1 + 1) #stringify(3 * 2) ] // 매크로 정의 @freestanding(expression) // 2 macro stringify(_ value: Int) -&gt; (Int, String) // 1 // 1: function 정의와 비슷함. Int 값을 파라미터로 받고 output 값으로 Int, String을 반환함. // 2: freestanding expression macro role을 사용하여 정의되었는데, 이것은 expression을 사용하는 곳엔 어디서든 매크로를 사용할 수 있도록 한다는 의미. 파라미터의 타입이 일치하는지 체크하고 (제네릭 타입 매크로도 작성 가능), 컴파일러는 macro expansion 실행 (macro expansion은 매크로가 실행되고 값을 리턴하는 과정을 말함) @freestanding(expression) @attached(member)"
  },"/til/2023-05-24-ViewLayout.html": {
    "title": "SwiftUI 뷰 레이아웃",
    "keywords": "TIL",
    "url": "/til/2023-05-24-ViewLayout.html",
    "body": "struct ReusableLabel: View { let keyword: String let symbol: String var body: some View { Label(keyword, systemImage: symbol) .font(.title) .foregroundColor(.white) .padding() .background(.green.opacity(0.75), in: Capsule()) // - 1 } } struct ReusableLabel_Previews: PreviewProvider { // - 2 static let keywords = [\"Hello\", \"Good Morning\"] static var previews: some View { // - 3 VStack { // - 4 ForEach(keywords, id: \\.self) { word in KeywordBubbleDefaultPadding(keyword: word, symbol: \"fish\") } } } } 1: .background에 Capsule()을 정의해줌으로써 캡슐 모양이 Label의 뒷쪽에 오도록 함. 이때 .padding()을 백그라운드의 윗쪽에 선언해주어야 패딩을 포함한 백그라운드에 캡슐 모양을 생성할 수 있음. 2: PreviewProvider 프로토콜을 사용하여 커스텀 스위프트UI 뷰의 코드가 생성하는 화면을 미리 볼 수 있음 3: PreviewProvider 프로토콜을 구현하기 위해선 static previews 프로퍼티를 정의해야 함 4: VStack 안에 ForEach를 사용하여, ReusableLabel 스트럭쳐가 생성하는 라벨 뷰가 다른 텍스트 길이에서 어떻게 적용되는지 한 화면에서 확인할 수 있음 ScaledMetric를 사용하여 동적으로 넓이 조정하기 padding() modifier를 사용하여 패딩을 주었을 때, 폰트 사이즈가 달라지면 아래 이미지와 같이 큰 사이즈의 폰트에서는 패딩이 충분하지 않는 경우가 있음 이때 패딩 값을 그냥 키워주면 작은 폰트에서는 패딩이 너무 넓어질 수 있음 @ScaledMetric 프로퍼티 래퍼를 사용하여 .title과 같은 environment’s effective font size에 숫자값을 적용할 수 있음 struct KeywordBubbleDefaultPadding: View { let keyword: String let symbol: String @ScaledMetric(relativeTo: .title) var paddingWidth = 20.5 // &lt;- 여기 var body: some View { Label(keyword, systemImage: symbol) .font(.title) .foregroundColor(.white) .padding(paddingWidth) // &lt;- 여기 // .padding() .background(.green.opacity(0.75), in: Capsule()) } } Layering Content 어떤 컨텐츠를 겹쳐서 (z-axis) 나타낼 때, ZStack{}/.overlay()/.background()을 사용 ZStack 다른 뷰들과 상관 없이, 사용 가능한 공간에 따라 뷰의 사이즈를 정함 다른 컨텐츠의 사이즈와 관련하여 뷰의 사이즈를 조정하고 싶다면 overlay와 background를 사용하면 됨 Image() 뷰 이니셜라이저는 기본적으로 이미지의 원래 사이즈로 이미지를 가져옴 resizable() 모더파이어와 scaledToFit() 같은 모더파이어를 사용하여 이미지 사이즈를 조정할 수 있음 .clipShape(RoundedRectangle(cornerRadius: 10.0, style: .continuous)) 을 사용하여 뷰의 위치나 크기를 변경하지 않고 corner radius를 설정할 수 있음"
  },"/til/2023-05-24-TIL.html": {
    "title": "TIL",
    "keywords": "TIL",
    "url": "/til/2023-05-24-TIL.html",
    "body": "DS_Store DS_Store는 해당 폴더에 대한 Finder 관련 정보를 가지고 있으므로, 다른 컴퓨터에는 영향을 주지 않음. 커밋 시 ignore 하여도 무방함. SwiftUI VideoPlayer 영상 looping @State private var queuePlayer: AVQueuePlayer = AVQueuePlayer() @State private var playerLooper: AVPlayerLooper! struct SomeView: View { VideoPlayer(player: queuePlayer) .onAppear { guard let url = URL(string: \"stringUrl\") else { return } if queuePlayer.currentItem?.status.rawValue != 1 { print(\"player status readyToPlay\") let asset = AVAsset(url: url) let item = AVPlayerItem(asset: asset) playerLooper = AVPlayerLooper(player: queuePlayer, templateItem: item) } queuePlayer.play() } .onDisappear { queuePlayer.pause() } } 하나의 영상을 반복 재생하기 AVQueuePlayer와 AVPlayerLooper를 사용 url을 통해 영상 데이터를 가져옴 AVAsset, AVPlayerItem, AVPlayerLooper를 사용하여 반복 재생하였으나 paged style tab view 안에 재생되는 비디오가 page 이동 후 돌아오면 아래와 같은 에러가 발생함. An AVPlayerItem can occupy only one position in a player’s queue at a time Lazy Stored Property lazy stored property의 초기값은 해당 속성이 사용되기 전까지 계산되지 않음. lazy property는 var 키워드를 사용하여 항상 변수로 선언해야 함. lazy 속성은 인스턴스 초기화가 완료된 후에도 초기값이 없을 수 있음(사용되기 전이기 때문에). 반면에, 상수(Constant) 속성은 객체 초기화 전에 값을 꼭 가져야 하기 때문에 lazy 속성으로 정의될 수 없음. class DataImporter { /* DataImporter 클래스는 외부의 파일로부터 데이터를 가져옴. 이 객체를 초기화하는 시간이 꽤 걸린다고 가정함. */ var filename = \"data.txt\" } class DataManager { lazy var importer = DataImporter() var data: [String] = [] // 데이터를 관리하는 기능을 제공하는 객체 } let manager = DataManager() manager.data.append(\"Some data\") manager.data.append(\"Some more data\") // 아직까지는 importer에 할당될 DataImporter의 인스턴스가 생성되지 않음. 스터디 과제 진행하며 정리 (~6/7) @State 프로퍼티는 항상 private으로 사용 (해당하는 뷰와 서브 뷰의 특정한 정보를 담기 때문) observable object class 수정 published 값이 옵셔널로 설정되어 있음 -&gt; 뷰 부분에서 처리해주어야 하는 불편함을 해결하기 위해 수정 final class로 변경 Combine 추가 데이터 로드하는 함수를 제네릭 함수로 변경 데이터 로드 함수를 실행하는 init() 제거 데이터 로드 함수가 observable object 클래스 안이 아닌 바깥 쪽에 정의 func testSearching() throws { let searchText = \"주차\" let result = ModelData().roomList.rooms.filter { $0.hashTags.contains(searchText) } XCTAssertEqual(result.count, 40) } 간단한 테스트 코드 작성하여 search function test 위 코드에서 searchText의 값과 XCTAssertEqual()의 값만 변경하여 여러가지 검색어 상황에 따른 데이터 결과를 확인할 수 있었음 문제 해결 내용 swift let file = Bundle.main.url(forResource: filename, withExtension: \"txt\") 에서 withExtension을 nil로 주면 이름이 일치하는 첫번째 파일을 가져온다고 하여 nil로 주었으나 파일을 찾지 못한다는 에러가 발생하여 파일의 익스텐션인 “txt”로 수정하여 해결 검색 기능을 추가하면서 search text를 해시 태그로 가지고 있는 방 데이터를 필터링하여 목록을 생성. 이 목록을 @State 변수에 할당해야 하는데, 현재 버튼으로 필터링하기 위해 computed property를 사용하고 있음. 스터디 과제 진행하며 정리 (~7/19) final 키워드가 붙은 class는 서브 클래스가 오버라이딩할 수 없음 SwiftUI Source of truth 생성하기 @State와 @Binding은 value type(ex. structure, enum)을 뷰를 업데이트하는 source of truth로 만들어 줌 value type이 아니고 reference type인 클래스는 @ObservedObject, @StateObject, @EnvironmentObject 프로퍼티 래퍼를 사용 @ObservedObject, @StateObject, @EnvironmentObject를 사용하기 위해서 클래스를 observable하게 만들어 주어야 함 @StateObject는 observable 객체를 생성 @ObservedObject는 parent view로부터 객체를 받는다는 걸 나타냄 (@StateObject로 생성된 객체를 받음) @EnvironmentObject는 복잡한 뷰에서 사용됨. 이니셜라이저를 통해 객체를 통과시키지 않고 .environmentObject() 모더파이어를 통해 해당 뷰가 객체를 사용할 수 있도록 함 (부모-자식-자식의 자식뷰에서 자식뷰가 .environmentObject() 모더파이어를 통해 객체를 사용할 수 있게 되면 자식의 자식뷰도 @EnvironmentObject 속성을 통해 사용할 수 있게 됨) 클래스가 ObservableObject 프로토콜을 따르도록 만들면 됨 클래스 안에는 값이 변경되었을 때 UI가 업데이트 되어야 하는 속성들이 정의됨 각 속성은 @Published atrribute를 사용해 정의되어 뷰에서 사용할 수 있게됨 Scene architecture Scene의 구조 하나의 앱을 만들기 위해서, App 프로토콜을 따르는 스트럭처를 생성함 이때 앞에 @main 어트리뷰트를 사용하여 이 스트럭처가 앱의 유일한 entry point라는 것을 시스템에 알려줌 앱 스트럭처의 바디 부분에 Scene 프로토콜을 따르는 스트럭처를 생성 (여러개 생성 가능) Scene은 앱이 보여줄 뷰 게층을 담을 컨테이너 보통 iOS / WatchOS는 하나의 Scene을 가지고 macOS / iPadOS 는 여러개의 Scene을 가짐 Scene Phases and transitions Scene의 단계와 변형 과정 앱이 실행되는 동안 Scene은 세 단계로 변화될 수 있음 active: scene이 foreground에 있고 사용자가 상호작용할 수 있음 inactive: scene이 보이지만, 시스템이 scene과 상호작용할 수 없음. 예를 들면, 아이패드에서 멀티태스킹 기능을 사용할 때 사용하지 않는 쪽은 보이지만 inactive 상태임. (scene은 foreground에 있음) background: 앱이 작동하고 있지만 사용자는 앱을 볼 수 없음. 앱이 꺼지기 직전에 Scene이 이 단계가 됨. scenePhase environment value를 사용해서 현재 scene의 상태를 알 수 있음. scene이 특정 상태가 됐을 때, 어떤 동작을 수행하도록 할 수 있음. (ex. 앱이 inactive 상태가 될 때 데이터를 저장하도록 함) Events and State 프로그램의 상태가 변할 때 뷰도 변하도록 하는 imperative 패턴과는 다르게, SwiftUI는 declarative 프로그래밍 패턴을 따름 SwiftUI의 뷰 바디에, 모든 상태에 대해 UI가 어떻게 나타날지 묘사함 프로그램이 실행되는 동안, 상태가 변함에 따라 변화되어야 하는 UI를 업데이트 함으로써 상태(state)와 UI가 서로 동기화되도록 함 사용자와의 상호작용이나, 알림 같은 event는 앱이 응답해야하는 상황을 만드는데, 이때 클로저가 이벤트의 응답으로써 실행됨. 이것이 Source of truth를 변경시킴 Source of truth에 일어난 변화를 감지하고, 이것을 뷰에 업데이트 하고 UI를 렌더링함 View life cycle events 뷰가 나타나더나 스크린에서 사라질 때, 앱의 상태를 변경시키려면 onAppear(perform:) / onDisappear(perform:) / task(priority:_:) modifier 를 사용 SwiftUI 기본 Structure var body: some View { } 는 Scene, View, App 프로토콜을 다르는 structure가 꼭 구햔헤야 하는 필수 computed property @main 으로 표시하여 App의 entry point를 정의할 수 있음. 앱에는 단 하나의 entry point만이 존재할 수 있음 아래 예시에서 WindowGroup은 첫번째 scene, Settings는 두번째 scene Settings scene은 거의 모든 mac앱에서 볼 수 있는 Settings 메뉴를 생성 Settings scene은 macOS 에서만 사용 가능 #if os(iOS) // iOS로 컴파일 될 코드 #elseif os(macOS) WindowGroup { AlternativeContentView() } Settings { SettingsView() } #endif #if os(iOS) 와 #elseif os(macOS), #endif는 platform conditional compilation block으로 Swift 컴파일러에게 특정 타겟 플랫폼에서만 조건문 안쪽의 코드를 컴파일 하도록 함 커스텀 뷰처럼 커스텀 Scene도 만들 수 있음 struct CustomScene: Scene { var body: some Scene { WindowGroup { // Scene 내용 } } } 7/31 에러 내용: Photo library access not determined. This app has crashed because it attempted to access privacy-sensitive data without a usage description. The app's Info.plist must contain an NSPhotoLibraryUsageDescription key with a string value explaining to the user how the app uses this data. TARGETS - Info - Privacy - Photo Library Usage Description 키 값 추가 - value 추가하여 해결 에러 내용: 스마트 앨범의 카운트가 실제와 다르게 큰 수로 나타남 estimatedAssetCount를 사용할 경우, 정확한 결과를 가져오지 못할 수 있으므로 fetchAssets를 사용하여 정확한 asset의 수를 구하여 해결"
  },"/til/2023-04-29-VerticalTabView.html": {
    "title": "Vertical TabView in SwiftUI",
    "keywords": "TIL",
    "url": "/til/2023-04-29-VerticalTabView.html",
    "body": "import SwiftUI struct ContentView: View { var body: some View { GeometryReader { proxy in TabView { ForEach(0..&lt;3, id: \\.self) { i in Image(\"img_\\(i + 1)\") .resizable() .scaledToFill() .rotationEffect(.degrees(-90)) // 1 .frame( width: proxy.size.width, height: proxy.size.height ) // 2 } } .frame( width: proxy.size.height, // Height &amp; width swap height: proxy.size.width ) // 3 .rotationEffect(.degrees(90), anchor: .topLeading) // 4 .offset(x: proxy.size.width) // 5 .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never)) } } } 👉🏻 참고한 글 .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never)) SwiftUI의 PageTabViewStyle은 기본적으로 수평으로 넘길 수 있는 paged scrolling 탭뷰입니다. 페이지를 넘기는 것과 같은 효과를 줄 수 있는데요. 위 코드와 같이, rotationEffect와 GeometryReader를 사용하여 수직으로 넘어가는 탭뷰를 만들 수 있습니다. // 1 : rotationEffect를 사용하여 왼쪽으로 90도 이미지를 로테이션 시켜줍니다. 현재 탭뷰 안의 이미지는 아래와 같이 살짝 커졌지만 가운데 정렬된 상태로 나타납니다. // 2: 이때 width / height는 누워있는 이미지와 같이 width가 더 큰 직사각형 형태로 존재합니다. // 3: 여기서 TabView의 frame을 정의하는데, height와 width를 바꿔줍니다. 그러면 width가 heigt보다 작은 세로로 기다란 모양의 직사각형 frame이 되겠죠? // 4 : anchor는 어느 꼭지점을 기준으로 로테이트 할 지 정할 때 사용하는데 .topLeading을 기준으로 90도 로테이트 했으므로 화면에는 이미지가 보여지지 않게 됩니다. 로테이트 하면서 화면 밖에 위치하게 되는데요. // 5 : 그래서 offset에 x 값을 현재 width만큼 주어서 오른쪽으로 이동시킵니다. 여기까지하면, 화면에 수직으로 이동하는 페이징 탭뷰가 맨 위에 있는 영상처럼 잘 나타나게 됩니다. 그런데 LazyVStack 안에 다른 뷰와 함께 탭뷰를 화면에 보이려고 하면 문제가 생기는데요. LazyVStack은 모든 아이템을 먼저 그리는게 아니라 필요할 때 아이템을 렌더링 하기 떄문에 기존의. VStack과는 다른 레이아웃 룰을 가지고 있습니다. 그래서 높이가 10 정도 되는 뷰만 그려주게 됩니다. 일단 VStack으로 교체하면 이 문제는 해결할 수 있습니다."
  },"/til/2023-02-20-StanfordLecture.html": {
    "title": "Stanford CS 193P",
    "keywords": "TIL",
    "url": "/til/2023-02-20-StanfordLecture.html",
    "body": "Youtube 🔗 강의 내용 중 필요한 것 정리 Developing iOS 11 Apps with Swift 1. Introduction to iOS 11, Xcode 9 and Swift 4 📌 the underscore operator @IBAction func touchCard(_ sender: UIButton) { } 위 함수의 external name은 ‘_‘이고, internal name은 sender. external / internal names 둘 다 사용하는 것을 권장하는데, 아래의 touchCard 함수는 internal / external names 개념이 없는 Objective-C 부터 사용된 함수이기 때문에 때문에 external name으로 ‘_‘가 사용됨. 📌 버튼 스타일이 default 상태여야 currentTitle을 통해 버튼의 타이틀 값을 가져올 수 있음. import UIKit class ViewController: UIViewController { @IBAction func touchCard(_ sender: UIButton) { flipCard(withEmoji: \"👻\", on: sender) } func flipCard(withEmoji emoji: String, on button: UIButton) { // 카드 확인 -&gt; already ghost -&gt; flip it over // 카드 확인 -&gt; not ghost -&gt; 하얀 배경 / 이모지로 변경 (flip) // button style을 default로 변경해야 currentTitle을 통해 값을 받아올 수 있음 if let title = button.currentTitle { if title == emoji { button.setTitle(\"\", for: .normal) // 로 설정된 값은 currentTitle로 가져올 수 있음 button.backgroundColor = .orange } else { // title = \"\" 인지 확인되면 else if 로 변경 button.setTitle(emoji, for: .normal) button.backgroundColor = .white } } } } 📌 didSet 카드를 뒤집어서 같은 두 개의 그림을 찾아 짝을 맞추는 게임앱. 카드를 뒤집을 때마다 아래와 같이 flipCount라는 변수에 1을 더함. var flipCount = 0 flipCount += 1 flipCountLabel 이라는 UILabel 타입의 변수가 있음. flipCount의 값이 변할때마다 flipCountLabel의 값도 변경되어야 함. flipCountLabel.text = \"Flips: \\(flipCount)\" 위의 코드를 변경되어야 하는 부분마다 반복적으로 입력한다면 같은 내용의 코드를 반복해서 여러번 작성하게 됨. 좀 더 효과적으로 코드를 작성하기 위하여 didSet을 사용할 수 있음 var flipCount = 0 { didSet { flipCountLabel.text = \"Flip s: \\(flipCount)\" } } didSet은 property obeserver인데 flipCount라는 프로퍼티의 값을 관찰하고 있다가 그것이 변경될 때마다 disSet 안의 코드를 실행함. 📌 swift에서는 instance variables를 property라고 함 📌 코드를 작성 중 복사/붙여넣기를 하고 있다면 뭔가 잘못된 것! 2. MVC 🔗 Model 뷰(화면에 보여지는 부분)과 완전히 독립적인 객체의 모임 (뷰와 전혀 관계 없음) 앱이 어떤 일을 하는지와 관련된 로직을 담고 있음 지금 만들고 있는 앱에서는 카드 뒤집기 게임의 진행 방식을 Model이 가지고 있음 Controller Model이 ‘어떤 방식으로 사용자에게 보여질 것인지’에 대한 로직을 담음 (UI logic) View Controller의 미니언 Button, Text 등의 제네릭 뷰를 사용하여 Controller가 시키는 대로 화면을 그림 API 모델 class를 만들 때 public API에 대해 생각해보기. API는 클래스에 속한 메서드, instance variables의 리스트. public API는 다른 클래스들이 호출할 수 있도록 허용된 메서드, instance variables. 앱이 동작하는 방식에 있어 가장 기본적이고 중요한 정보가 무엇인지, 사람들이 이 앱을 어떻게 사용할지 알아야 클래스의 메서드와 instance variables를 작성할 수 있기 때문에 클래스를 작성하기 전에 API에 대해 생각해 보는 것을 추천. 📌 static… static var / static func 처럼 static 키워드를 사용하여 타입 레벨의 프로퍼티를 생성할 수 있음. 아래 Card 타입 스트럭쳐가 인스턴스화되지 않더라도 Card.getUniqueIdentifier() 처럼 함수를 사용할 수 있고, static이 붙은 변수는 static 함수 안에서 자유롭게 사용할 수 있음. struct Card { var isFaceUp = false var isMatched = false var identifier: Int static var identifierFactory = 0 static func getUniqueIdentifier() -&gt; Int { identifierFactory += 1 return identifierFactory } init() { self.identifier = Card.getUniqueIdentifier() } }"
  },"/til/2023-01-17-Quake.html": {
    "title": "앱 Earthquakes 튜토리얼을 따라가며 정리",
    "keywords": "TIL",
    "url": "/til/2023-01-17-Quake.html",
    "body": "Earthquakes app tutorial 이 글은 위의 apple developer tutorial을 따라가며 정리한 내용입니다. Error /decoding-structured-json/Decode earthquake data/step 8 Swift에서는 Error 프로토콜을 따르는 타입을 사용하여 에러를 나타냅니다. Error 프로토콜은 에러를 핸들링하기 위해 사용되는 타입이라는 것을 나타낼 뿐 아무런 내용이 없습니다. 요구사항도 없습니다. 그래서 커스텀 타입에 자유롭게 사용할 수 있습니다. enum QuakeError: Error { case missingData } extension QuakeError: LocalizedError { var errorDescription: String? { switch self { case .missingData: return NSLocalizedString(\"Found and will discard a quake missing a valid code, magnitude, place, or time.\", comment: \"\") } } } 위 QuakeError enumeration은 case missingData를 가지는데 LocalizedError 프로토콜을 따르는 extension을 작성하여, QuakeError.missingData로 에러가 던져질 경우 “code, maginitude, place, time 중 없는 데이터가 있어 정상적으로 코드가 작동하지 않았다.”는 메세지를 표출할 것입니다. // Quake struct라는 설계도를 사용하여 디코딩하는 인스턴스를 생성하기 위해 from decoder:_를 인자로 가지는 init 사용 // throws function, try, try?를 사용하여 디코딩 과정 중 에러 발생 시 nil을 반환하도록 처리함 init(from decoder: Decoder) throws { let values = try decoder.container(keyedBy: CodingKeys.self) let rawMagnitude = try? values.decode(Double.self, forKey: .magitude) let rawPlace = try? values.decode(String.self, forKey: .place) let rawTime = try? values.decode(Date.self, forKey: .time) let rawCode = try? values.decode(String.self, forKey: .code) let rawDetail = try? values.decode(URL.self, forKey: .detail) // try? 가 사용된 곳에서 에러가 발생하지 않으면 옵셔널 값이 반환되므로 해당 값을 unwrapping 함 guard let magnitude = rawMagnitude, let place = rawPlace, let time = rawTime, let code = rawCode, let detail = rawDetail else { throw QuakeError.missingData } 위 예시의 가장 아래쪽에 있는 else 구문에서 throw 키워드를 사용하여 에러를 던졌습니다. magnitude, place, time, code, detail 중 데이터가 없는 것이 있을 때 QuakeError.missingData 에러가 던져집니다. Experiment /decoding-structured-json/Decoding structured JSON/test the decoder 쓰나미 경보를 푸시 알림으로 보내려 하는 상황 튜토리얼 내용을 참고하여 쓰나미 관련 데이터를 디코딩해보기 USGS 사이트에서 쓰나미의 데이터 타입을 찾음 -&gt; Integer Quake 스트럭처에 tsunami 프로퍼티 추가 struct Quake: Identifiable { let magnitude: Double let place: String let time: Date let code: String let detail: URL let tsunami: Int } 키 값으로 사용되는 CodingKeys enum에 tsunami일 경우를 추가 private enum CodingKeys: String, CodingKey { case magnitude = \"mag\" case place case time case code case detail case tsunami } 생성자에 필요한 코드 추가 init(from decoder: Decoder) throws { let values = try decoder.container(keyedBy: CodingKeys.self) let rawMagnitude = try? values.decode(Double.self, forKey: .magitude) let rawPlace = try? values.decode(String.self, forKey: .place) let rawTime = try? values.decode(Date.self, forKey: .time) let rawCode = try? values.decode(String.self, forKey: .code) let rawDetail = try? values.decode(URL.self, forKey: .detail) let rawTsunami = try? values.decode(Int.self, forKey: .tsunami) // try? 가 사용된 곳에서 에러가 발생하지 않으면 옵셔널 값이 반환되므로 해당 값을 unwrapping 함 guard let magnitude = rawMagnitude, let place = rawPlace, let time = rawTime, let code = rawCode, let detail = rawDetail, let tsunami = rawTsunami else { throw QuakeError.missingData } self.magnitude = magnitude self.place = place self.time = time self.code = code self.detail = detail self.tsunami = tsunami } 현재 테스트 데이터의 값인 0과 같은지 테스트를 통해 확인 import XCTest @testable import FollwingEarthquake class FollwingEarthquakeTests: XCTestCase { func testGeoJSONDecoderDecodesQuake() throws { let decoder = JSONDecoder() decoder.dateDecodingStrategy = .millisecondsSince1970 let quake = try decoder.decode(Quake.self, from: testFeature_nc73649170) XCTAssertEqual(quake.code, \"73649170\") let expectedSeconds = TimeInterval(1636129710550) / 1000 let decodedSeconds = quake.time.timeIntervalSince1970 XCTAssertEqual(expectedSeconds, decodedSeconds, accuracy: 0.00001) XCTAssertEqual(quake.tsunami, 0) // 테스트 통과 } } private(set) struct GeoJSON { private(set) var quakes:[Quake] = [] } private(set) modifier가 사용된 배열 quakes는 GeoJSON 스트럭쳐 안에있는 코드에서만 수정 가능합니다. GeoJSON 스트럭처 바깥에서 작성된 코드에서는 quakes의 값을 읽는 것만 가능합니다. structuredJSON USGS의 지진 정보는 structuredJSON 형태로 제공됩니다. 필요한 정보인 latitude / longitude를 얻기 위해 각 structure를 정의합니다. Products 타입을 사용하여 RootProperties 타입 안에 products를 정의하고 Origin 타입을 사용하여 Products 타입 안에 origin 을 정의하는 것과 같은 방법으로 이미지 속 GeoJSON 계층을 모델링합니다. var latitude: Double { properties.products.origin.first!.properties.latitude } var longitude: Double { properties.products.origin.first!.properties.longitude } 모델링한 스트럭처를 이용하여 위와 같이 latitude, longitude 정보를 계산합니다. 루트 프로퍼티로부터 한 계층씩 내려가며 최종적으로 latitude와 longitude를 계산하는 방식이 인상깊었습니다. CodingKey enum private enum CodingKeys: String, CodingKey { case magnitude = \"mag\" case place case time case code case detail case tsunami } 위 예시의 nested coding keys enumeration은 case magnitude = “mag” 값을 가지고 있습니다. place, time, code, detail, tsunami는 GeoJSON 객체에서 같은 이름을 키값으로 사용하고 있고, magnitude는 GeoJSON 객체에서 “mag”를 키값으로 가집니다. init(from decoder: Decoder) throws { let values = try decoder.container(keyedBy: CodingKeys.self) let rawMagnitude = try? values.decode(Double.self, forKey: .magnitude) let rawPlace = try? values.decode(String.self, forKey: .place) let rawTime = try? values.decode(Date.self, forKey: .time) let rawCode = try? values.decode(String.self, forKey: .code) let rawDetail = try? values.decode(URL.self, forKey: .detail) let rawTsunami = try? values.decode(Int.self, forKey: .tsunami) ... } 디코딩하는 생성자 함수에서 magnitude를 키값으로 사용한 것을 확인할 수 있습니다. CodingKeys enum의 케이스 이름은 Quake struct의 프로퍼티를 나타냅니다. JSON 객체의 키 값과 이름이 같은 경우는 case 이름만 작성 / 다른 경우는 case magnitude = “mag”와 같이 작성합니다. Existential Types Building a network test client Earthquakes 앱은 network client를 사용하여 원격 서버에서 JSON 데이터를 가져옵니다. network client의 동작을 테스트하기 위해, 제네릭 / existential 타입을 사용하여 network client를 재사용 가능하도록 만들 것입니다. Existentnial type은 any 키워드를 앞에 붙여 사용할 수 있음 lazy는 let과 함께 사용할 수 없음. var와 함께 사용. 제네릭 / existential 타입 비교하기 import Foundation protocol Pollinator { // 꽃가루를 옮기는 기능을 하는 프로토콜 // 이 프로토콜을 따르는 struct는 꽃가루를 '파라미터'식물로부터 옮기는 동작을 수행함. func pollinate(_ plant: String) } struct Hummingbird: Pollinator { // Hummingbird 스트럭처는 Pollinator 프로토콜을 따르므로 아래 함수를 실행해야 함. func pollinate(_ plant: String) { print(\"허밍버드가 부리로 \\(plant)로부터 꽃가루를 옮김.\") } } struct Insect: Pollinator { // Insect 스트럭처도 마찬가지로 Pollinator 프로토콜을 따르므로 아래 함수를 실행해야 함. func pollinate(_ plant: String) { print(\"곤충이 다리에 꽃가루를 묻혀 \\(plant)로부터 꽃가루를 옮김.\") } } // Hummingbird와 Inset는 Pollinator 프로토콜을 따르므로 '꽃가루를 옮기는 기능'을 수행하는 스트럭처라는 것을 알 수 있음. let speedy = Hummingbird() let busyBee = Insect() // 각 스트럭처를 인스턴스화하여 실제로 pollinate 함수를 동작시킴. speedy.pollinate(\"해바라기\") busyBee.pollinate(\"프리지아\") // 꽃가루를 옮기는 기능을 하는 함수를 작성하려고 하는데... // 옮기는 주체가 Pollinator 타입을 따르는 것은 무엇이든 될 수 있는 함수를 작성하려고 함. func pollinate&lt;T: Pollinator&gt;(_ plants: [String], with pollinator: T) { // &lt;T: Pollinator&gt; 을 작성하여 Pollinator 프로토콜을 따르는 T라는 타입을 함수에서 사용할 것이라는 것을 알려줌. for plant in plants { // 매개변수로 받은 pollinator는 Pollinator 프로토콜을 따르므로 pollinate 함수를 실행함. // pollinator의 타입은 T, T는 Pollinator라는 프로토콜을 따르는 모든 타입. 여기서는 Hummingbird와 Insect 타입의 객체가 pollinator로 사용될 수 있음. pollinator.pollinate(plant) } } pollinate([\"백합\", \"수국\"], with: speedy) // 실행 결과: 허밍버드가 부리로 백합로부터 꽃가루를 옮김. / 허밍버드가 부리로 수국로부터 꽃가루를 옮김. pollinate([\"들꽃\"], with: busyBee) // 실행 결과 : 곤충이 다리에 꽃가루를 묻혀 들꽃로부터 꽃가루를 옮김. // * 하나의 함수에서 다른 타입의 객체를 매개변수로 사용할 수 있게 됨. // any Pollinator 타입을 따르는 변수를 정의 -&gt; any 키워드는 any Pollinator가 existential 타입이라는 것을 의미한다. var anotherPollinator: any Pollinator = Hummingbird() anotherPollinator.pollinate(\"튤립\") // anotherPollinator는 변수이므로 Pollinator 프로토콜을 따르는 타입의 인스턴스를 할당 받을 수 있음. anotherPollinator = Insect() anotherPollinator.pollinate(\"옥수수\") // 아래 함수는 existential 타입의 매개변수를 사용하여 작성됨 func pollinate2(_ plants: [String], with pollinator: any Pollinator) { for plant in plants { pollinator.pollinate(plant) } } Swift는 제네릭 함수를 호출 할 때는 static dispatch를 사용하여 함수 호출을 최적화 하지만, existential 타입을 포함한 함수를 호출할 경우 dynamic dispatch를 사용함. 이때 더 많은 메모리를 필요로 하기 때문에 제네릭 매개변수를 사용한 함수 호출보다 조금 덜 효율적이게 됨. import Foundation class QuakeClient { private let feedURL = URL(string: \"https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_day.geojson\")! //computed porperty의 타입이 있고 milliseconds로 변경하기 위해 이렇게 사용한건가? //date decoding strategy를 변경하기 위해서 anonymous 클로저를 사용해서 init 함 private lazy var decoder: JSONDecoder = { let aDecoder = JSONDecoder() aDecoder.dateDecodingStrategy = .millisecondsSince1970 return aDecoder }() //feedURL은 리터럴 스트링 값을 가지고 있고, decoder는 클로저를 사용하여 이니셜라이징함 //downloader 이니셜라이징하여 값 설정 //Existential value가 사용되는 부분 private let downloader: any HTTPDataDownloader //이니셜라이징 중 파라미터로 통과된 downloader(HTTPDataDownloader 프로토콜을 따르는 any type)가 //QuakeClient의 downloader로 사용됨 init(downloader: any HTTPDataDownloader) { self.downloader = downloader } } quakes 배열을 비동기식으로 가져오고, 가져오는 과정에서 에러가 있을 수 있기 때문에 async, throws 키워드를 사용. property에 async와 throws를 사용하려면 get syntax를 사용해야 함 var quakes: [Quake] { get async throws{ //data를 서버로부터 다운로드 let data = try await downloader.httpData(from: feedURL) //다운로드한 데이터를 디코딩 let allQuakes = try decoder.decode(GeoJSON.self, from: data) //GeoJSON 스트럭처 안에 지진 정보를 배열 형태로 담는 quakes return allQuakes.quakes } } URL 사용하여 데이터 가져오기 URLSession의 인스턴스 메서드인 data를 사용하여 데이터를 가져오려고 함 커스텀 프로토콜인 HTTPDataDownloader를 생성 protocol HTTPDataDownloader { func httpData(from: URL) async throws -&gt; Data } URLSession에 extension을 작성하여 위 커스텀 프로토콜을 따르도록 함 httpData(from:_) 함수의 바디 부분에 URLSession의 인스턴스 메서드인 data를 사용하여 네트워크 연결을 통해 데이터를 가져옴 Preview Content 폴더로 test data 파일을 옮기면 SwiftUI 프리뷰와 유닛 테스트 둘 다에서 데이터를 사용할 수 있음 Add the map view MapKit 프레임워크를 사용하여 지진이 발생한 곳을 지도로 보여주려고 함. import MapKit // 1 struct QuakeDetailMap: View { @State private var region = MKCoordinateRegion() // 2 var body: some View { Map(coordinateRegion: $region) // 3 .onAppear { // 4 withAnimation { region.center = CLLocationCoordinate2D(latitude: -30.0, longitude: 130.0) region.span = MKCoordinateSpan(latitudeDelta: 50, longitudeDelta: 70) } } } } 맵킷 프레임워크 추가 맵이 보여줄 지역을 담은 state property 바디 프로퍼티 부분에 맵뷰를 추가하여 뷰에 지도 뿌리기 onAppear{} 사용하여 맵뷰가 열릴 때 특정 지역이 보이도록 함. 프리뷰에서 핀치 제스처 하는 방법 - 마우스 클릭하고 옵션 키 누르기 디테일에 추가할 맵뷰를 파일로 따로 생성한 경우, 디테일 뷰의 프리뷰에서 맵뷰를 확인할 수 있게 되면 프리뷰 자체를 삭제해도 됨. (그동안은 프리뷰 부분을 유지해야겠다고만 생각해서 추가 작업이 필요했음) region.center = CLLocationCoordinate2D(latitude: 35.0, longitude: 127.0) 값을 수정하여 한국이 나타나도록 해봄 Managing structured concurrency Fetching multiple URLs → 현재 Earthquakes 앱의 클라이언트는 지진의 정보 목록을 가져오기 위해서 하나의 요청을 보내고 있음. 이제 클라이언트가 concurrency 기능을 사용하여 여러개의 요청을 동시에 보내도록 수정하려고 함. 비동기 함수와 비동기 속성을 사용해서 네트워크 요청에 대한 값을 가져오는 작업이 실행되는 동안 잠깐 해당 부분에 실행을 멈춤. 그동안 다른 작업이 먼저 진행됨. let quakes: [Quake] = try await quakeClient.quakes 위 코드에서는 비동기 프로퍼티가 지진의 목록을 가져옴. (비동기 속서이기 때문에, 정보를 가져올때까지 기다림.) func quakeLocation(from url: URL) -&gt; QuakeLocation 위 코드에서는 각 지진의 디테일 정보 중 위치 정보를 가져옴. 이 두 개의 네트워크 요청을 동시에 보내려고 함. let quakes: [Quake] = try await quakeClient.quakes var locations: [QuakeLocation] = [] for quake in quakes { let location = await quakeClient.quakeLocation(from: quake.url) location.append(location) } 위 코드를 보면, 가져온 지진 정보 마다 가지고 있는 위치 정보 url을 사용하여 위치 정보를 얻어오고, 그 정보를 locations 배열에 추가함. for loop 안에 작성된 quakeClient.quakeLocation(from: quake.url) 함수는 각 반복마다 quakeLocation() 함수가 결과 값을 가져올동안 중단되고, 다시 실행되면 다음 suspension point(quakeLocation()이 다시 실행되는 곳)까지 실행됨. 비동기 함수이지만 순차적으로 진행되게 됨. 이것을 동시에 실행되도록 해야 함. Task Group 이때 사용할 수 있는 것이 테스크 그룸. 테스크 그룹을 사용하면 많은 테스크를 동시에 실행할 수 있음. 시스템은 병렬 쓰레드를 사용하여 테스크를 동시에 실행함. -withTaskGroup() -withThrowingTaskGroup() 위 두가지 함수를 사용하여 테스크 그룹을 사용할 수 있는데, 여기서는 throwing 함수를 사용하기 때문에 withThrowingTaskGroupo()을 사용함."
  },"/til/2022-08-14-myBoxes.html": {
    "title": "My Box",
    "keywords": "TIL",
    "url": "/til/2022-08-14-myBoxes.html",
    "body": "My Box - SwiftUI 프로젝트 ~9/15 📌 진행사항 보관함 목록 아이템 목록 보관함 편집 화면 ~9/19 📋 메모 Edit 뷰를 만들기 전에 타입 Box 안에 nested 형태로 Data라는 타입을 생성했다. 타입 Data는 왜 필요했을까? Data에는 Box의 속성 중, 편집 가능하도록 할 속성을 담는다. 사용자가 편집한 내용을 Data의 각 속성에 담는다. 변경사항이 저장되는게 확실해지면 (‘확인’ 또는 ‘Done’ 버튼을 눌렀을 때…) Data에 담긴 내용을 Box에 업데이트한다. ~9/25 📌 진행사항 Done 버튼을 누르면 편집 화면 사라짐 Box.Data() 인스턴스에 저장된 데이터를 Box 인스턴스에 업데이트하는 함수 실행 ToolbarItem(placement: .confirmationAction) { Button(\"Done\") { isPresentingEditView = false box.update(from: data) } } ~10/2 📌 진행사항 State 와 binding을 사용하여 데이터가 뷰 사이에서 전달되도록 했지만, 앱을 종료했다 다시 시작하면 모든 데이터가 날라간다. 데이터를 저장하고 가져오는 메서드를 작성해야 한다. 데이터를 file/Document에 저장하고 가져오는 함수를 따로 작성하고 앱이 열릴 때 데이터를 가져오는 함수 적용 중 @Environment 속성에 scenePhase 값을 설정하여 앱이 inactive한 상태로 바뀔 때 사용자가 입력한 데이터를 저장하도록 함. 이제 앱을 종료하고 다시 열어도 그대로 데이터가 저장되어 있는 상태가 되었다. 보관함 리스트를 삭제하는 기능 추가 완료 보관함에 pin 심볼을 다른 것으로 변경하기 기존에 임의로 설정해두었던 배경/글자색을 주석처리하여 기본색으로 설정 태그 심볼 제거 ~10/6 📌 진행사항 데이터가 잘 입력되는지 테스트 해봤는데 생각 못한 문제가 있었다. 한번에 많은 데이터를 입력면 목록이 키보드 뒤로 숨는다.. 흠.. 위 목록을 스크롤로 올릴 수 있어서 사용에는 문제가 없지만 좀 더 나은 사용자 경험을 위해서 후에 수정할 목록에 추가! 기능을 좀 더 추가해야 할 것 같아서 목록에 별모양을 추가하는 중.. ‘좋아요’ 버튼 같은 느낌으로! ~10/8 📌 진행사항 튜토리얼을 보고 리스트를 필터링하는 computed property를 바디 바깥 부분에 작성했는데 그럼 바인딩을 사용할 수 없어서 바디 안쪽으로 재작성했다. ‘좋아요’(?) / Favorite 을 표시할 수 있는 기능을 추가해보고 있다. Favorite인지 아닌지 정보를 담을 Bool 타입 속성을 모델 스트럭처에 추가하고 그 속성의 값이 true일 때만 노란색 별이 나타나도록 해주었다. 샘플 데이터 값에 true/false를 입력하여 별이 잘 나타는지 확인했다. 토글을 만들어 On 상태일 때는 favorite 표시가 된 것만 나타나도록 했다. ~10/17 📌 진행사항 등록한 모든 아이템을 검색하는 기능을 구현하려고 찾아보니 크게 UIKit 을 사용하는 방법과 SwifUI를 사용하는 방법 두 가지가 있었다. 먼저 SwiftUI의 searchable modifier 사용해보기로 했다. 검색 바를 구현하는건 코드 세 줄만 추가하면 되어서 금방했는데 그 후에 과정에서 시간이 좀 들고 있다. (Overlay를 사용해서 검색된 값들과 검색창만 화면에 보여주려고 하는데 Overlay를 어디다가 붙여야 할 지 모르겠음.) 내일까지 구현해보고 안되면 UIKit으로 해봐야겠다. ~10/18 📌 진행사항 어제 searchable 을 사용하여 검색 텍스트 필드 UI를 생성했다. 사용자가 입력을 시작하면 현재 박스 목록 화면을 완전히 가리는 새로운 뷰가 나타나고, 그 뷰에 검색어가 들어간 아이템들이 쭉 나왔으면 좋겠다. 일단 영상에서 보이듯이 검색어를 입력했을 때 현재 목록위로 overlay가 된 투명한(?) 뷰에 입력한 값이 전달되는 것까지 구현하였다. 이제 그 화면에 검색어로 필터링된 아이템 리스트를 뽑아내면 될 것 같다. ~10/19 📌 진행사항 전체 앱을 통하는 데이터 흐름을 변경했다. 전체 아이템 목록의 이름(itemName)을 기준으로 키워드와 일치하는 아이템 목록을 만들어서 뿌러주려고 했는데.. 오늘은 실패! 오류는 어떻게든 해결을 해봤는데 키워드를 입력하자 흰 화면이 나타난다. 내일 다시 도전해보겠어….! var filteredList: [Box.Item] { if !searchText.isEmpty{ return items } else { return items.filter { $0.itemName.localizedCaseInsensitiveContains(searchText) } } } ~10/20 📌 진행사항 localizedCaseInsensitiveContains(_:) 메서드를 사용해서 대소문자에 상관없이 검색 키워드를 포함한 아이템들의 목록을 만드려고 했는데 처음에 자꾸 오류가 났다. 알고보니 searchText 자리에 값이 nil이면 안되는데 if !searchText.isEmpty처리를 해주지 않았던게 원인이었다. 비어있을 때는 키워드로 필터링되지 않은 전체 아이템이 나타나도록 if문을 작성해 주었다. 이제 검색어를 입력하면 리스트 화면이 나타나긴하지만 키워드와는 관계없이 첫번째 박스에 담긴 아이템이 나타나고, search bar도 사라진다. 해결하자! ~10/21 📌 진행사항 전체 아이템을 가진 리스트를 search bar에 입력된 키워드를 가진 아이템들을 가진 리스트로 필터링 하려고 했는데, 전체 아이템을 잘못 작성한 것 같다. 전체 아이템을 가진 리스트를 먼저 정상적으로 뽑아보기 Type ‘() -&gt; ()’ cannot conform to ‘ShapeStyle… ~10/22 📌 진행사항 위와 같은 에러가 발생해서 해결해 보는 중.. 해결! 검색 기능을 구현하면서 searchbar에 텍스트가 입력되고 검색 중일 때 overlay 를 사용해서 해당 텍스트를 포함한 아이템 리스트가 전체 화면을 가리도록 구현했다. 이 과정에서 사용된 .overlay modifier가 문제였다. .overlay { } / .overlay( ) 이렇게 두 개의 형태로 사용되는데 { }를 가진 overlay의 경우 해당 컨텐츠가 ShapeStyle 프로토콜을 따라야해서 발생한 오류였다. ()를 가진 overlay의 경우 어떤 프로토콜도 따르고 있지 않아서 { }를 ( )로 변경해주었더니 에러가 사라졌다. ~10/23 📌 진행사항 드디어 됐다! 각 박스들의 목록이 있는 메인 화면에서 검색어를 입력하면 그 검색어를 포함한 아이템들만 화면에 보여주는 것 성공! 일주일동안 성공하지 못했던 요인 스스로 생각하며 분석해보는 시간이 부족했다. searchable 을 사용하여 검색 기능을 구현하는 방법을 엄청 검색했다. 지금 돌이켜 생각해보면 정말 ‘검색만’ 했다. 여러가지 인스턴스 메서드를 사용해보고 사람들이 사용한 여러가지 방법을 적용해봤는데, 안되는 이유는 아이템 전체 목록을 잘못 설정한 것이었다. 아이템의 전체 목록 부터 잘못 불러오고 있었으니 아무리 필터링을 하려고 해도 필터링이 제대로 되지 않았던 것이다. 전체 아이템 리스트를 불러올 방식은 아주 간단한데 그것부터 제대로 하지 않아 며칠을 다른곳에서 이유를 찾으며 시간을 보냈다. 검색 기능 구현이 안되는 이유들을 찾으며 소스를 다시 보니 모호하게 아는 부분이 많다는 것을 꺠달았다. ~10/25 📌 진행사항 검색된 아이템을 누르면 아이템 하나의 디테일 뷰로 이동하는 것을 구현해보려고 하는데 item 모델에 id와 itemName 속성 딱 두가지만 정의를 해두어서 디테일 뷰에 여러가지 속성들을 나타내려면 모델에 속성을 추가해야 할 것 같다. ~10/28 📌 진행사항 Navigation Link를 사용하여 아이템을 눌렀을 때 다른 View로 이동하도록 해보고 있다. 일단 해당 아이템이 속하는 박스 뷰로 이동하도록 수정해 보았다. 각 아이템의 개인 속성은 필요할 것 같으면서도 복잡해지는 것 아닐까 하는 생각이 든다. 아이템 이름이 아닌 따로 저장한 키워드를 이용한 검색 기능은 넣어으면 좋겠어서 그 부분에 대해 생각해 봐야겠다. ~10/31 📌 진행사항 10월의 마지막 날! 박스 뷰에서 별 모양을 누르면 메인 리스트에서 노란색 별이 표출되고 이 별 표시가 있는 목록만 볼 수 있는 토글 버튼이 있는데 “Favorites Only”라는 글씨 대신 별을 추가해주고 버튼 가까이로 위치를 이동시켰다. 박스의 별은 왼쪽 정렬해주어 표시가 되지 않은 상자들과 좀 더 눈에 띄게 달라보이도록 하였다. 12/01 📌 진행사항 12월이 시작되었고 여전히 회사는 바쁘고 개인적으로도 할 일이 많지만, 이 프로젝트를 꼭 앱 스토어에 올리겠다는 마음으로 다시 시작! 먼저 각 아이템의 상세 정보를 담는 뷰를 연결해 봐야겠다. 1번 보관함을 생성한 뒤 다시 새 보관함을 생성할 때, 1번 보관함에 정보가 텍스트 필드에 그대로 나타나서 수정 완료 처음 보관함 등록할 때 별 표시 되어서 저장되는 것 수정 완료 -&gt; 추가하는 뷰에서 일시적으로 데이터를 저장하는 Data()에 별 표시(좋아요 표시) 속성인 isFavorite의 기본값이 true로 되어있던 것을 false로 변경해줌. ~12/11 📌 진행사항 리스트 안에서 아이템의 위치를 변경할 수 있도록 수정 .onMove modifier를 사용해서 간단하게 아이템을 이동시키는 기능을 구현할 수 있었다. .onMove는 ForEach로 생성되는 리스트처럼 ‘동적 리스트’에만 사용할 수 있다. List로 만들어진 리스트는 정적 리스트이기 때문에 사용할 수 없다. 나는 ForEach를 통해 리스트를 만들고 있기 때문에 사용할 수 있었다. .onMove는 두 개의 패러미터를 가진다. indexSet과 Int형의 패러미터(위 이미지에서는 index)이다. .onMove { (IndexSet, index) in box.items.move(fromOffsets: IndexSet, toOffset: index) } .environment(\\.editMode, Binding.constant(EditMode.active)) 기본적으로 .onMove modifier는 edit 버튼을 생성하고 이 edit 버튼을 눌러야 리스트를 옮길 수 있도록 하는 기능이 활성화되는데 나는 이미 Edit 버튼을 사용하여 모달뷰를 띄우고 있기 때문에 리스트에서 이 기능을 확인할 수 없었다. edit 버튼을 누르면 editing 중인 상태로 전환되고, 이 상태에서 아이템의 순서를 변경하는 기능이 활성화되므로 항상 editing 중인 상태로 변경하여 해결하였다. 수정 필요 키보드에 가려져 작성중인 아이템이 보이지 않는 부분"
  }}
