{"/til/2024-10-17-UnitTest.html": {
    "title": "단위 테스트 작성하기",
    "keywords": "TIL",
    "url": "/til/2024-10-17-UnitTest.html",
    "body": "override func setUpWithError() throws { //... } 각 메서드가 실행되기 전에 호출되는 함수 테스트에 필요한 객체를 초기화 override func tearDownWithError() throws { // Put teardown code here. This method is called after the invocation of each test method in the class. } 각 테스트 메서드가 실행 완료한 뒤 호출되는 함수 테스트에서 사용한 객체를 정리함 Teardown code Teardown code는 테스트에서 사용한 객체를 해제하는 코드를 의미함."
  },"/til/2024-10-03-login.html": {
    "title": "로그인 기능 구현하기",
    "keywords": "TIL",
    "url": "/til/2024-10-03-login.html",
    "body": "구글 로그인 환경설정 🔗 Get started with Google Sign-In for iOS and macOS CocoaPods나 SPM으로 Google Sign-In을 프로젝트에 추가합니다. OAuth client ID를 생성합니다. OAuth server client ID를 생성합니다. 대부분의 앱들은 로그인한 유저의 정보를 백엔드 서버로 보내야 합니다. 유저의 정보를 안전하게 백엔드 서버로 보내기 위해 ID token을 사용합니다. 유저의 ID token을 받기 위해서는 서버 클라이언트 ID인 두번째 클라이언트 ID가 필요합니다. 서버 클라이언트 ID를 얻기 위해 웹 어플리케이션 타입의 OAuth client ID를 생성합니다. ⬆️ 윗 부분까지는 진행 완료. (서버 클라이언트 ID는 백엔드 개발자님께서 생성해주심) Xcode 프로젝트 설정하기 // OAuth client ID &lt;key&gt;GIDClientID&lt;/key&gt; &lt;string&gt;YOUR_IOS_CLIENT_ID&lt;/string&gt; // OAuth server client ID &lt;key&gt;GIDServerClientID&lt;/key&gt; &lt;string&gt;YOUR_SERVER_CLIENT_ID&lt;/string&gt; // Custom URL Scheme &lt;key&gt;CFBundleURLTypes&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;CFBundleURLSchemes&lt;/key&gt; &lt;array&gt; &lt;string&gt;YOUR_DOT_REVERSED_IOS_CLIENT_ID&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/array&gt; 위와 같이 OAuth client ID / OAuth server client ID / Custom URL Scheme을 설정합니다. (보안을 위해 Config 파일에 값을 저장하였습니다.) 구현 🔗 Integrating Google Sign-In into your iOS or macOS app 🔗 Try iOS Sample App 1. Handle the authentication redirect URL AppDelegate에 아래 메서드를 추가하고, GIDSignIn의 handle url 메서드를 호출하는 코드를 추가합니다. func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -&gt; Bool { var handled: Bool handled = GIDSignIn.sharedInstance.handle(url) if handled { return true } // Handle other custom URL types. // If not handled by this app, return false. return false } 2. Attempt to restore the user’s sign-in state 앱이 시작될 때, restorePreviousSignInWithCallback를 호출하여 이미 구글로 로그인을 했던 사용자의 sign-in 상태를 복구합니다. 로그인 상태가 복구되기 때문에 사용자가 앱을 사용할때마다 다시 로그인하지 않아도 됩니다. (사용자가 로그아웃하지 않았다면) application(application:didFinishLaunchingWithOptions:)에서 restorePreviousSignIn의 결과값을 사용하여, 처음 앱이 열렸을 때 어떤 뷰를 보여줄지 결정할 수 있습니다. func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { // Override point for customization after application launch. GIDSignIn.sharedInstance.restorePreviousSignIn { user, error in if error != nil || user == nil { // Show the app's signed-out state. } else { // Show the app's signed-in state. } } return true }"
  },"/ti/2024-09-27-responsiveMediaApp.html": {
    "title": "Create a more responsive media app (WWDC)",
    "keywords": "TI",
    "url": "/ti/2024-09-27-responsiveMediaApp.html",
    "body": "Create a more responsive media app (WWDC) AVFoundation을 사용하여 더 반응이 빠른 미디어 앱 만들기 썸네일을 보여주거나, 어러개의 미디어를 하나의 컴포지션으로 합치거나, 에셋의 정보를 얻는 등의 작업은 데이터를 로딩하는 작업이 필요합니다. 비디오처럼 큰 파일은 데이터를 로딩하는 작업에 긴 시간이 걸릴 수 있습니다. 이런 작업을 메인 스레드에서 동기적으로 실행하게 되면 레이턴시 이슈가 발생할 수 있습니다. AVFoundation의 도구들을 사용하여 데이터를 비동기적으로 로드한 뒤, 데이터 로딩 작업이 끝난 후 UI를 업데이트 하여, 앱이 위와 같은 문제없이 responsive하게 동작할 수 있습니다. Generating thumbnails AVAssetImageGenerator로부터 이미지를 얻는 것은 썸네일을 만드는 좋은 방법입니다. 하지만 이미지를 생성하는 것은 실행 즉시 이루어지지 않습니다. 이미지를 생성하기 위해서, image generator는 비디오 파일의 프레임 데이터를 먼저 로드해야 합니다. 원격 서버나 인터넷에서 비디오 파일을 가져온다면 프레임 데이터를 로딩하는 작업이 훨씬 느리게 진행되기 때문에 이미지를 생성하는 방법을 신중히 선택해야 합니다. 아래 코드에서 사용된 copyCGimage는 데이터를 메인스레드에서 동기적으로 로드합니다. 비디오가 로딩되길 기다리는 동안 UI는 멈춰버립니다. func thumbnail() throws -&gt; UIImage { let generator = AVAssetImageGenerator(asset: asset) let thumbnail = try generator.copyCGImage(at: time, actualTime: nil) return UIImage(cgImage: thumbnail) } image(at: time) image(at: time) 메서드를 사용하여 이미지 제너레이터가 데이터를 로딩하는 동안 호출된 스레드를 해제시켜 위와 같은 문제를 해결할 수 있습니다. func thumbnail(asset: AVAsset) async throws -&gt; UIImage { let generator = AVAssetImageGenerator(asset: asset) let thumbnail = try await generator.image(at: CMTime.zero).image // time 설정 필요 return UIImage(cgImage: thumbnail) } 위 코드에서 이미지 제너레이터는 튜플 (image: CGImage, actualTime: CMTime)을 리턴합니다. actual time은 에셋에서 해당 이미지의 actual time입니다. actual time은 몇가지 이유로 요청한 타임과 같지 않을 수 있습니다. 위 코드와 같이 .image를 사용하여 이미지에만 접근할 수도 있습니다. 압축된 비디오의 프레임 중 IFrame은 다른 프레임들보다 로드하기 쉽습니다. 다른 프레임과 상관없이 독립적으로 디코딩되기 때문입니다. 다른 프레임들은 가까이 있는 프레임에 의존하여 디코딩됩니다. 그렇기 때문에 이미지 제너레이터는 기본적으로 요청한 시간과 가장 가까운 iFrame을 사용하여 이미지를 생성합니다. 아래와 같이 tolerance를 zero로 설정하여 요청한 정확한 시간의 썸네일을 얻을 수 있지만, 요청한 시간의 프레임이 iFrame이 아닐 경우 해당 프레임을 디코딩하기 위해 근처에 있는 프레임들까지 로딩해야할 수 있습니다. func thumbnail(asset: AVAsset) async throws -&gt; UIImage { let generator = AVAssetImageGenerator(asset: asset) generator.requestedTimeToleranceBefore = .zero generator.requestedTimeToleranceAfter = .zero let thumbnail = try await generator.image(at: CMTime.zero).image // time 설정 필요 return UIImage(cgImage: thumbnail) } 아래와 같이 더 넓은 tolerance를 줄 수 있습니다. 제너레이터가 더 많은 프레임 선택지를 갖게 함으로써 데이터 로딩을 줄일 수 있게 됩니다. 프레임을 더 적게 로드할 수록 더 빠르게 이미지를 리턴할 수 있게 됩니다. func thumbnail(asset: AVAsset) async throws -&gt; UIImage { let generator = AVAssetImageGenerator(asset: asset) generator.requestedTimeToleranceBefore = .zero generator.requestedTimeToleranceAfter = CMTime(seconds: 3, preferredTimescale: 600) let thumbnail = try await generator.image(at: CMTime.zero).image // time 설정 필요 return UIImage(cgImage: thumbnail) } Generate a series of thumbnails 여러개의 time으로 부터 섬네일들을 가져오기 위해서는, images(for: times)를 사용합니다. images(for: times)는 Async Sequence를 사용하여 결과값을 제공합니다. 시퀀스를 사용하면 for in loop를 사용하여 items를 iterate할 수 있습니다. 아래의 코드처럼 items(generator.images(for: times))가 한번에 가져올 수 없는 값이라면, async 시퀀스를 사용하여 각각의 iteration마다 다음 요소를 기다리도록 할 수 있습니다. func timelineThumbnails(for times: [CMTime], asset: AVAsset) async { let generator = AVAssetImageGenerator(asset: asset) for await result in generator.images(for: times) { // ... } }"
  },"/til/2024-09-22-lottoMate-refactoringLog.html": {
    "title": "프로젝트 ‘로또메이트’ - 리팩토링 기록",
    "keywords": "TIL",
    "url": "/til/2024-09-22-lottoMate-refactoringLog.html",
    "body": "Template 이슈 정리 템플리 프로젝트 진행 중 리팩토링한 내용을 아래 템플릿에 따라 정리합니다. 1. 리팩토링 이유 (Reason for Refactoring) 배경 설명: 코드 리팩토링이 필요했던 배경을 설명합니다. 새로운 기술을 학습하거나 프로젝트 요구 사항이 변경되어 리팩토링이 필요하게 된 이유를 적습니다. 2. 기존 코드 문제점 (Issues in Existing Code) 기존 코드의 문제점: 리팩토링 이전에 코드에서 발생한 문제들을 나열합니다. 성능 문제, 가독성, 중복 코드 등 개선해야 할 부분을 구체적으로 설명합니다. 3. 리팩토링 과정 (Refactoring Process) 수행한 작업: 리팩토링 중 어떤 작업을 수행했는지 단계별로 설명합니다. 코드 리팩토링 과정에서 변경한 주요 사항들을 포함합니다. 시도한 방법: 리팩토링을 진행하며 시도한 다양한 방법을 기록합니다. 성공하지 못한 접근 방식도 포함하여, 해결 과정에서의 고민을 보여줍니다. 4. 최종 코드 (Final Code) 최종 코드 설명: 리팩토링 후의 최종 코드를 설명합니다. 리팩토링 전후의 주요 차이점과 개선된 부분을 코드와 함께 보여줍니다. // 리팩토링 후의 최종 코드 예시 func updateUI() { updateLabelText() updateButtonState() } 5. 결과 (Outcome) 성능 및 유지보수성 향상: 리팩토링 후 성능이나 유지보수성, 코드 가독성이 얼마나 개선되었는지 설명합니다. 6. 교훈 및 배운 점 (Lessons Learned) 리팩토링을 통해 배운 점: 리팩토링 과정에서 배운 점이나 새로 익힌 기술을 기록합니다. 비슷한 상황에서 적용할 수 있는 원칙이나 개선할 수 있는 부분을 정리합니다. [RxSwift] 중첩 구독 1. 리팩토링 이유 다른 개발자님께서 코드를 검토하던 중 중첩된 구독이 발생한 것을 알려주셨습니다. 코드의 가독성과 유지보수성을 높이기 위해 RxSwift의 권장 방식을 따르는 방향으로 리팩토링을 진행하게 되었습니다. 2. 기존 코드 문제점 confirmButton.rx.tapGesture() .when(.recognized) .subscribe(onNext: { [weak self] _ in guard let self = self else { return } let selectedRound = data[row].0 viewModel.selectedLotteryType .subscribe(onNext: { [weak self] type in switch type { case .lotto: self?.viewModel.fetchLottoResult(round: selectedRound) self?.viewModel.currentLottoRound.accept(selectedRound) case .pensionLottery: self?.viewModel.fetchPensionLotteryResult(round: selectedRound) self?.viewModel.currentPensionLotteryRound.accept(selectedRound) case .speeto: break } }) .disposed(by: disposeBag) self.dismiss(animated: true, completion: nil) }) .disposed(by: disposeBag) 여기 에서 확인할 수 있듯이 RxSwift에서는 operator를 사용하여 스트림을 조합하는 것이 권장되지만, 기존 코드는 이를 따르지 않고 중첩 구독하는 방식으로 작성되어 있었습니다. 3. 리팩토링 과정 (Refactoring Process) 중첩된 subscribe 제거: withLatestFrom 연산자를 사용하여 confirm 버튼을 탭하는 시점에 최신 lottery type을 가져오도록 하여 viewModel.selectedLotteryType의 subscribe를 제거하였습니다. 4. 최종 코드 (Final Code) confirmButton.rx.tapGesture() .when(.recognized) .withLatestFrom(viewModel.selectedLotteryType) // tap 시점에 최신 로터리 타입을 가져옴 .subscribe(onNext: { [weak self] type in guard let self = self else { return } let selectedRound = data[row].0 switch type { case .lotto: self.viewModel.fetchLottoResult(round: selectedRound) self.viewModel.currentLottoRound.accept(selectedRound) case .pensionLottery: self.viewModel.fetchPensionLotteryResult(round: selectedRound) self.viewModel.currentPensionLotteryRound.accept(selectedRound) case .speeto: break } self.dismiss(animated: true, completion: nil) }) .disposed(by: disposeBag) 리팩토링 후의 최종 코드는 중첩된 구독을 제거하고, withLatestFrom 연산자를 사용하여 구독을 단순화했습니다. 이로 인해 코드의 가독성과 유지보수성이 크게 향상되었습니다. 6. 교훈 및 배운 점 리팩토링 과정에서 RxSwift의 operator 사용의 중요성을 깨달았습니다. 스트림을 조합하는 방식이 코드의 가독성과 유지보수성을 높이는 데 얼마나 효과적인지를 실감했으며, 앞으로도 이러한 원칙을 적용해 더 나은 코드를 작성할 수 있도록 할 것입니다."
  },"/til/2024-09-20-lottoMate.html": {
    "title": "프로젝트 ‘로또메이트’ - 문제 해결 내용",
    "keywords": "TIL",
    "url": "/til/2024-09-20-lottoMate.html",
    "body": "Template 이슈 정리 템플릿 아래 템플릿을 사용하여 프로젝트 진행 중 발생한 이슈 내용을 정리합니다. 각 항목에 맞춰 문제와 해결 방법을 구체적으로 작성합니다. 1. 문제 상황 (Problem) 배경 설명: 문제 발생 전에 있었던 상황이나 필요했던 기능을 간략하게 설명합니다. 문제 설명: 구체적으로 문제가 무엇인지 설명합니다. 해당 문제를 어떻게 발견했는지, 문제를 다시 재현하는 방법도 간략하게 언급할 수 있습니다. 2. 원인 분석 (Analysis) 원인 분석 과정: 문제를 분석하면서 발견한 내용을 설명합니다. 관련 코드를 포함하면 좋습니다. 시도한 방법들: 문제를 해결하기 위해 시도한 여러 방법을 설명합니다. 성공하지 못한 방법도 간략히 언급하여, 문제 해결 과정의 고민을 드러냅니다. 3. 해결 방법 (Solution) 최종 해결 방법: 문제를 어떻게 해결했는지 구체적으로 설명합니다. 해결한 코드를 포함시켜 독자가 쉽게 이해할 수 있도록 합니다. 왜 이 방법이 효과적인지: 해결책이 왜 효과적이었는지 설명하여, 독자가 그 원리를 이해할 수 있게 돕습니다. 4. 결과 (Result) 결과 설명: 문제 해결 후의 결과를 설명합니다. 성능, UI 개선 등 눈에 띄는 변화가 있다면 언급합니다. 추가 개선 사항: 만약 문제 해결 과정에서 배운 점이나 추가로 고려할 사항이 있다면 짧게 언급합니다. 5. 교훈 (Takeaways) 배운 점: 이 문제를 해결하며 배운 점을 간략히 정리합니다. 비슷한 상황에서 적용할 수 있는 원칙을 공유합니다. 커스텀 네비게이션 바 레이아웃 이슈 1. 문제 상황 iPhone 14 Pro, iPhone 14 Pro Max, iPhone 15 Pro, iPhone 15 Pro Max 기기 시뮬레이터에서 status bar와 커스텀 navigation bar 사이에 5px 정도의 빈 공간이 나타나는 문제가 발생했습니다. 다른 기기 시뮬레이터 에서는 이러한 현상이 나타나지 않았으며, 문제는 해당 네 가지 기기 시뮬레이터에서만 재현되었습니다. 문제는 rootFlexContainer가 top safe area 바로 아래에 커스텀 네비게이션 바가 위치하도록 작성된 코드에서 발생했습니다. rootFlexContainer.pin.top(view.safeAreaInsets.top).horizontally() rootFlexContainer.flex.layout(mode: .adjustHeight) 2. 원인 분석 기존 코드에서는 view.safeAreaInsets.top을 사용하여 네비게이션 바를 top safe area 아래에 배치하고 있었습니다. 하지만 특정 기기에서는 status bar와 top safe area 간에 예상치 못한 빈 공간이 생기는 현상이 발생했습니다. 처음에는 사용자의 기기 정보를 기반으로 문제가 발생하는 기기(iPhone 14 Pro, iPhone 14 Pro Max, iPhone 15 Pro, iPhone 15 Pro Max)에 한해 커스텀 네비게이션 바의 margin top 값을 -5로 설정하여 빈 공간만큼 뷰를 위로 이동시키는 방식을 시도했습니다. 이를 통해 빈 공간이 없는 것처럼 보이게 했으나, 기기별 정보를 이용해 코드를 분기 처리하는 방식은 안전하지 않다고 판단했습니다. 따라서 최종적으로 status bar의 높이를 동적으로 구한 후, 그 값을 이용해 커스텀 네비게이션 바를 status bar 바로 아래에 위치시키는 방법을 사용했습니다. 3. 해결 방법 문제를 해결하기 위해, status bar의 높이를 직접 가져와 그 값을 기반으로 rootFlexContainer(커스텀 네비게이션 바)를 배치하도록 코드를 수정했습니다. 빈 공간이 발생하는 기기에서도 문제없이 동작할 수 있도록 statusBarManager를 통해 상태 바의 정확한 높이를 가져와 그 바로 아래에 네비게이션 바가 위치하도록 설정했습니다. // 상태바의 높이를 가져오기 위한 설정 var statusBarHeight: CGFloat = 0.0 if let windowScene = view.window?.windowScene { statusBarHeight = windowScene.statusBarManager?.statusBarFrame.height ?? 0 } // rootFlexContainer를 상태바 바로 아래에 배치 rootFlexContainer.pin .top(statusBarHeight) // 상태바 바로 아래에 배치 .horizontally() // 좌우 여백은 기본으로 적용 rootFlexContainer.flex.layout(mode: .adjustHeight) // 높이는 flex로 자동 조정 문제의 원인은 top safe area의 높이와 status bar의 높이가 서로 다르기 때문이었습니다. 기기마다 status bar의 높이가 다를 수 있지만, 이 값을 동적으로 가져와 top 값으로 설정함으로써 모든 기기에서 일관된 레이아웃을 유지할 수 있었습니다. 4. 결과 해당 코드를 적용한 후, iPhone 14 Pro, iPhone 14 Pro Max, iPhone 15 Pro, iPhone 15 Pro Max에서 모두 빈 공간이 나타나지 않고 네비게이션 바가 정상적으로 status bar 바로 아래에 배치되었습니다. 그 외 다른 기기에서도 정상적으로 레이아웃이 유지됨을 확인했습니다. 5. 교훈 이번 문제를 통해 기기별로 다른 코드를 사용하는 것보다, 모든 기기에서 일관되게 동작하는 코드를 찾는 것이 더 중요하다는 점을 알게 되었습니다. 앞으로는 특정 기기에 맞추기보다, 범용적으로 사용할 수 있는 코드를 우선적으로 고려하려고 합니다. 사진 확대 뷰 닫기 기능 이슈 1. 문제 상황 사진 확대 기능에서 닫기 버튼을 통해 뷰를 제거하는 기능이 필요했습니다. 닫기 버튼을 처음 눌렀을 때 뷰가 사라지지 않고 두 번째 눌렀을 때부터 사라지는 문제가 발생했습니다. 2. 원인 분석 닫기 버튼 클릭 시 동작하는 함수인 dismissFullscreenImage()가 호출될 때 전체 subview의 배경색을 확인해본 결과, 사진 확대 뷰가 두번 추가되었기 때문에 발생한 문제임을 발견했습니다. @objc func dismissFullscreenImage() { for subview in self.view.subviews { print(\"subview's background color: \\(String(describing: subview.backgroundColor))\") } // subview's background color: nil // subview's background color: Optional(kCGColorSpaceModelRGB 0 0 0 0.8 ) // subview's background color: Optional(kCGColorSpaceModelRGB 1 1 1 0.8 ) // subview's background color: Optional(kCGColorSpaceModelRGB 0 0 0 0.8 ) 3. 해결 방법 winningReviewFullSizeImgName이 기본값을 내보낼 때도 서브 뷰가 추가되도록 코드가 작성되어 있었기 때문에 발생한 문제임을 발견했습니다. 기본값인 ““일 때는 뷰가 추가되지 않도록 수정했습니다. func showTappedImage() { viewModel.winningReviewFullSizeImgName .subscribe(onNext: { name in if name != \"\" { // 기본값인 \"\"일 때 추가되지 않도록 수정 self.changeStatusBarBgColor(bgColor: .clear) self.showFullscreenImage(named: \"\\(name)\") } }) .disposed(by: disposeBag) } 4. 결과 문제 해결 후 닫기 버튼을 클릭하면 뷰가 즉시 제거되며, 사용자 경험이 개선되었습니다. 향후에는 UI 요소의 추가와 제거를 더 체계적으로 관리하기 위해 뷰의 상태를 명확하게 정의할 계획입니다. 5. 교훈 이 문제를 해결하며 문제를 바로 해결하려고 하기보다는 문제의 원인을 빠르게 파악하는 것이 중요하다는 것을 깨달았습니다. 원인을 이해한 후에 적절한 해결책을 찾는 것이 더 효과적입니다. UILabel 숫자 변경 시 레이아웃 흔들림 문제 해결 1. 문제 상황 (Problem) 배경 설명: 로또 번호를 랜덤으로 생성하는 뷰에 “오늘 N번째 돌렸어요!” 라는 텍스트를 보여주는 UILabel을 구현했습니다. N은 사용자가 버튼을 누를 때마다 증가하는 횟수를 표시합니다. 문제 설명: 횟수(N)가 한 자릿수에서 두 자릿수로 변경될 때(예: 9→10), 두 자릿수에서 세 자릿수로 변경될 때(예: 99→100), 또는 같은 자릿수 내에서도 숫자가 변경될 때(예: 112→115)마다 레이블의 전체 너비가 변경되어 UI가 흔들리는 현상이 발생했습니다. 이는 각 숫자가 서로 다른 너비를 가지고 있어서, 숫자가 바뀔 때마다 전체 텍스트의 너비도 함께 변경되는 문제였습니다. 2. 원인 분석 (Analysis) 원인 분석 과정: 기존 폰트는 proportional 숫자를 사용하고 있었습니다. Proportional 숫자는 각 숫자가 자신의 실제 너비만큼 공간을 차지하기 때문에, “1”과 “2” 같은 숫자의 너비가 서로 달라 전체 텍스트의 길이가 변경되었습니다. 시도한 방법들: 레이블의 너비를 고정값으로 설정 레이블의 텍스트 정렬 방식 변경 위의 방법들은 근본적인 문제 해결이 되지 않았습니다. 3. 해결 방법 (Solution) 최종 해결 방법: UIFontDescriptor에 모노스페이스 숫자 특성을 추가하여 모든 숫자가 동일한 너비를 갖도록 수정했습니다. let fontDescriptor = UIFontDescriptor(name: fontName, size: self.size) .addingAttributes([ .featureSettings: [ [ UIFontDescriptor.FeatureKey.type: kNumberSpacingType, UIFontDescriptor.FeatureKey.selector: kMonospacedNumbersSelector ] ] ]) let font = UIFont(descriptor: fontDescriptor, size: self.size) 왜 이 방법이 효과적인지: OpenType 폰트 기능 중 모노스페이스 숫자 설정을 활용하여, 모든 숫자가 동일한 너비를 갖도록 만들었습니다. 이로 인해 숫자가 변경되어도 전체 텍스트의 너비가 일정하게 유지됩니다. 4. 결과 (Result) 결과 설명: 숫자가 한 자릿수에서 두 자릿수, 세 자릿수로 변경되어도 레이블의 너비가 변경되지 않고 안정적으로 표시됩니다. 5. 교훈 (Takeaways) 숫자를 포함하는 동적 텍스트를 다룰 때는 폰트의 숫자 표시 방식(proportional vs. monospace)을 고려해야 합니다. UIFontDescriptor의 다양한 특성들을 활용하면 텍스트 표시와 관련된 세밀한 제어가 가능합니다."
  },"/til/2024-06-26-PinLayoutAndFlexLayout.html": {
    "title": "PinLayout &amp; FlexLayout",
    "keywords": "TIL",
    "url": "/til/2024-06-26-PinLayoutAndFlexLayout.html",
    "body": "이 포스팅은 PinLayout &amp; FlexLayout 사용하여 프로젝트를 진행하며 기억해두고 싶은 것을 적어두는 것에 목적을 두고 있습니다. 🍊 override init() { // 뷰의 appearance를 정의 } override func layoutSubviews() { // 이 안에서 layout을 설정해주어야 뷰에 나타남. } 🍊 addressField.pin.below(of: visible([ageSwitch, ageField])).horizontally().height(height).marginTop(margin).marginHorizontal(20) visible을 사용하여 보이는 뷰의 아래에 뷰를 pin 할 수 있음. ageSwitch 버튼의 isOn 상태에 따라 ageField가 나타났다 사라졌다 하는데 ageField가 나타났을 때는 ageField 아래에 뷰가 나타나고, 사라졌을 때는 ageSwitch 밑에 뷰가 나타남. 🍊 override func layoutSubviews() { super.layoutSubviews() // top: safety area에 고정, 나머지는 스크린 끝쪽에 고정 contentView.pin.top(pin.safeArea).bottom().left().right() } top: safety area에 고정, 나머지는 스크린 끝쪽에 고정 🍊 flex.addItem().direction(.row).alignItems(.baseline).define { flex in flex.addItem(view1).marginRight(8) flex.addItem(view2) } UILabel의 높이가 같은 컨테이너에 있을 경우 같게 나타나는 문제가 있어 아래와 같이 alignItems()를 추가해주어 각자의 높이가 정상적으로 나타나도록 함. 🍊 Simulator에서 layout이 정상적으로 보이지 않는 문제 Scroll view를 사용하는 뷰가 프리뷰에서는 정상적으로 보이나 시뮬레이터에서는 정상적으로 보이지 않음. 코드 a와 b의 순서가 다른 것이 문제였음. scroll view를 pin하는 코드를 먼저 작성해주었더니 정상적으로 나타남. override func layoutSubviews() { super.layoutSubviews() scrollView.pin.top().bottom().left().right() // scroll view를 pin하는 코드 a rootFlexContainer.pin.top().left().right() // rootFlexContainer를 pin하는 코드 b rootFlexContainer.flex.layout(mode: .adjustHeight) scrollView.contentSize = rootFlexContainer.frame.size }"
  },"/til/2024-06-09-UIKit-toturial.html": {
    "title": "UIKit 튜토리얼 따라가보기",
    "keywords": "TIL",
    "url": "/til/2024-06-09-UIKit-toturial.html",
    "body": "Creating a list view Add a collention view controller 뷰컨트롤러(이하 ‘뷰컨’)는 뷰와 데이터 모델 사이에 다리 역할을 한다. 각 뷰컨은 하나의 뷰 계층을 관리하는 역할을 담당한다. 뷰의 컨텐츠를 업데이트하고, UI에 일어난 이벤트를 관리한다. Interface Builder를 사용하여 컬렉션 뷰컨트롤러를 생성해보자. 컬렉션뷰는 그리드, 행, 열, 또는 테이블의 형태로 셀을 보여준다. Collection view controller scene을 추가한다. 생성된 collection view의 cell 템플릿을 제거한다. (셀을 코드에서 정의할 것이기 때문.) Attribute inspector에서 is initial view controller 체크박스를 체크하여 해당 씬을 스토리보드의 엔트리 포인트로 설정 (앱이 스토리보드를 로드할 때 가장 먼저 로드됨.) Create a reminder model structure를 사용하여 모델을 생성한다. Swift 컴파일러가 자동으로 스트럭처에 멤버에 해당하는 이니셜라이저를 생성하기 때문에 따로 이니셜라이저를 생성할 필요가 없다. #if DEBUG extension Reminder { } #endif #if DEBUG 블락을 사용하여 디버그 모드에서만 컴파일되는 코드를 작성할 수 있다. 디버그 빌드에서 테스팅을 위한 코드를 작성하거나, 샘플 테스트 데이터를 작성할 때 사용할 수 있다. 나는 아래와 같이 내 앱 데이터에 해당하는 샘플 데이터를 생성했다. #if DEBUG extension LottoWinPointModel { static var sampleLottoWinPoints = [ LottoWinPointModel(currentCount: 10, data: LottoWinPointModelData.sampleLottoWinPointsData, matchCount: 330, page: 1, perPage: 10, totalCount: 330) ] } extension LottoWinPointModelData { static var sampleLottoWinPointsData = [ LottoWinPointModelData(firstPrizeWinsCount: \"5\", storeName: \"일등복권편의점\", orderNumber: \"1\", region: \"대구 달서구\"), LottoWinPointModelData(firstPrizeWinsCount: \"3\", storeName: \"오케이상사\", orderNumber: \"2\", region: \"서울 서초구\"), LottoWinPointModelData(firstPrizeWinsCount: \"2\", storeName: \"세진전자통신\", orderNumber: \"3\", region: \"대구 서구\"), LottoWinPointModelData(firstPrizeWinsCount: \"2\", storeName: \"라이프마트\", orderNumber: \"4\", region: \"인천 중구\"), LottoWinPointModelData(firstPrizeWinsCount: \"2\", storeName: \"스파\", orderNumber: \"5\", region: \"서울 노원구\"), LottoWinPointModelData(firstPrizeWinsCount: \"2\", storeName: \"노다지복권방\", orderNumber: \"6\", region: \"인천 미추홀구\"), LottoWinPointModelData(firstPrizeWinsCount: \"2\", storeName: \"흥부네박터졌네\", orderNumber: \"7\", region: \"인천 계양구\"), LottoWinPointModelData(firstPrizeWinsCount: \"2\", storeName: \"오천억복권방\", orderNumber: \"8\", region: \"광주 서구\"), LottoWinPointModelData(firstPrizeWinsCount: \"2\", storeName: \"해피+24시편의점\", orderNumber: \"9\", region: \"광주 북구\"), LottoWinPointModelData(firstPrizeWinsCount: \"2\", storeName: \"토큰박스\", orderNumber: \"10\", region: \"경기 남양주시\"), ] } #endif Configure the collection as a list Compositional layout을 사용하여 컬렉션 뷰의 appearance를 설정하기. 컴포지셔널 레이아웃은 sections, groups, items와 같은 컴포넌트를 조합하여 뷰를 생성함. 아이템이 가장 작은 단위, 아이템의 그룹이 group, 가장 큰 단위가 section. 스토리보드의 Collection view controller를 backing code에 연결하기. UICollectionViewController를 상속하는 뷰컨 클래스를 생성. 스토리보드의 Custom Class의 클래스를 해당 파일로 변경해주어 클래스 인스턴스에 엑세스할 수 있도록 함. private func listLayout() -&gt; UICollectionViewCompositionalLayout { var listConfiguration = UICollectionLayoutListConfiguration(appearance: .grouped) listConfiguration.showsSeparators = false listConfiguration.backgroundColor = .clear return UICollectionViewCompositionalLayout.list(using: listConfiguration) } UICollectionLayoutListConfiguration은 리스트의 섹션 부분을 생성함. 생성한 list configuration을 사용하여 UICollectionViewCompositionalLayout을 리턴함. override func viewDidLoad() { super.viewDidLoad() let listLayout = listLayout() collectionView.collectionViewLayout = listLayout } 뷰컨이 자신의 뷰 계층을 메모리에 로드한 후, 시스템이 ViewDidLoad() 함수를 호출함. viewDidLoad() 함수 안에서 리스트 레이아웃을 생성한 뒤 collectionViewLayout에 할당함. Configure the data source let cellResistration = UICollectionView.CellRegistration { (cell: UICollectionViewListCell, indexPath: IndexPath, itemIdentifier: String) in let lottoWinPoint = LottoWinPointModelData.sampleLottoWinPointsData[indexPath.item] var contentConfiguration = cell.defaultContentConfiguration() contentConfiguration.text = lottoWinPoint.storeName cell.contentConfiguration = contentConfiguration } CellRegistration을 사용하여 셀의 스타일과 내용(데이터)를 설정한다. defaultContentConfiguration()은 시스템 디폴트 스타일의 셀을 리턴함. contentConfigutation.text는 primary 스타일의 텍스트를 셀에 나타냄. typealias DataSource = UICollectionViewDiffableDataSource&lt;Int, String&gt; var dataSource: DataSource! dataSource = DataSource(collectionView: collectionView, cellProvider: { (collectionView: UICollectionView, indexPath: IndexPath, itemIdentifier: String) in return collectionView.dequeueConfiguredReusableCell(using: cellResistration, for: indexPath, item: itemIdentifier) }) typealias를 사용하여 길게 표현된 타입을 짧게 줄일 수 있음. dataSource 변수는 implicitly unwrapped optional 인데, (!를 사용하여 강제로 언래핑) 이것은 위에서처럼 값이 언제나 있을때만 사용해야 함. 새로운 셀을 계속해서 생성할수도 있지만 앱 퍼포먼스를 위하여 리유저블 셀을 사용함. Apply a snapshot Diffable 데이터 소스는 스냅샷을 사용하여 데이터의 상태를 관리함. 스냅샵은 특정 시간 지점의 데이터 상태를 보여줌. 스냅샷을 사용하여 데이터를 보여주기 위해서, 스냅샷을 생성, 보여주길 원하는 데이터의 상태로 스냅샷을 채우고, 스냅샷을 UI에 적용함. typealias SnapShot = NSDiffableDataSourceSnapshot&lt;Int, String&gt; var snapshot = SnapShot() // 스냅샷 생성 snapshot.appendSections([0]) // 하나의 섹션 추가 snapshot.appendItems(LottoWinPointModelData.sampleLottoWinPointsData.map { $0.storeName }) // 샘플데이터 중 storeName으로 배열을 생성하여 아이템으로 추가 dataSource.apply(snapshot) // 데이터 소스에 적용하여 데이터의 변경사항이 UI에 적용되도록 함. collectionView.dataSource = dataSource // 컬렉션 뷰에 데이터소스 적용. Displaying cell info Organize view controllers UIKit 앱에서 뷰컨은 여러가지 역할을 담당한다. 데이터 소스와 관련된 behavior를 다른 파일로 분리시켜 뷰컨의 역할을 정리해보자. import UIKit extension WinPointsListViewController { typealias DataSource = UICollectionViewDiffableDataSource&lt;Int, String&gt; typealias SnapShot = NSDiffableDataSourceSnapshot&lt;Int, String&gt; func cellRegistrationHandler(cell: UICollectionViewListCell, indexPath: IndexPath, id: String) { let lottoWinPoints = LottoWinPointModelData.sampleLottoWinPointsData[indexPath.item] var contentConfiguration = cell.defaultContentConfiguration() contentConfiguration.text = lottoWinPoints.storeName contentConfiguration.secondaryText = \"1등 당첨 횟수: \\(lottoWinPoints.firstPrizeWinsCount)\" contentConfiguration.secondaryTextProperties.font = UIFont.preferredFont(forTextStyle: .caption1) cell.contentConfiguration = contentConfiguration } } WinPointsListViewController+DataSource라는 이름의 파일을 생성. cellRegistrationHandler 함수를 작성. WinPointsListViewController에 있는 cell registration 부분의 trailing closure를 아래 코드로 대체. let cellResistration = UICollectionView.CellRegistration(handler: cellRegistrationHandler) 뷰컨은 많은 역할을 담당하므로 그 코드가 길어질 수 있기 때문에, 위와 같이 extension을 사용하여 역할 별로 구분된 파일을 생성하여 에러를 찾기 쉽고 새 기능을 쉽게 추가할 수 있도록 해야함. Making reminders identifiable Diffable data source는 컬렉션 뷰의 아이템들이 가지는 identifier를 담은 리스트를 가지고 있다. struct LottoWinPointModelData: Codable, LottoWinPoint, Identifiable { var id: String = UUID().uuidString } LottoWinPointModelData.ID Identifiable 프로토콜을 사용하려면 id 속성이 필수로 필요. structure이름.ID는 Identifiable 프로토콜의 연관속성으로 위 코드에서는 String의 type alias가 됨. Create functions for accessing the model // extension Array where Element == LottoWinPointModelData extension [LottoWinPointModelData] { func indexOfWinPoint(widhId id: LottoWinPointModelData.ID) -&gt; Self.Index { guard let index = firstIndex(where: { $0.id == id }) else { fatalError() } return index } } func lottoWinPoint(withId id: LottoWinPointModelData.ID) -&gt; LottoWinPointModelData { let index = lottoWinPoints.indexOfWinPoint(widhId: id) return lottoWinPoints[index] } func updateLottoWinPoint(_ lottoWinPoint: LottoWinPointModelData) { let index = lottoWinPoints.indexOfWinPoint(widhId: lottoWinPoint.id) lottoWinPoints[index] = lottoWinPoint } 커스텀 타입 ‘LottoWinPointModelData’ 타입 배열의 extension 생성. 배열의 요소가 LottoWinPointModelData 타입일 경우 이 익스텐션 안에 작성된 indexOfWinPoint(withId:) 함수를 사용하여 해당 아이디를 가진 요소의 index를 얻을 수 있게 됨. lottoWinPoint(withId:), updateLottoWinPoint() 함수를 사용하여 각 lottoWinPoint의 id 값으로 배열안의 인덱스 값을 얻을 수 있음. 이 방식으로 lotto win point 데이터를 가져오거나 업데이트 하도록 함. Wire a target-action pair Target-action은 디자인 패턴인데, 이벤트가 발생하면 한 객체가 이벤트를 실행하기 위해 다른 객체에 메세지를 보낸다. import UIKit class LottoWinPointLikedButton: UIButton { var id: LottoWinPoint.ID? } 커스텀 UIButton 클래스를 생성한 뒤, id 속성을 추가한다. import Foundation extension WinPointsListViewController { @objc func didPressLikedButton(_ sender: LottoWinPointLikedButton) { guard let id = sender.id else { return } likeLottoWinPoint(withId: id) } } WinPointsListViewController+Actions 파일을 생성한 뒤, 뷰컨의 액션 관련 코드를 분리해줍니다. didPressLikedButton() 함수를 작성하여 해당 버튼의 id를 가져와서 likeLottoWinPoint()를 실행. Breakpoint 사용해보기 liked button을 탭 했을 때 아무일도 일어나지 않아서 이 action이 동작하는지 확인이 필요함. 버튼이 탭 되었을 때 업데이트하는 함수 call 부분에 breakpoint를 추가하고 다시 동작시킴. break point에 멈추기 때문에 함수가 호출된다는 것은 알 수 있음. 함수 호출이 문제가 아니라, 변경된 사항을 보여주기 위해 새 스냅샷을 생성해야 함. Update the snapshot func updateSnapshot(reloading ids: [LottoWinPoint.ID] = []) { var snapshot = SnapShot() snapshot.appendSections([0]) snapshot.appendItems(lottoWinPoints.map { $0.id }) if !ids.isEmpty { snapshot.reloadItems(ids) } dataSource.apply(snapshot) } 파라미터에 빈 배열을 기본값으로 줌으로써 viewDidLoad() 함수에서 ids 값 없이 호출할 수 있도록 함. viewDidLoad()에서는 ids 값없이 호출하여 스냅샷이 리로드되지 않고, updateSnapshot(reloading: [id]) 와 같이 id 값이 파라미터로 들어와 호출되면 스냅샷이 리로드 되도록 함. Make the action accessible var lottoWinPointLikedValue: String { NSLocalizedString(\"Liked\", comment: \"Lotto win point liked value\") } var lottoWinPointNotLikedValue: String { NSLocalizedString(\"Not Liked\", comment: \"Lotto win point not liked value\") } func cellRegistrationHandler(cell: UICollectionViewListCell, indexPath: IndexPath, id: LottoWinPoint.ID) { let lottoWinPoint = lottoWinPoint(withId: id) cell.accessibilityCustomActions = [likedButtonAccessibilityAction(for: lottoWinPoint)] cell.accessibilityValue = lottoWinPoint.isLiked ? lottoWinPointLikedValue : lottoWinPointNotLikedValue } private func likedButtonAccessibilityAction(for lottoWinPoint: LottoWinPoint) -&gt; UIAccessibilityCustomAction { let name = NSLocalizedString(\"Toggle completion\", comment: \"Lotto win point accessibility label\") let action = UIAccessibilityCustomAction(name: name) { [weak self] action in self?.likeLottoWinPoint(withId: lottoWinPoint.id) return true } return action } 위와 같이 Accessibility를 추가하고 Accessibility inspector를 사용하여 시뮬레이터로 테스트할 수 있음. Displaying reminder details class LottoWinPointViewController: UICollectionViewController { var lottoWinPoint: LottoWinPoint init(lottoWinPoint: LottoWinPoint) { self.lottoWinPoint = lottoWinPoint var listConfiguration = UICollectionLayoutListConfiguration(appearance: .insetGrouped) listConfiguration.showsSeparators = false let listLayout = UICollectionViewCompositionalLayout.list(using: listConfiguration) super.init(collectionViewLayout: listLayout) } } Swift의 서브클래스는 초기화 과정에서 슈퍼클래스의 designated initializers를 호출해야 함. Display the detail view override func collectionView(_ collectionView: UICollectionView, shouldSelectItemAt indexPath: IndexPath) -&gt; Bool { let id = lottoWinPoints[indexPath.item].id pushDetailViewForLottoWinPoint(withId: id) return false } func pushDetailViewForLottoWinPoint(withId id: LottoWinPoint.ID) { let reminder = reminder(withId: id) let viewController = LottoWinPointViewController(lottoWinPoint: lottoWinPoint) navigationController?.pushViewController(viewController, animated: true) } 디테일 뷰는 리스트의 셀을 선택하면 보여짐. 해당 Lotto win point의 아이디 값을 사용하여 디테일 정보를 가져옴. 생성해둔 LottoWinPointViewController(디테일 뷰)에 lotto win point 정보를 넣어 view controller 인스턴스를 생성. 네비게이션 스택에 푸시해주기. collectionView(_ collectionView: UICollectionView, shouldSelectItemAt indexPath: IndexPath) 함수를 사용하여 해당 셀이 선택되었을 때 pushDetailViewForLottoWinPoint 함수가 실행되도록 함. 이때 선택이 되었는지를 표시하지 않기 때문에 false를 리턴함. Main 스토리보드로 이동하여 Win point list view controller scene을 선택하고 Editor - Embed in - navigation controller를 선택하여 네비게이션 컨트롤러를 생성 빌드하여 디테일 뷰를 확인하기. Getting ready for editing Add an edit button UIViewController의 서브클래스는 editButtonItem 속성을 가지고 있습니다. 이 속성을 사용하여 편집 모드를 껐다/켰다 할 수 있습니다. override func viewDidLoad() { super.viewDidLoad() navigationItem.rightBarButtonItem = editButtonItem } 유저가 Edit 버튼을 탭하면 시스템은 setEditing(_:animated:) 함수를 호출합니다. 이 함수를 override하여 디테일뷰를 뷰/편집 모드로 전환합니다. Using Content Views Create a reusable layout function UIKit view는 UI를 생성하기 위해 사용되는 아주 기초적인 빌딩블럭이다. UIKit이 제공하는 subclass를 사용하여 라벨, 버튼 등의 일반적인 인터페이스 요소들을 만들 수 있다. extension UIView { func addPinnedSubview( _ subview: UIView, height: CGFloat? = nil, insets: UIEdgeInsets = UIEdgeInsets(top: 0, left: 8, bottom: 0, right: 8) ) { addSubview(subview) subview.translatesAutoresizingMaskIntoConstraints = false subview.topAnchor.constraint(equalTo: topAnchor, constant: insets.top).isActive = true subview.leadingAnchor.constraint(equalTo: leadingAnchor, constant: insets.left).isActive = true } } UIView의 addSubview(_:) 메서드는 슈퍼뷰의 가장 아래 계층에 sub view를 추가함. 시스템이 자동으로 constraint를 생성하지만, 환경(사이즈, 스크린 방향)에 따라 다른 contraint를 뷰에 적용하지 않기 때문에 false 처리 해줌. UIKit의 constraint syntax를 사용하여 슈퍼뷰의 top 부분에 sub view를 pin함. Create a custom view with a text field import UIKit class TextFieldContentView: UIView { let textField = UITextField() override var intrinsicContentSize: CGSize { CGSize(width: 0, height: 44) } init() { super.init(frame: .zero) // 1 addPinnedSubView(textField, insets: UIEdgeInsets(top: 0, left: 16, bottom: 0, right: 16)) // 2 } required init?(coder: NSCoder) { fatalError(\"init(coder:) has not been implemented\") } } 처음에는 프레임 사이즈 없이 텍스트 필드를 초기화 함. 텍스트 필드는 top에 pin되고, 16의 horizontal padding을 가짐. top, bottom inset이 0이기 때문에 super view의 height 만큼 늘어나게 됨. Create a custom view with a text field 이 앱에서는, UIView의 서브클래스를 커스텀하여 편집화면에서 사용할 컨트롤을 만든다. UIKit configurations의 스타일과 power를 사용하기 위해서 커스텀 서브 클래스가 UIContentView 프로토콜을 따라야 한다. Configurations Configurations를 사용하여 셀과 뷰의 내용, appearance를 상세히 정할 수 있다. 뷰의 상태가 변경될 때 자동으로 업데이트되어 뷰가 해당 상태의 새로운 스타일을 반영할 수 있도록 함. Conform to the content view protocol UIContentView 프로토콜을 따르는 객체는 UIContentConfiguration 타입의 configuration 속성을 가져야 한다. 이 앱에서 사용할 configuration은 텍스트 필드의 값인 text 속성을 가진다. text 속성을 가진 커스텀 UIContentConfiguration 타입을 생성하자. Editing reminders workingReminder 라는 변수를 생성. 사용자가 편집 모드에서 workingReminder에 변경 사항을 일으키면 이 변경된 사항을 reminder에 복사해서 뷰 모드에서 그 데이터들이 보여지도록 함."
  },"/til/2024-04-09-swiftui-concepts-tutorials.html": {
    "title": "SwiftUI Tutorials",
    "keywords": "TIL",
    "url": "/til/2024-04-09-swiftui-concepts-tutorials.html",
    "body": "색 정의하기 Define colors in the asset catalog import SwiftUI // global property let gradientColors: [Color] = [ .gradientTop, .gradientBottom ] struct ContentView: View { //... } 에셋 카탈로그에 ‘GradientTop’, ‘GradientBottom’라는 이름의 Color set을 추가했습니다. Xcode가 자동으로 카멜케이스 스타일의 컬러 밸류를 생성합니다. (.gradientTop, .gradientBottom) ‘Gradient_Top’이라는 이름도 .gradientTop으로 변환됩니다. gradientColors 속성은 최상단 레벨에 작성되었고 이런 프로퍼티(=속성)을 글로벌 프로퍼티라고 합니다. 글로벌 프로퍼티는 모든 파일, 모든 코드에서 사용할 수 있게 됩니다. Text 뷰 Text 뷰는 읽기 전용 텍스트를 보여주는 뷰입니다. 텍스트 뷰는 타이틀과 같은 짧은 String, 또는 글의 내용과 같이 긴 String을 컨텐츠로 가질 수 있습니다. mutating 함수 // 뷰가 새 레시피를 추가하는 화면을 보이도록 상태를 변경하는 함수 mutating func presentAddRecipe(sidebar: SidebarItem) { recipe = Recipe.emptyRecipe() // ... shouldSaveChanges = false isPresented = true } 함수가 위치한 structure 안에 정의된 변수인 shouldSaveChanges, isPresented의 값을 변경시키기 때문에 mutating 키워드를 사용하여 작성함 .Sheet modifier .sheet(isPresented: $recipeEditorConfig.isPresented, onDismiss: didDismissEditor) { RecipeEditor(config: $recipeEditorConfig) } 위의 sheet modifier는 recipeEditorConfig.isPresented 값을 바인딩으로 받는다. 그러므로 isPresented 값을 read / write 할 수 있게 된다. 만약 사용자가 아래 방향으로 스와이핑하여 시트가 아래로 내려가면, isPresented의 값이 false로 변경되고, SwiftUI가 뷰를 다시 초기화하고, 다시 그린다. 그러하여 더이상 sheet가 올라와있지 않게 된다. Design a custom control 커스텀 컨트롤을 구현하기 전에 생각해 볼 것이 있다. 어떤 데이터가 필요한지, 그 데이터를 사용하여 뭘 하는지, 그리고 데이터를 뷰에 어떻게 보여줄 것인지이다. Specifying the source of truth 이 샘플 앱은 커스텀 뷰인 DetailView에서 레시피의 세부사항을 보여주는데, DetailView는 레시피의 id만 알고 있다. 레시피의 세부사항은 recipe box라는 데이터 스토어에 담겨 있는데, 이 세부사항을 가져와 DetailView에서 보여주기 위해 커스텀 바인딩을 사용한다. DetailView에서 State를 사용하여 원천데이터를 정의하는 것이 아니고, 데이터 스토어에서 커스텀 바인딩과 id를 통해 데이터를 가져오는 것이다. Note 커스텀을 바인딩은 state 변수로 원천데이터를 정의할 수 없을 떄, state object를 사용하여 모델 데이터를 공유할 수 없을 때만 사용한다. 여기서는 왜 커스텀 바인딩을 사용했는가? private var recipe: Binding&lt;Recipe&gt; { Binding { if let id = recipeId { return recipeBox.recipe(with: id) ?? Recipe.emptyRecipe() } else { return Recipe.emptyRecipe() } } set: { updatedRecipe in recipeBox.update(updatedRecipe) } } state 변수를 정의하는 대신, recipe라는 computed property를 선언했다. recipe는 Recipe를 리턴하지 않고, Recipe 타입의 커스텀 바인딩을 리턴한다. 내가 작성한 코드와 다른점 이 샘플 앱은 총 3개의 네비게이션 층을 가지고 있다. 카테고리 등을 선택할 수 있는 side bar 부분, 레시피 리스트 부분, 레시피 디테일 부분. 이 세가지의 네비게이션 층을 파일로 생성하였다. 그리고 그 안에서 세부 뷰들을 나눠 파일을 만들었다. 그렇게 하므로써 선언형 코드의 장점을 극대화했다. 전에 내가 작성했던 코드는 물론 더 복잡한 네비게이션 계층을 가지고 있기 때문에 똑같이 작성할 수는 없겠지만, 뷰에 적용될 데이터를 가져오지 못했거나 없을 경우 나타나는 뷰와 데이터가 있을 경우 나타나는 뷰를 한 파일에 작성하고 (DetailView), 데이터가 있을 경우 나타나는 뷰 (RecipeDetailView)를 따로 작성하여, 데이터 유무에 따라 어떤 뷰가 나타날지 한번에 볼 수 있도록 코드를 작성한 것이 눈에 띄였다. (나도 데이터가 없을 경우 나타나는 뷰를 따로 작성하긴 했지만, 데이터가 있을 경우의 뷰는 동일 파일에 작성했었다.) RecipeDetailView와 같은 경우 아래와 같이 작성되었는데, TopView(), BottomView() 구조체를 같은 파일에 private struct 로 작성한 뒤 각 뷰의 필요한 구조체는 따로 다른 파일에 작성하여 한눈에 볼 수 있도록 한 것이 인상 깊었다. struct RecipeDetailView: View { @Binding var recipe: Recipe var body: some View { VStack { TopView(recipe: $recipe) ScrollView { BottomView(recipe: recipe) } } } }"
  },"/til/2023-10-10-Scrumdinger.html": {
    "title": "앱 Scrumdinger 튜토리얼을 따라가며 정리",
    "keywords": "TIL",
    "url": "/til/2023-10-10-Scrumdinger.html",
    "body": "Scrumdinger app tutorial 이 글은 위 튜토리얼을 따라가며 정리한 내용입니다. Create a color theme 앱 전체에 일관된 스타일을 주기 위해 컬러 테마를 생성하기. 뷰 파일이 아니지만 Foundation을 제거하고 SwiftUI를 import (SwiftUI 프레임워크의 Color을 사용하기 때문) SwiftUI는 컬러를 뷰 계층에 바로 추가할 수 있는 하나의 뷰 인스턴스로 취급함. String 타입의 값을 raw value로 가지는 enum 생성 enum Theme: String { case bubblegum case buttercup case indigo case lavender var accentColor: Color { switch self { case .bubblegum, .buttercup, .lavender: return .black case .indigo: return .white } } } 위와 같이 case 이름만 작성해주면 Swift가 자동으로 스트링 타입의 raw value를 생성함. enum 안에 switch self를 사용하여 case 별로 값을 리턴하는 컬러 프로퍼티를 생성 Managing data flow between views Source of truth source of truth == 원천데이터 원천데이터를 사용하지 않으면 뷰에 나타나는 데이터가 불일치하는 버그가 생길 수 있음. 데이터를 가지고 있는 요소를 한 장소에 보관하고 뷰들이 그 데이터에 접근하도록 함. 앱 전체 코드를 통하는 원천데이터를 생성할 수도 있음. 원천 데이터를 정의하는 방식과 위치는 여러 뷰들 사이에서 공유되는 데이터인지, 변하는 데이터인지에 따라 다름. Swift property wrappers 스위프트의 프로퍼티 래퍼를 사용하여 특정 행동을 하는 속성을 만들 수 있음. 일반적으로 많이 사용되는 속성의 동작들을 캡슐화 해놓은 것. State는 그런 프로퍼티 래퍼중 하나로 뷰 안에서 원천데이터를 생성함. @State 사용자의 상호작용으로 @State 속성의 값이 변경될 수 있음. 이때 시스템은 이 새로운 값을 가진 버전의 뷰를 자동으로 다시 그림. state 속성은 일시적인 상태를 관리하는 것에 사용됨. (예: 버튼의 상태, 필터링 버튼, 현재 선택된 리스트 아이템..) 그렇기 떄문에 private으로 선언함. (한 뷰 안에서 일시적으로 변화되는 값들이기 때문에..) 같은 이유로 영속적으로 보관되어야 하는 데이터에는 사용하지 않음. @State 프로퍼티 래퍼는 하나의 뷰 안에서 변경되는 원천 데이터를 담기 위해 사용되는데, 만약 여러개의 뷰 계층 속에서 같은 원천데이터를 사용하고 싶다면..? @Binding Binding은 state 속성과 똑같이 원천데이터를 읽거나 값을 변경할 수 있음. @Binding은 데이터를 직접 담지 않고 원천 데이터와 뷰 사이에 양방향 커넥션을 생성함. 이 커넥션은 하나의 데이터와 관련된 뷰들이 같은 데이터 상태를 가지도록 함. 시스템은 원천데이터를 가진 부모뷰와 @Binding을 가진 자식뷰의 관계를 성립시킴. 이때는 자식뷰, 부모뷰 모두 원천데이터를 읽거나, 수정할 수 있음. 만약 자식뷰가 read-only 속성을 가지고 있다면, 원천데이터를 보내기만 할 수 있음. (수정은 안됨.) 두 경우 모두, 프레임워크가 자동으로 뷰를 업데이트 함. Making classes observable Working with reference types @State 속성은 구조체나 열거형과 같은 value type 원천데이터만 정의할 수 있다. 클래스와 같은 reference type인 원천데이터를 정의하려면 @State가 아닌 아래 세가지 프로퍼티 래퍼를 사용해야 한다. @ObservedObject @StateObject @EnvironmentObject 이 프로퍼티 래퍼들을 사용하려면 먼저 원천데이터가 될 클래스를 observable한 상태로 만들어주어야 한다. Making a class observable ObservableObject 프로토콜을 따르는 클래스를 생성하여 클래스를 observable 하도록 만들 수 있다. (observable의 사전적 의미 중 하나는 ‘관찰할 수 있는’이다. 클래스를 observable 하도록 만든다는 건, 다른 어떤 것들이 이 클래스를 관찰할 수 있도록 만든다는 것이다.) class ScrumTimer: ObservableObject { @Published var activeSpeaker = \"\" @Published var secondsElapsed = 0 @Published var secondsRemaining = 0 // ... } 이 클래스 안에서 위 세개의 속성들은 자신의 값이 변할 때 UI를 업데이트 해야한다. 이런 속성들은 @Published를 사용하여 정의한다. 이 published property의 값이 변경될 때 ScrumTimer가 자신을 관찰하고 있는 관찰자에게 이 변경사항을 알린다. Monitoring an object for changes ObservedObject, StateObject, EnvironmentObject 이 세가지의 속성 중 하나를 사용하여 SwiftUI가 observable 객체를 모니터링하도록 할 수 있다. 이 속성을 사용하여 정의된 프로퍼티는 원천데이터가 된다. struct MeetingView: View { @StateObject var scrumTimer = ScrumTimer() // ... } @StateObject 래퍼를 사용하여 observable 객체를 생성한다. App, Scene, View에서 스테이트 객체를 생성할 수 있다. 시스템이 스테이트 객체를 초기화하면 해당 스트럭처 또는 객체를 전달 받은 다른 뷰에서 해당 객체를 사용할 수 있다. Managing state and life cycle struct MeetingFooterView: View { let speakers: [ScrumTimer.Speaker] private var isLastSpeaker: Bool { return speakers.dropLast().allSatisfy { $0.isCompleted } } } 🖍️ 이 뷰 안에서만 필요한 computed property이기 때문에 private으로 선언 🖍️ dropLast()를 사용하여 speakers 배열의 마지막 요소를 제외한 배열을 리턴함. 🖍️ allSatisfy()를 사용하여 마지막 speaker를 제외한 모든 speakers의 isCompleted 이 true라는 bool 값을 리턴함. dropLast(_:) let numbers = [1, 2, 3, 4, 5] print(numbers.dropLast(2)) // Prints \"[1, 2, 3]\" print(numbers.dropLast(10)) // Prints \"[]\" 🖍️ 마지막 요소만 제외하거나, 제외할 요소의 수를 정할 수 있음. 위 코드에서는 2를 통과시켜 맨 뒤에서부터 배열의 요소 2개를 제외한 배열을 리턴 🖍️ 배열의 카운트보다 큰 수를 통과시킬 경우 빈 배열을 리턴 allSatisfy(_:) let names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"] let allHaveAtLeastFive = names.allSatisfy({ $0.count &gt;= 5 }) // allHaveAtLeastFive == true 🖍️ 배열의 모든 요소가 5자 이상인 이름인지를 bool 값으로 리턴함. import Foundation /// Keeps time for a daily scrum meeting. Keep track of the total meeting time, the time for each speaker, and the name of the current speaker. @MainActor final class ScrumTimer: ObservableObject { /// A struct to keep track of meeting attendees during a meeting. struct Speaker: Identifiable { /// The attendee name. let name: String /// True if the attendee has completed their turn to speak. var isCompleted: Bool /// Id for Identifiable conformance. let id = UUID() } // ... } 🖍️ 주석 /// 을 사용하여 Xcode에서 보여지는 문서를 작성할 수 있음 Adopting Swift Concurrency Swift 코드로 복잡한 비동기 작업을 단순화 해보자! SwiftUI 앱에서는 메인 스레드가 모든 UI 작업을 실행한다. 또, 탭하거나 스와이프하는 것과 같은 유저 이벤트를 처리한다. 앱이 제대로 작동하기 위해서는 모든 뷰 업데이트 작업과 이벤트 핸들러를 메인 스레드에서 실행해야 한다. 하지만 만약 모든 작업을 메인 스레드에서 처리한다면 앱이 느린 것과 같이 느껴질 수 있다. 만약 메인 스레드가 모든 코드를 처리하는 것을 기다려야 한다면, 앱이 느리거나 심지어 멈춘 것처럼 느껴질 수 있다. 그렇기 때문에 가능한 작업은 백그라운드 스레드에서 실행하고, 꼭 필요한 작업을 메인 스레드에서 실행하며 균형을 맞춰야 한다. 디스크에 있는 데이터를 읽고, 디스크에 데이터를 입력하는 작업을 비동기적으로 작성해보자. 이 작업에서는 스위프트의 비동기 함수, Task 타입, @MainActor 어노테이션을 사용할 것이다. Defining an asynchronous function 비동기 함수는 파라미터 리스트 뒤에 async 키워드를 추가하여 정의한다. 리턴값이 있을 경우 리턴 애로우 앞쪽에 표시한다. final class UserStore { func fetchParticipants() asyns -&gt; [Participant] {...} } Calling an asynchronous function await 키워드를 사용하여 비동기 함수를 호출한다. await 키워드는 비동기적인 흐름, 문맥에서만 사용할 수 있다. 아래 UserStore 클래스는 비동기 함수인 refresh() 안에서 fetchParticipants() 함수를 await를 사용해서 호출하고 있다. final class UserStore { func refresh() async -&gt; [UserRecord] { let participants = await fetchParticipants() let records = await fetchRecords(participants: participants) return records } func fetchParticipants async -&gt; [Participant] {...} func fetchRecords(participants: [Participant]) async -&gt; [UserRecord] } fetchParticipants()가 작업을 완료하는 동안 refresh() 함수는 잠시 멈춤. 그동안 refresh()를 실행하는 스레드는 다른 작업을 할 수 있음. fetchParticipants()의 작업이 완료되면, 시스템은 refresh() 함수의 다음 라인을 실행함. fetchRecords(participants: participants) 함수가 호출할 때 fetchParticipants()의 리턴값을 사용할 수 있음. 비동기 함수를 사용하면 작성돼있는 순서로 코드를 실행함. Creating an asynchronous context 비동기 함수는 비동기적인 문맥상에서만 사용할 수 있다. 이 비동기적인 문맥은 거의 대부분 또 다른 비동기 함수나 클로저의 바디 부분이 될 것이다. 위 refresh() 함수가 비동기 함수로 작성되었기 때문에 또 다른 비동기 함수인 fetchParticipants()와 fetchRecords(participants:)를 호출할 수 있었다. 동기적 문맥상에서 작동하는 API를 사용하는 것과 같은 동기적 문맥상에서 비동기 함수를 호출해야 하는 일이 빈번히 발생하는데, 이때 Task를 사용하여 비동기 함수를 호출 할 수 있다. struct RefreshButton: View { @Binding var model: ViewModel var body: some View { Buton(\"Refresh\") { // 버튼의 액션 부분에서는 비동기 함수를 호출 할 수 없다. Task { // Task를 생성하여 액션 클로저 안에 비동기적 문맥을 생성하여 비동기 함수를 호출할 수 있다. await model.refresh() } } } } refresh() 함수가 리턴값을 가지고 있지 않고, 에러를 던지고 있지 않기 때문에 위의 코드는 정상적으로 동작한다. Task { } 안에서 리턴값이나 에러에 대한 처리를 수동적으로 처리하지 않으면 코드가 정상적으로 작동하지 않을 수 있다. 뷰 모더파이어인 onAppear(perform:)도 동기적 클로저의 또 다른 예다. SwiftUI의 task(priority:_:) 모더파이어를 사용하여 뷰가 나타날 때 비동기 함수를 실행할 수 있다. task의 생명주기는 task 모더파이어가 적용된 뷰의 생명주기와 같다. 뷰가 사라지면 진행중인 task가 취소된다. Updating the user interface @State 와 @Binding 속성의 값이 변경되면 뷰가 업데이트 된다. 그렇기 때문에 이 값들을 변경시키는 것은 메인 스레드에서 실행되어야 한다. 비동기 함수는 백그라운드 스레드에서 실행될 수 있기 때문에 위와 같은 동작을 하는 함수를 비동기 함수로 실행하는 것은 문제가 될 수 있다. Swift는 메인 스레드와의 상호작용을 돕기 위한 어노테이션인 @MainActor를 제공한다. @MainActor 어노테이션이 적용된 클래스의 속성의 변경은 모두 메인 스레드에서 다뤄지게 된다. 아래 코드에서 UserStore 는 ObservableObject이다. 그리고 users 는 퍼블리시드 속성이다. @MainActor를 사용했기 때문에 users 속성을 수정하는 동작은 메인스 스레드에서 일어나게 되고, 안전하게 뷰를 변경하는 @Binding과 함꼐 사용할 수 있게 된다. @MainActor class UserStore: ObservableObject { @Published var users: [UserRecord] = [] func refresh() async { let participants = await fetchParticipants() let records = await fetchRecords(participants: participants) self.users = records } func fetchParticipants() async -&gt; [Participant] { return [] } func fetchRecords(participants: [Participant]) async -&gt; [UserRecord] { return [] } } Persisting data 커스텀 타입에 Codable conformance를 적용하려면 타입의 모든 stored properties가 Codable을 채택하고 있어야 함. @Published 속성은 뷰에 bind 되어 있음. binding을 사용하여 가장 최신의 데이터로 뷰를 업데이트 할 수 있음. ObservableObject 는 클래스에만 사용할 수 있는 프로토콜로, SwiftUI 뷰와 외부 모델 데이터를 연결함. class ScrumStore: ObservableObject { @Published var scrums: [DailyScrum] = [] private static var fileURL() throws -&gt; URL { try FileManager.default.url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: false) .appendingPathComponent(\"scrums.data\") } } FileManager의 shared 인스턴스를 사용하여 현재 사용자의 문서 파일의 위치를 얻음. appendingPathComponent(_:) 함수를 호출하여 scrums.data 라는 이름의 파일의 URL을 리턴함 파일 시스템의 데이터를 읽는 동작은 느릴 수 있음. 파일 시스템으로부터 데이터를 읽어오는 동안, 시스템이 기다리지 않고 UI를 먼저 업데이트 하도록 함. func load() async throws { let task = Tast { } } let constant에 Task를 담아서 후에 리턴값에 접근하거나 task로 부터 던져진 에러를 catch할 수 있도록 함."
  },"/til/2023-05-24-ViewLayout.html": {
    "title": "SwiftUI 뷰 레이아웃",
    "keywords": "TIL",
    "url": "/til/2023-05-24-ViewLayout.html",
    "body": "struct ReusableLabel: View { let keyword: String let symbol: String var body: some View { Label(keyword, systemImage: symbol) .font(.title) .foregroundColor(.white) .padding() .background(.green.opacity(0.75), in: Capsule()) // - 1 } } struct ReusableLabel_Previews: PreviewProvider { // - 2 static let keywords = [\"Hello\", \"Good Morning\"] static var previews: some View { // - 3 VStack { // - 4 ForEach(keywords, id: \\.self) { word in KeywordBubbleDefaultPadding(keyword: word, symbol: \"fish\") } } } } 1: .background에 Capsule()을 정의해줌으로써 캡슐 모양이 Label의 뒷쪽에 오도록 함. 이때 .padding()을 백그라운드의 윗쪽에 선언해주어야 패딩을 포함한 백그라운드에 캡슐 모양을 생성할 수 있음. 2: PreviewProvider 프로토콜을 사용하여 커스텀 스위프트UI 뷰의 코드가 생성하는 화면을 미리 볼 수 있음 3: PreviewProvider 프로토콜을 구현하기 위해선 static previews 프로퍼티를 정의해야 함 4: VStack 안에 ForEach를 사용하여, ReusableLabel 스트럭쳐가 생성하는 라벨 뷰가 다른 텍스트 길이에서 어떻게 적용되는지 한 화면에서 확인할 수 있음 ScaledMetric를 사용하여 동적으로 넓이 조정하기 padding() modifier를 사용하여 패딩을 주었을 때, 폰트 사이즈가 달라지면 아래 이미지와 같이 큰 사이즈의 폰트에서는 패딩이 충분하지 않는 경우가 있음 이때 패딩 값을 그냥 키워주면 작은 폰트에서는 패딩이 너무 넓어질 수 있음 @ScaledMetric 프로퍼티 래퍼를 사용하여 .title과 같은 environment’s effective font size에 숫자값을 적용할 수 있음 struct KeywordBubbleDefaultPadding: View { let keyword: String let symbol: String @ScaledMetric(relativeTo: .title) var paddingWidth = 20.5 // &lt;- 여기 var body: some View { Label(keyword, systemImage: symbol) .font(.title) .foregroundColor(.white) .padding(paddingWidth) // &lt;- 여기 // .padding() .background(.green.opacity(0.75), in: Capsule()) } } Layering Content 어떤 컨텐츠를 겹쳐서 (z-axis) 나타낼 때, ZStack{}/.overlay()/.background()을 사용 ZStack 다른 뷰들과 상관 없이, 사용 가능한 공간에 따라 뷰의 사이즈를 정함 다른 컨텐츠의 사이즈와 관련하여 뷰의 사이즈를 조정하고 싶다면 overlay와 background를 사용하면 됨 Image() 뷰 이니셜라이저는 기본적으로 이미지의 원래 사이즈로 이미지를 가져옴 resizable() 모더파이어와 scaledToFit() 같은 모더파이어를 사용하여 이미지 사이즈를 조정할 수 있음 .clipShape(RoundedRectangle(cornerRadius: 10.0, style: .continuous)) 을 사용하여 뷰의 위치나 크기를 변경하지 않고 corner radius를 설정할 수 있음"
  },"/til/2023-04-29-VerticalTabView.html": {
    "title": "Vertical TabView in SwiftUI",
    "keywords": "TIL",
    "url": "/til/2023-04-29-VerticalTabView.html",
    "body": "import SwiftUI struct ContentView: View { var body: some View { GeometryReader { proxy in TabView { ForEach(0..&lt;3, id: \\.self) { i in Image(\"img_\\(i + 1)\") .resizable() .scaledToFill() .rotationEffect(.degrees(-90)) // 1 .frame( width: proxy.size.width, height: proxy.size.height ) // 2 } } .frame( width: proxy.size.height, // Height &amp; width swap height: proxy.size.width ) // 3 .rotationEffect(.degrees(90), anchor: .topLeading) // 4 .offset(x: proxy.size.width) // 5 .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never)) } } } 👉🏻 참고한 글 .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never)) SwiftUI의 PageTabViewStyle은 기본적으로 수평으로 넘길 수 있는 paged scrolling 탭뷰입니다. 페이지를 넘기는 것과 같은 효과를 줄 수 있는데요. 위 코드와 같이, rotationEffect와 GeometryReader를 사용하여 수직으로 넘어가는 탭뷰를 만들 수 있습니다. // 1 : rotationEffect를 사용하여 왼쪽으로 90도 이미지를 로테이션 시켜줍니다. 현재 탭뷰 안의 이미지는 아래와 같이 살짝 커졌지만 가운데 정렬된 상태로 나타납니다. // 2: 이때 width / height는 누워있는 이미지와 같이 width가 더 큰 직사각형 형태로 존재합니다. // 3: 여기서 TabView의 frame을 정의하는데, height와 width를 바꿔줍니다. 그러면 width가 heigt보다 작은 세로로 기다란 모양의 직사각형 frame이 되겠죠? // 4 : anchor는 어느 꼭지점을 기준으로 로테이트 할 지 정할 때 사용하는데 .topLeading을 기준으로 90도 로테이트 했으므로 화면에는 이미지가 보여지지 않게 됩니다. 로테이트 하면서 화면 밖에 위치하게 되는데요. // 5 : 그래서 offset에 x 값을 현재 width만큼 주어서 오른쪽으로 이동시킵니다. 여기까지하면, 화면에 수직으로 이동하는 페이징 탭뷰가 맨 위에 있는 영상처럼 잘 나타나게 됩니다. 그런데 LazyVStack 안에 다른 뷰와 함께 탭뷰를 화면에 보이려고 하면 문제가 생기는데요. LazyVStack은 모든 아이템을 먼저 그리는게 아니라 필요할 때 아이템을 렌더링 하기 떄문에 기존의. VStack과는 다른 레이아웃 룰을 가지고 있습니다. 그래서 높이가 10 정도 되는 뷰만 그려주게 됩니다. 일단 VStack으로 교체하면 이 문제는 해결할 수 있습니다."
  },"/til/2023-01-17-Quake.html": {
    "title": "앱 Earthquakes 튜토리얼을 따라가며 정리",
    "keywords": "TIL",
    "url": "/til/2023-01-17-Quake.html",
    "body": "Earthquakes app tutorial 이 글은 위의 apple developer tutorial을 따라가며 정리한 내용입니다. Error /decoding-structured-json/Decode earthquake data/step 8 Swift에서는 Error 프로토콜을 따르는 타입을 사용하여 에러를 나타냅니다. Error 프로토콜은 에러를 핸들링하기 위해 사용되는 타입이라는 것을 나타낼 뿐 아무런 내용이 없습니다. 요구사항도 없습니다. 그래서 커스텀 타입에 자유롭게 사용할 수 있습니다. enum QuakeError: Error { case missingData } extension QuakeError: LocalizedError { var errorDescription: String? { switch self { case .missingData: return NSLocalizedString(\"Found and will discard a quake missing a valid code, magnitude, place, or time.\", comment: \"\") } } } 위 QuakeError enumeration은 case missingData를 가지는데 LocalizedError 프로토콜을 따르는 extension을 작성하여, QuakeError.missingData로 에러가 던져질 경우 “code, maginitude, place, time 중 없는 데이터가 있어 정상적으로 코드가 작동하지 않았다.”는 메세지를 표출할 것입니다. // Quake struct라는 설계도를 사용하여 디코딩하는 인스턴스를 생성하기 위해 from decoder:_를 인자로 가지는 init 사용 // throws function, try, try?를 사용하여 디코딩 과정 중 에러 발생 시 nil을 반환하도록 처리함 init(from decoder: Decoder) throws { let values = try decoder.container(keyedBy: CodingKeys.self) let rawMagnitude = try? values.decode(Double.self, forKey: .magitude) let rawPlace = try? values.decode(String.self, forKey: .place) let rawTime = try? values.decode(Date.self, forKey: .time) let rawCode = try? values.decode(String.self, forKey: .code) let rawDetail = try? values.decode(URL.self, forKey: .detail) // try? 가 사용된 곳에서 에러가 발생하지 않으면 옵셔널 값이 반환되므로 해당 값을 unwrapping 함 guard let magnitude = rawMagnitude, let place = rawPlace, let time = rawTime, let code = rawCode, let detail = rawDetail else { throw QuakeError.missingData } 위 예시의 가장 아래쪽에 있는 else 구문에서 throw 키워드를 사용하여 에러를 던졌습니다. magnitude, place, time, code, detail 중 데이터가 없는 것이 있을 때 QuakeError.missingData 에러가 던져집니다. Experiment /decoding-structured-json/Decoding structured JSON/test the decoder 쓰나미 경보를 푸시 알림으로 보내려 하는 상황 튜토리얼 내용을 참고하여 쓰나미 관련 데이터를 디코딩해보기 USGS 사이트에서 쓰나미의 데이터 타입을 찾음 -&gt; Integer Quake 스트럭처에 tsunami 프로퍼티 추가 struct Quake: Identifiable { let magnitude: Double let place: String let time: Date let code: String let detail: URL let tsunami: Int } 키 값으로 사용되는 CodingKeys enum에 tsunami일 경우를 추가 private enum CodingKeys: String, CodingKey { case magnitude = \"mag\" case place case time case code case detail case tsunami } 생성자에 필요한 코드 추가 init(from decoder: Decoder) throws { let values = try decoder.container(keyedBy: CodingKeys.self) let rawMagnitude = try? values.decode(Double.self, forKey: .magitude) let rawPlace = try? values.decode(String.self, forKey: .place) let rawTime = try? values.decode(Date.self, forKey: .time) let rawCode = try? values.decode(String.self, forKey: .code) let rawDetail = try? values.decode(URL.self, forKey: .detail) let rawTsunami = try? values.decode(Int.self, forKey: .tsunami) // try? 가 사용된 곳에서 에러가 발생하지 않으면 옵셔널 값이 반환되므로 해당 값을 unwrapping 함 guard let magnitude = rawMagnitude, let place = rawPlace, let time = rawTime, let code = rawCode, let detail = rawDetail, let tsunami = rawTsunami else { throw QuakeError.missingData } self.magnitude = magnitude self.place = place self.time = time self.code = code self.detail = detail self.tsunami = tsunami } 현재 테스트 데이터의 값인 0과 같은지 테스트를 통해 확인 import XCTest @testable import FollwingEarthquake class FollwingEarthquakeTests: XCTestCase { func testGeoJSONDecoderDecodesQuake() throws { let decoder = JSONDecoder() decoder.dateDecodingStrategy = .millisecondsSince1970 let quake = try decoder.decode(Quake.self, from: testFeature_nc73649170) XCTAssertEqual(quake.code, \"73649170\") let expectedSeconds = TimeInterval(1636129710550) / 1000 let decodedSeconds = quake.time.timeIntervalSince1970 XCTAssertEqual(expectedSeconds, decodedSeconds, accuracy: 0.00001) XCTAssertEqual(quake.tsunami, 0) // 테스트 통과 } } private(set) struct GeoJSON { private(set) var quakes:[Quake] = [] } private(set) modifier가 사용된 배열 quakes는 GeoJSON 스트럭쳐 안에있는 코드에서만 수정 가능합니다. GeoJSON 스트럭처 바깥에서 작성된 코드에서는 quakes의 값을 읽는 것만 가능합니다. structuredJSON USGS의 지진 정보는 structuredJSON 형태로 제공됩니다. 필요한 정보인 latitude / longitude를 얻기 위해 각 structure를 정의합니다. Products 타입을 사용하여 RootProperties 타입 안에 products를 정의하고 Origin 타입을 사용하여 Products 타입 안에 origin 을 정의하는 것과 같은 방법으로 이미지 속 GeoJSON 계층을 모델링합니다. var latitude: Double { properties.products.origin.first!.properties.latitude } var longitude: Double { properties.products.origin.first!.properties.longitude } 모델링한 스트럭처를 이용하여 위와 같이 latitude, longitude 정보를 계산합니다. 루트 프로퍼티로부터 한 계층씩 내려가며 최종적으로 latitude와 longitude를 계산하는 방식이 인상깊었습니다. CodingKey enum private enum CodingKeys: String, CodingKey { case magnitude = \"mag\" case place case time case code case detail case tsunami } 위 예시의 nested coding keys enumeration은 case magnitude = “mag” 값을 가지고 있습니다. place, time, code, detail, tsunami는 GeoJSON 객체에서 같은 이름을 키값으로 사용하고 있고, magnitude는 GeoJSON 객체에서 “mag”를 키값으로 가집니다. init(from decoder: Decoder) throws { let values = try decoder.container(keyedBy: CodingKeys.self) let rawMagnitude = try? values.decode(Double.self, forKey: .magnitude) let rawPlace = try? values.decode(String.self, forKey: .place) let rawTime = try? values.decode(Date.self, forKey: .time) let rawCode = try? values.decode(String.self, forKey: .code) let rawDetail = try? values.decode(URL.self, forKey: .detail) let rawTsunami = try? values.decode(Int.self, forKey: .tsunami) ... } 디코딩하는 생성자 함수에서 magnitude를 키값으로 사용한 것을 확인할 수 있습니다. CodingKeys enum의 케이스 이름은 Quake struct의 프로퍼티를 나타냅니다. JSON 객체의 키 값과 이름이 같은 경우는 case 이름만 작성 / 다른 경우는 case magnitude = “mag”와 같이 작성합니다. Existential Types Building a network test client Earthquakes 앱은 network client를 사용하여 원격 서버에서 JSON 데이터를 가져옵니다. network client의 동작을 테스트하기 위해, 제네릭 / existential 타입을 사용하여 network client를 재사용 가능하도록 만들 것입니다. Existentnial type은 any 키워드를 앞에 붙여 사용할 수 있음 lazy는 let과 함께 사용할 수 없음. var와 함께 사용. 제네릭 / existential 타입 비교하기 import Foundation protocol Pollinator { // 꽃가루를 옮기는 기능을 하는 프로토콜 // 이 프로토콜을 따르는 struct는 꽃가루를 '파라미터'식물로부터 옮기는 동작을 수행함. func pollinate(_ plant: String) } struct Hummingbird: Pollinator { // Hummingbird 스트럭처는 Pollinator 프로토콜을 따르므로 아래 함수를 실행해야 함. func pollinate(_ plant: String) { print(\"허밍버드가 부리로 \\(plant)로부터 꽃가루를 옮김.\") } } struct Insect: Pollinator { // Insect 스트럭처도 마찬가지로 Pollinator 프로토콜을 따르므로 아래 함수를 실행해야 함. func pollinate(_ plant: String) { print(\"곤충이 다리에 꽃가루를 묻혀 \\(plant)로부터 꽃가루를 옮김.\") } } // Hummingbird와 Inset는 Pollinator 프로토콜을 따르므로 '꽃가루를 옮기는 기능'을 수행하는 스트럭처라는 것을 알 수 있음. let speedy = Hummingbird() let busyBee = Insect() // 각 스트럭처를 인스턴스화하여 실제로 pollinate 함수를 동작시킴. speedy.pollinate(\"해바라기\") busyBee.pollinate(\"프리지아\") // 꽃가루를 옮기는 기능을 하는 함수를 작성하려고 하는데... // 옮기는 주체가 Pollinator 타입을 따르는 것은 무엇이든 될 수 있는 함수를 작성하려고 함. func pollinate&lt;T: Pollinator&gt;(_ plants: [String], with pollinator: T) { // &lt;T: Pollinator&gt; 을 작성하여 Pollinator 프로토콜을 따르는 T라는 타입을 함수에서 사용할 것이라는 것을 알려줌. for plant in plants { // 매개변수로 받은 pollinator는 Pollinator 프로토콜을 따르므로 pollinate 함수를 실행함. // pollinator의 타입은 T, T는 Pollinator라는 프로토콜을 따르는 모든 타입. 여기서는 Hummingbird와 Insect 타입의 객체가 pollinator로 사용될 수 있음. pollinator.pollinate(plant) } } pollinate([\"백합\", \"수국\"], with: speedy) // 실행 결과: 허밍버드가 부리로 백합로부터 꽃가루를 옮김. / 허밍버드가 부리로 수국로부터 꽃가루를 옮김. pollinate([\"들꽃\"], with: busyBee) // 실행 결과 : 곤충이 다리에 꽃가루를 묻혀 들꽃로부터 꽃가루를 옮김. // * 하나의 함수에서 다른 타입의 객체를 매개변수로 사용할 수 있게 됨. // any Pollinator 타입을 따르는 변수를 정의 -&gt; any 키워드는 any Pollinator가 existential 타입이라는 것을 의미한다. var anotherPollinator: any Pollinator = Hummingbird() anotherPollinator.pollinate(\"튤립\") // anotherPollinator는 변수이므로 Pollinator 프로토콜을 따르는 타입의 인스턴스를 할당 받을 수 있음. anotherPollinator = Insect() anotherPollinator.pollinate(\"옥수수\") // 아래 함수는 existential 타입의 매개변수를 사용하여 작성됨 func pollinate2(_ plants: [String], with pollinator: any Pollinator) { for plant in plants { pollinator.pollinate(plant) } } Swift는 제네릭 함수를 호출 할 때는 static dispatch를 사용하여 함수 호출을 최적화 하지만, existential 타입을 포함한 함수를 호출할 경우 dynamic dispatch를 사용함. 이때 더 많은 메모리를 필요로 하기 때문에 제네릭 매개변수를 사용한 함수 호출보다 조금 덜 효율적이게 됨. import Foundation class QuakeClient { private let feedURL = URL(string: \"https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_day.geojson\")! //computed porperty의 타입이 있고 milliseconds로 변경하기 위해 이렇게 사용한건가? //date decoding strategy를 변경하기 위해서 anonymous 클로저를 사용해서 init 함 private lazy var decoder: JSONDecoder = { let aDecoder = JSONDecoder() aDecoder.dateDecodingStrategy = .millisecondsSince1970 return aDecoder }() //feedURL은 리터럴 스트링 값을 가지고 있고, decoder는 클로저를 사용하여 이니셜라이징함 //downloader 이니셜라이징하여 값 설정 //Existential value가 사용되는 부분 private let downloader: any HTTPDataDownloader //이니셜라이징 중 파라미터로 통과된 downloader(HTTPDataDownloader 프로토콜을 따르는 any type)가 //QuakeClient의 downloader로 사용됨 init(downloader: any HTTPDataDownloader) { self.downloader = downloader } } quakes 배열을 비동기식으로 가져오고, 가져오는 과정에서 에러가 있을 수 있기 때문에 async, throws 키워드를 사용. property에 async와 throws를 사용하려면 get syntax를 사용해야 함 var quakes: [Quake] { get async throws{ //data를 서버로부터 다운로드 let data = try await downloader.httpData(from: feedURL) //다운로드한 데이터를 디코딩 let allQuakes = try decoder.decode(GeoJSON.self, from: data) //GeoJSON 스트럭처 안에 지진 정보를 배열 형태로 담는 quakes return allQuakes.quakes } } URL 사용하여 데이터 가져오기 URLSession의 인스턴스 메서드인 data를 사용하여 데이터를 가져오려고 함 커스텀 프로토콜인 HTTPDataDownloader를 생성 protocol HTTPDataDownloader { func httpData(from: URL) async throws -&gt; Data } URLSession에 extension을 작성하여 위 커스텀 프로토콜을 따르도록 함 httpData(from:_) 함수의 바디 부분에 URLSession의 인스턴스 메서드인 data를 사용하여 네트워크 연결을 통해 데이터를 가져옴 Preview Content 폴더로 test data 파일을 옮기면 SwiftUI 프리뷰와 유닛 테스트 둘 다에서 데이터를 사용할 수 있음 Building a network test client 네트워크 클라이언트를 만들어 Quake 구조 정보를 요청. 네트워크 클라이언트는 네트워크 요청을 하고 JSON 데이터를 받아오고 받아온 데이터를 커스텀 타입인 Quake structure 타입의 요소를 가진 배열로 decoding하는 역할을 함. Add the map view MapKit 프레임워크를 사용하여 지진이 발생한 곳을 지도로 보여주려고 함. import MapKit // 1 struct QuakeDetailMap: View { @State private var region = MKCoordinateRegion() // 2 var body: some View { Map(coordinateRegion: $region) // 3 .onAppear { // 4 withAnimation { region.center = CLLocationCoordinate2D(latitude: -30.0, longitude: 130.0) region.span = MKCoordinateSpan(latitudeDelta: 50, longitudeDelta: 70) } } } } 맵킷 프레임워크 추가 맵이 보여줄 지역을 담은 state property 바디 프로퍼티 부분에 맵뷰를 추가하여 뷰에 지도 뿌리기 onAppear{} 사용하여 맵뷰가 열릴 때 특정 지역이 보이도록 함. 프리뷰에서 핀치 제스처 하는 방법 - 마우스 클릭하고 옵션 키 누르기 디테일에 추가할 맵뷰를 파일로 따로 생성한 경우, 디테일 뷰의 프리뷰에서 맵뷰를 확인할 수 있게 되면 프리뷰 자체를 삭제해도 됨. (그동안은 프리뷰 부분을 유지해야겠다고만 생각해서 추가 작업이 필요했음) region.center = CLLocationCoordinate2D(latitude: 35.0, longitude: 127.0) 값을 수정하여 한국이 나타나도록 해봄 Managing structured concurrency Fetching multiple URLs → 현재 Earthquakes 앱의 클라이언트는 지진의 정보 목록을 가져오기 위해서 하나의 요청을 보내고 있음. 이제 클라이언트가 concurrency 기능을 사용하여 여러개의 네트워크 요청을 동시에 보내도록 수정하려고 함. 비동기 함수와 비동기 속성을 사용해서 네트워크 요청에 대한 값을 가져오는 작업이 실행되는 동안 잠깐 해당 부분에 실행을 멈춤. 그동안 다른 작업이 먼저 진행됨. let quakes: [Quake] = try await quakeClient.quakes 위 코드에서는 비동기 프로퍼티가 지진의 목록을 가져옴. (비동기 속서이기 때문에, 정보를 가져올때까지 기다림.) func quakeLocation(from url: URL) -&gt; QuakeLocation 위 코드에서는 각 지진의 디테일 정보 중 위치 정보를 가져옴. 이 함수를 비동기, 병렬 방식으로 호출하여 동시에 여러개의 네트워크 요청을 보낼 수 있도록 함. let quakes: [Quake] = try await quakeClient.quakes var locations: [QuakeLocation] = [] for quake in quakes { let location = await quakeClient.quakeLocation(from: quake.url) location.append(location) } 위 코드를 보면, 가져온 지진 정보 마다 가지고 있는 위치 정보 url을 사용하여 위치 정보를 얻어오고, 그 정보를 locations 배열에 추가함. for loop 안에 작성된 quakeClient.quakeLocation(from: quake.url) 함수는 각 반복마다 quakeLocation() 함수가 결과 값을 가져올동안 중단되고, 다시 실행되면 다음 suspension point(quakeLocation()이 다시 실행되는 곳)까지 실행됨. 비동기 함수이지만 순차적으로 진행되게 됨. 이것을 동시에 실행되도록 해야 함. Task Group 이때 사용할 수 있는 것이 테스크 그룸. 테스크 그룹을 사용하면 많은 테스크를 동시에 실행할 수 있음. 시스템은 병렬 쓰레드를 사용하여 테스크를 동시에 실행함. -withTaskGroup() -withThrowingTaskGroup() 위 두가지 함수를 사용하여 테스크 그룹을 사용할 수 있는데, 여기서는 throwing 함수를 사용하기 때문에 withThrowingTaskGroupo()을 사용함."
  }}
