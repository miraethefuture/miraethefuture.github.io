{"/pages/about/": {
    "title": "About",
    "keywords": "Jekyll",
    "url": "/pages/about/",
    "body": "This is an about page."
  },"/pages/contact/": {
    "title": "Contact",
    "keywords": "",
    "url": "/pages/contact/",
    "body": "📧 mirae2thefuture@gmail.com 🐈‍⬛ https://github.com/miraethefuture"
  },"/til/2023-01-17-Quake.html": {
    "title": "앱 Earthquakes 튜토리얼을 따라가며 정리",
    "keywords": "TIL",
    "url": "/til/2023-01-17-Quake.html",
    "body": "Earthquakes app tutorial 이 글은 위의 apple developer tutorial을 따라가며 정리한 내용입니다. Error /decoding-structured-json/Decode earthquake data/step 8 Swift에서는 Error 프로토콜을 따르는 타입을 사용하여 에러를 나타냅니다. Error 프로토콜은 에러를 핸들링하기 위해 사용되는 타입이라는 것을 나타낼 뿐 아무런 내용이 없습니다. 요구사항도 없습니다. 그래서 커스텀 타입에 자유롭게 사용할 수 있습니다. enum QuakeError: Error { case missingData } extension QuakeError: LocalizedError { var errorDescription: String? { switch self { case .missingData: return NSLocalizedString(\"Found and will discard a quake missing a valid code, magnitude, place, or time.\", comment: \"\") } } } 위 QuakeError enumeration은 case missingData를 가지는데 LocalizedError 프로토콜을 따르는 extension을 작성하여, QuakeError.missingData로 에러가 던져질 경우 “code, maginitude, place, time 중 없는 데이터가 있어 정상적으로 코드가 작동하지 않았다”는 메세지를 표출할 것입니다. // Quake struct라는 설계도를 사용하여 디코딩하는 인스턴스를 생성하기 위해 from decoder:_를 인자로 가지는 init 사용 // throws function, try, try?를 사용하여 디코딩 과정 중 에러 발생 시 nil을 반환하도록 처리함 init(from decoder: Decoder) throws { let values = try decoder.container(keyedBy: CodingKeys.self) let rawMagnitude = try? values.decode(Double.self, forKey: .magitude) let rawPlace = try? values.decode(String.self, forKey: .place) let rawTime = try? values.decode(Date.self, forKey: .time) let rawCode = try? values.decode(String.self, forKey: .code) let rawDetail = try? values.decode(URL.self, forKey: .detail) // try? 가 사용된 곳에서 에러가 발생하지 않으면 옵셔널 값이 반환되므로 해당 값을 unwrapping 함 guard let magnitude = rawMagnitude, let place = rawPlace, let time = rawTime, let code = rawCode, let detail = rawDetail else { throw QuakeError.missingData } 위 예시의 가장 아래쪽에 있는 else 구문에서 throw 키워드를 사용하여 에러를 던졌습니다. magnitude, place, time, code, detail 중 데이터가 없는 것이 있을 때 QuakeError.missingData 에러가 던져집니다. Experiment /decoding-structured-json/Decoding structured JSON/test the decoder 쓰나미 경보를 푸시 알림으로 보내려 하는 상황 튜토리얼 내용을 참고하여 쓰나미 관련 데이터를 디코딩해보기 USGS 사이트에서 쓰나미의 데이터 타입을 찾음 -&gt; Integer Quake 스트럭처에 tsunami 프로퍼티 추가 struct Quake: Identifiable { let magnitude: Double let place: String let time: Date let code: String let detail: URL let tsunami: Int } 키 값으로 사용되는 CodingKeys enum에 tsunami일 경우를 추가 private enum CodingKeys: String, CodingKey { case magnitude = \"mag\" case place case time case code case detail case tsunami } 생성자에 필요한 코드 추가 init(from decoder: Decoder) throws { let values = try decoder.container(keyedBy: CodingKeys.self) let rawMagnitude = try? values.decode(Double.self, forKey: .magitude) let rawPlace = try? values.decode(String.self, forKey: .place) let rawTime = try? values.decode(Date.self, forKey: .time) let rawCode = try? values.decode(String.self, forKey: .code) let rawDetail = try? values.decode(URL.self, forKey: .detail) let rawTsunami = try? values.decode(Int.self, forKey: .tsunami) // try? 가 사용된 곳에서 에러가 발생하지 않으면 옵셔널 값이 반환되므로 해당 값을 unwrapping 함 guard let magnitude = rawMagnitude, let place = rawPlace, let time = rawTime, let code = rawCode, let detail = rawDetail, let tsunami = rawTsunami else { throw QuakeError.missingData } self.magnitude = magnitude self.place = place self.time = time self.code = code self.detail = detail self.tsunami = tsunami } 현재 테스트 데이터의 값인 0과 같은지 테스트를 통해 확인 import XCTest @testable import FollwingEarthquake class FollwingEarthquakeTests: XCTestCase { func testGeoJSONDecoderDecodesQuake() throws { let decoder = JSONDecoder() decoder.dateDecodingStrategy = .millisecondsSince1970 let quake = try decoder.decode(Quake.self, from: testFeature_nc73649170) XCTAssertEqual(quake.code, \"73649170\") let expectedSeconds = TimeInterval(1636129710550) / 1000 let decodedSeconds = quake.time.timeIntervalSince1970 XCTAssertEqual(expectedSeconds, decodedSeconds, accuracy: 0.00001) XCTAssertEqual(quake.tsunami, 0) // 테스트 통과 } } private(set) struct GeoJSON { private(set) var quakes:[Quake] = [] } private(set) modifier가 사용된 배열 quakes는 GeoJSON 스트럭쳐 안에있는 코드에서만 수정 가능합니다. GeoJSON 스트럭처 바깥에서 작성된 코드에서는 quakes의 값을 읽는 것만 가능합니다. structuredJSON USGS의 지진 정보는 structuredJSON 형태로 제공됩니다. 필요한 정보인 latitude / longitude를 얻기 위해 각 structure를 정의합니다. Products 타입을 사용하여 RootProperties 타입 안에 products를 정의하고 Origin 타입을 사용하여 Products 타입 안에 origin 을 정의하는 것과 같은 방법으로 이미지 속 GeoJSON 계층을 모델링합니다. var latitude: Double { properties.products.origin.first!.properties.latitude } var longitude: Double { properties.products.origin.first!.properties.longitude } 모델링한 스트럭처를 이용하여 위와 같이 latitude, longitude 정보를 계산합니다. 루트 프로퍼티로부터 한 계층씩 내려가며 최종적으로 latitude와 longitude를 계산하는 방식이 인상깊었습니다. CodingKey enum private enum CodingKeys: String, CodingKey { case magnitude = \"mag\" case place case time case code case detail case tsunami } 위 예시의 nested coding keys enumeration은 case magnitude = “mag” 값을 가지고 있습니다. place, time, code, detail, tsunami는 GeoJSON 객체에서 같은 이름을 키값으로 사용하고 있고, magnitude는 GeoJSON 객체에서 “mag”를 키값으로 가집니다. init(from decoder: Decoder) throws { let values = try decoder.container(keyedBy: CodingKeys.self) let rawMagnitude = try? values.decode(Double.self, forKey: .magnitude) let rawPlace = try? values.decode(String.self, forKey: .place) let rawTime = try? values.decode(Date.self, forKey: .time) let rawCode = try? values.decode(String.self, forKey: .code) let rawDetail = try? values.decode(URL.self, forKey: .detail) let rawTsunami = try? values.decode(Int.self, forKey: .tsunami) ... } 디코딩하는 생성자 함수에서 magnitude를 키값으로 사용한 것을 확인할 수 있습니다. CodingKeys enum의 케이스 이름은 Quake struct의 프로퍼티를 나타냅니다. JSON 객체의 키 값과 이름이 같은 경우는 case 이름만 작성 / 다른 경우는 case magnitude = “mag”와 같이 작성합니다."
  },"/til/2022-11-09-firstLog.html": {
    "title": "(회고) 5개월 0.42년차 개발자의 첫 회고",
    "keywords": "TIL",
    "url": "/til/2022-11-09-firstLog.html",
    "body": "무엇을 했나요? 입사 후 무엇을 했는지 시간 순으로 정리… 인턴 3개월 (OJT 기간) 12주 동안 회사 도메인, 회사에서 사용하고 있는 기술에 대한 교육을 받았습니다. 3주차부터 12주차까지 매주 프레젠테이션 자료를 만들어 발표하는 형식으로 주간 보고를 진행했습니다. (당시에는 매주 프레젠테이션 자료를 만드는게 꽤 힘들었던 기억이 나네요. 매주 주말에 고통받으며(?) 자료를 만들곤 했는데 지금와 회고를 작성하려고 다시 열어보니 기억을 되살리는데 많은 도움이 되네요.) 정직원이 되고… 저는 정직원이 되었고 회사는 새 프로젝트를 시작했습니다. 딱 신입이 해낼 만큼의 일을 받았고 이미 개발되어 있는 페이지의 코드를 참고하여 비슷한 유형의 다른 메뉴 페이지를 개발하고 화면 설계서와 프로그램 설계서 등 필요한 문서작업을 진행했습니다. 기존 솔루션 모바일 앱(iOS)에 두 개의 API를 적용하기도 했습니다. 이때는 솔루션 자체에 대한 이해도도 높지 않았고 코드가 Objective-C 로 작성되어 있어서 긴장을 하고 열심히 코드를 읽었던 기억이 납니다. 기본적인 부분을 놓친걸 모르고, 해결 방법을 찾느라 하루를 보내기도 하고 2주 넘게 정상적으로 작동하지 않고 문제의 원인도 알 수 없었던 건은, 알고보니 처음부터 정상 작동하고 있었지만 API 쪽 에러로 정상 작동하지 않는 것처럼 보였던… 일도 있었습니다. 최근 한 달은… 프로젝트에서 맡은 개발 건 중 70% 정도가 마무리되었고, 기존 솔루션 모바일 앱(iOS)에 유지/보수 사항이 있어 처리 중입니다. 주석을 보니 첫 코드가 작성되었을 때가 4-5년 전 정도인 것 같습니다. 그래서 어떤 기능을 계속해서 사용하기 위해, 또는 더 발전된, 편리한 기능을 사용하기 위해 기존에 사용된 라이브러리나, 메서드 등을 교체해야 하는 상황이 생기고 있습니다. 현재 작업중인 기능은 사진 라이브러리에서 여러개의 이미지를 선택하며 한번에 추가할 수 있도록하는 것입니다. (기존 앱은 하나의 이미지씩 추가해야했음.) 어떤 기술을 사용했나요? 언어, 프레임워크, IDE 등.. 가장 최근에는 자사 솔루션 모바일 앱 (iOS)에 추가해야 할 기능이 서너개 있어서 IDE는 Xcode를 가장 많이 사용하고 있습니다. 새로운 기능 두개를 Swift로 작성한 뒤 기존 Objective-C 프로젝트에서 사용할 수 있도록 연결해두어 Obejctive-C 다음으로 많이 사용한 언어는 Swift가 되겠네요. 회사에 들어와서 지금까지 가장 많이 본 코드는 C#과 ASP.NET, HTMl, Javascript 로 작성된 웹단 코드입니다. 기능을 수정하고 추가해보았지만 일로써, 바쁘게 기능이 돌아가도록 하느라 바빠 기본적인 문법 공부는 하지 못한게 아쉽습니다. 느낀점 느낀점은 어떤 것이든 적어 봅시다! 목적없이 공부했던 것들이 생각보다 큰 도움이 된다. Swift를 처음 공부하기 시작했을 때 (2022년 3월) 문서를 많이 읽었습니다. 무작정 영어 문서를 번역하면서 읽었죠. 그러다 일을 하게 되었고, 그때 잘 이해하지 못하면서 읽었던 것들이 꽤 많은 도움이 되었습니다. 특히 검색 키워드를 정할 때 도움이 많이 됩니다. 예를 들어, 함수를 통해 함수 바깥 범위에 있는 변수의 값을 변경하려 했을 때 Swift 문서에서 봤던 in-out 파라미터를 떠올렸고, ‘in-out parameter for Objective-C’ 라고 검색하여 What’s Objective-C’s equivalent of Swift’s inout Parameters? 와 같은 결과를 빨리 찾을 수 있었습니다. ‘개발’…! 적성에 맞는 것 같다. 입사한지 6개월도 안된 이 시점에 개발자라는 직업이 적성에 맞는다고 말하는 것은 조금 섣부른 판단일 수도 있겠지만, 생각보다 더 적성에 맞는 것 같습니다. 문제를 맞닥뜨리고 그것을 해결해 나가는 것이 생각보다 고통스럽지 않고(?) 재미있는 것 같아요. 원래 컴퓨터나 전자기기를 다루는 것을 좋아하기도 하고, 집중해서 무언가를 하는 것을 좋아하는 편이어서 더 잘 맞게 느껴지는 것 같습니다. 또, 언젠가는 여러 나라에서 일하면서 살아보고 싶은데 그런 내 목표를 실현시켜 줄 확률이 있는 직업인 것 같아 마음에 듭니다. 영어 공부를 함께 할 수 있는 것도 좋고요…! 가장 재미있었던 순간(?) Importing Swift code to Objective-C project! Swift code를 사용하기 위해서 Obejctive-C 코드로 작성된 프로젝트에 Swift file을 생성했습니다. 그리고 여러가지 과정을 거쳐서 처음 Obejctive-C 파일에서 Swift 클래스에 작성한 메서드를 사용하게 되었을 때, (메서드의 이름 앞글자만 입력했는데 자동완성에 그 메서드의 이름이 나타났을 때!) 신기하고, 신났던 기억이 납니다. 마무리하며 회고를 처음 작성해 보았는데요. 쓰면서 좀 더 많은 기록을 남겨두어야 겠다는 생각이 들었습니다. 어떤 일을 했는지, 어떤 것을 느꼈는지, 무엇을 배웠는지, 뭐가 좋았고 뭐가 싫었는지 생각보다 더 기억이 잘 안나네요. 앞으로는 더 자주 회고를 써야겠다는 생각도 들었습니다. -끝-"
  },"/til/2022-08-14-myBoxes.html": {
    "title": "My Boxes",
    "keywords": "TIL",
    "url": "/til/2022-08-14-myBoxes.html",
    "body": "앱 프로젝트: My Boxes 개인 프로젝트를 시작했습니다. 목표는 9월 안에 1차 완성 후 테스트 플라이트에 등록하기! 하루하루 무엇을 했는지 기록을 남겨봅니다. 9/15 8월 14일 프로젝트 시작 후 그동안 무엇을 했는지 영상으로 보면.. \"어디에 뒀더라... 분명 어디 있는데?\" 위와 같은 생각이 반복되다보니 내가 어떤 물건을, 어디에 가지고 있는지를 목록으로 만들어보고 싶었습니다. 메인 리스트 뷰 / 각 상자 속 아이텝의 리스트 뷰 / 편집뷰를 만든 상태입니다. 아직 편집 화면에서 추가한 아이템이나 변경 사항들이 리스트에 반영되는 곳까지 데이터 플로우를 처리하지 못했습니다. 일단 그것을 먼저해야 할 것 같습니다. 9/19 좀 더 정확하게 이해해보기 Edit 뷰를 만들기 전에 타입 Box 안에 nested 형태로 Data라는 타입을 생성했다. - 타입 Data는 왜 필요했을까? 1) Data에는 Box의 속성 중, 편집 가능하도록 할 속성을 담는다. 2) 사용자가 편집한 내용을 Data의 각 속성에 담는다. 3) 변경사항이 저장되는게 확실해지면 ('확인' 또는 'Done' 버튼을 눌렀을 때...) 4) Data에 담긴 내용을 Box에 업데이트한다. - computed property인 data의 역할은? a. data는 Box 타입의 extension { } 안에서 정의됨 b. data의 리턴 타입은 Data c. Box의 속성값들을 사용하여 Data() 를 리턴 9/25 Done 버튼을 누르면 모달뷰가 내려가고, Box.Data()에 담아두었던 원래 입력되어 있던 데이터 + 변경된 데이터를 Box에 업데이트하여 아이템 리스트에서도 볼 수 있도록 함. 9/28 State 와 binding을 사용하여 데이터가 뷰 사이에서 전달되도록 했지만, 앱을 종료했다 다시 시작하면 모든 데이터가 날라간다. 데이터를 저장하고 가져오는 메서드를 작성해야 한다. 9/30 데이터를 file/Document에 저장하고 가져오는 함수를 따로 작성하고 앱이 열릴 때 데이터를 가져오는 함수 적용 중… 10/2 @Environment 속성에 scenePhase 값을 설정하여 앱이 inactive한 상태로 바뀔 때 사용자가 입력한 데이터를 저장하도록 함. 이제 앱을 종료하고 다시 열어도 그대로 데이터가 저장되어 있는 상태가 되었다. 보관함 리스트를 삭제하는 기능 추가 완료 보관함에 pin 심볼을 다른 것으로 변경하기 기존에 임의로 설정해두었던 배경/글자색을 주석처리하여 기본색으로 설정 태그 심볼 제거 Testing.. 10/6 데이터가 잘 입력되는지 테스트 해봤는데 생각 못한 문제가 있었다. 한번에 많은 데이터를 입력면 목록이 키보드 뒤로 숨는다.. 흠.. 위 목록을 스크롤로 올릴 수 있어서 사용에는 문제가 없지만 좀 더 나은 사용자 경험을 위해서 후에 수정할 목록에 추가! 기능을 좀 더 추가해야 할 것 같아서 목록에 별모양을 추가하는 중.. ‘좋아요’ 버튼 같은 느낌으로! 10/8 튜토리얼을 보고 리스트를 필터링하는 computed property를 바디 바깥 부분에 작성했는데 그럼 바인딩을 사용할 수 없어서 바디 안쪽으로 재작성했다. ‘좋아요’(?) / Favorite 을 표시할 수 있는 기능을 추가해보고 있다. Favorite인지 아닌지 정보를 담을 Bool 타입 속성을 모델 스트럭처에 추가하고 그 속성의 값이 true일 때만 노란색 별이 나타나도록 해주었다. 샘플 데이터 값에 true/false를 입력하여 별이 잘 나타는지 확인했다. 토글을 만들어 On 상태일 때는 favorite 표시가 된 것만 나타나도록 했다. 10/10 바인딩을 사용하여 뷰 안에서 생긴 데이터의 변경사항을 데이터 소스로 전달할 수 있다. 사용자가 입력한 카테고리를 기준으로 나누어 보관함들을 보여주는 뷰를 생성 중. 샘플 데이터에 입력해 주었고, 사용자가 입력하는 부분을 생성해야 함. 10/11 사용자가 입력한 카테고리를 기준으로 나누는 것은 일단 보류. 미리 생성해 둔 카테고리를 이용하여 보관함을 나눠보는 것을 먼저 시도해보려고 한다. 10/12 회사일의 연장..?으로 iOS 프로젝트가 하나 생겨서 잠시 이 프로젝트를 쉽니다. 10/13 위 프로젝트를 안해도 돼서 (하루만에 ㅋㅋㅋㅋ) 다시 이 프로젝트로 돌아옵니다. 10/16 카테고리 기능이 필요할 것 같지 않아서 검색 기능을 먼저 구현해보려고 한다. searchable 모더파이어를 사용해보려고 하는데.. 될까..? 10/17 등록한 모든 아이템을 검색하는 기능을 구현하려고 찾아보니 크게 UIKit 을 사용하는 방법과 SwifUI를 사용하는 방법 두 가지가 있었다. 먼저 SwiftUI의 searchable 모더 파이어를 사용해보기로 했다. 검색 바를 구현하는건 코드 세 줄만 추가하면 되어서 금방했는데 그 후에 과정에서 시간이 좀 들고 있다. (Overlay를 사용해서 검색된 값들과 검색창만 화면에 보여주려고 하는데 Overlay를 어디다가 붙여야 할 지 모르겠음.) 내일까지 구현해보고 안되면 UIKit으로 해봐야겠다. 10/18 어제 searchable 을 사용하여 검색 텍스트 필드 UI를 생성했다. 사용자가 입력을 시작하면 현재 박스 목록 화면을 완전히 가리는 새로운 뷰가 나타나고, 그 뷰에 검색어가 들어간 아이템들이 쭉 나왔으면 좋겠다. 일단 영상에서 보이듯이 검색어를 입력했을 때 현재 목록위로 overlay가 된 투명한(?) 뷰에 입력한 값이 전달되는 것까지 구현하였다. 이제 그 화면에 검색 기능을 가진 리스트를 뽑아내면 될 것 같다. 10/19 전체 앱을 통하는 데이터 흐름을 변경했다. 전체 아이템 목록의 이름(itemName)을 기준으로 키워드와 일치하는 아이템 목록을 만들어서 뿌러주려고 했는데.. 오늘은 실패! 오류는 어떻게든 해결을 해봤는데 키워드를 입력하자 흰 화면이 나타난다… 놉 ㅠ …. 내일 다시 도전해보겠어….! 10/20 var filteredList: [Box.Item] { if !searchText.isEmpty{ return items } else { return items.filter { $0.itemName.localizedCaseInsensitiveContains(searchText) } } } localizedCaseInsensitiveContains(_:) 메서드를 사용해서 대소문자에 상관없이 검색 키워드를 포함한 아이템들의 목록을 만드려고 했는데 처음에 자꾸 오류가 났다. 알고보니 searchText 자리에 값이 nil이면 안되는데 if !searchText.isEmpty처리를 해주지 않았던게 원인이었다. 비어있을 때는 키워드로 필터링되지 않은 전체 아이템이 나타나도록 if문을 작성해 주었다. 이제 검색어를 입력하면 리스트 화면이 나타나긴하지만 키워드와는 관계없이 첫번째 박스에 담긴 아이템이 나타나고, search bar도 사라진다. 해결하자! 10/21 전체 아이템을 가진 리스트를 search bar에 입력된 키워드를 가진 아이템들을 가진 리스트로 필터링 하려고 했는데, 전체 아이템을 잘못 작성한 것 같다. 전체 아이템을 가진 리스트를 먼저 뽑기 10/22 Type ‘() -&gt; ()’ cannot conform to ‘ShapeStyle 위와 같은 에러가 발생해서 해결해 보는 중.. 해결! 검색 기능을 구현하면서 searchbar에 텍스트가 입력되고 검색 중일 때 overlay 를 사용해서 해당 텍스트를 포함한 아이템 리스트가 전체 화면을 가리도록 구현했다. 이 과정에서 사용된 .overlay { } modifier가 문제였다. 10/23 드디어 됐다! 각 박스들의 목록이 있는 메인 화면에서 검색어를 입력하면 그 검색어를 포함한 아이템들만 화면에 보여주는 것 성공,, 일주일동안 성공하지 못했던 요인 스스로 생각하며 분석해보는 시간이 부족했다. searchable 을 사용하여 검색 기능을 구현하는 방법을 엄청 검색했다. 지금 돌이켜 생각해보면 정말 ‘검색만’ 했다. 여러가지 인스턴스 메서드를 사용해보고 사람들이 사용한 여러가지 방법을 적용해봤는데, 안되는 이유는 아이템 전체 목록을 잘못 설정한 것이었다. 아이템의 전체 목록 부터 잘못 불러오고 있었으니 아무리 필터링을 하려고 해도 필터링이 제대로 되지 않았던 것이다. 전체 아이템 리스트를 불러올 방식은 아주 간단한데 그것부터 제대로 하지 않아 며칠을 다른곳에서 이유를 찾으며 시간을 보냈다. 검색 기능 구현이 안되는 이유들을 찾으며 소스를 다시 보니 모호하게 아는 부분이 많다는 것을 꺠달았다. 검색된 아이템을 누르면 아이템 하나의 디테일 뷰로 이동하는 것을 구현해보자. 각 박스 안에서 검색하는 기능도 추가해보자. 10/25 검색된 아이템을 누르면 아이템 하나의 디테일 뷰로 이동하는 것을 구현해보려고 하는데 item 모델에 id와 itemName 속성 딱 두가지만 정의를 해두어서 디테일 뷰에 여러가지 속성들을 나타내려면 모델에 속성을 추가해야 할 것 같다. 10/26 추가할 속성 몇 개 있는가? 해시태그 ( 검색 시 더 넓은 키워드로 찾을 수 있도록 ) notes 보관한 기간 10/27 애플 디벨로퍼 아카데미 지원 애플 디벨로퍼 아카데미 2기 러너를 모집한다고 하여 지원해보려고 한다. 포트폴리오에 프로젝트를 넣었으면 해서 이 프로젝트에 대해 작성해 보려고 한다. 기능을 완성하지 못하더라도 어떤 것들을 배웠고 어떻게 만들어 보았는지 써보자! 10/28 CV/포트폴리오를 주제로 한 설명회를 들었다. 생각보다 더 도움이 많이 되었다. 들었던 내용을 기반으로 조금씩 작성해보고 있다. 각 item의 속성을 추가해보기로 했는데, 그 전에 Navigation Link를 사용하여 아이템을 눌렀을 때 다른 View로 이동하도록 해보고 있다. 일단 해당 아이템이 속하는 박스 뷰로 이동하도록 수정해 보았다. 각 아이템의 개인 속성은 필요할 것 같으면서도 복잡해지는 것 아닐까 하는 생각이 든다. 해시태그 기능은 넣어으면 좋겠어서 그 부분에 대해 생각해 봐야겠다. 10/31 10월의 마지막 날! 박스 뷰에서 별 모양을 누르면 메인 리스트에서 노란색 별이 표출되고 이 별 표시가 있는 목록만 볼 수 있는 토글 버튼이 있는데 “Favorites Only”라는 글씨 대신 별을 추가해주고 버튼 가까이로 위치를 이동시켰다. 박스의 별은 왼쪽 정렬해주어 표시가 되지 않은 상자들과 좀 더 눈에 띄게 달라보이도록 하였다. 11/05 추가하고 싶은 기능 정리 구입 날짜 표시 수량 표시 색 테마 변경 사진 추가 (각 아이템 속성 화면 추가 한다면..) 11/07 각 박스 목록의 뷰 색을 변경할 수 있도록 한 번 해보고 싶다. 11/13 각 박스의 타이틀 볼드 처리. 12/01 12월! 12월이 시작되었고 여전히 회사는 바쁘고 개인적으로도 할 일이 많지만,, 이 프로젝트를 꼭 앱 스토어에 올리겠다는 마음으로 다시 시작! 먼저 각 아이템의 상세 정보를 담는 뷰를 연결해 봐야겠다. 수정할 것 1번 보관함을 생성한 뒤 다시 새 보관함을 생성하면 1번 보관함에 정보가 추가 화면에 나타남. 나타나지 않도록 수정할 것 (현재 앱을 내렸다 올리면 1번 보관함의 정보가 나타나지 않음) -&gt; 수정 완료 처음 보관함 등록할 때 별 표시 되어서 저장되는 것 수정 -&gt; 추가하는 뷰에서 일시적으로 데이터를 저장하는 Data()에 별 표시(좋아요 표시) 속성인 isFavorite의 기본값이 true로 되어있던 것을 false로 변경해줌. 12/11 리스트 안에서 아이템의 위치를 변경해보자. .onMove modifier를 사용해서 간단하게 아이템을 이동시키는 기능을 구현할 수 있었다. .onMove는 ForEach로 생성되는 리스트처럼 ‘동적 리스트’에만 사용할 수 있다. List로 만들어진 리스트는 정적 리스트이기 때문에 사용할 수 없다. 나는 ForEach를 통해 리스트를 만들고 있기 때문에 사용할 수 있었다. .onMove는 두 개의 패러미터를 가진다. indexSet과 Int형의 패러미터(위 이미지에서는 index)이다. 기본적으로 .onMove modifier는 edit 버튼을 생성하고 이 edit 버튼을 눌러야 리스트를 옮길 수 있도록 하는 기능이 활성화되는데 나는 이미 Edit 버튼을 사용하여 모달뷰를 띄우고 있기 때문에 리스트에서 이 기능을 확인할 수 없었다. edit 버튼을 누르면 editing 중인 상태로 전환되고, 이 상태에서 아이템의 순서를 변경하는 기능이 활성화되므로 항상 editing 중인 상태로 바꾸어 해결하였다. .onMove { (IndexSet, index) in box.items.move(fromOffsets: IndexSet, toOffset: index) } .environment(\\.editMode, Binding.constant(EditMode.active)) .onMove modifier가 어떻게 동작하는지 궁금하다."
  }}
