var store = [{
        "title": "만들어 가면서 배우는 JAVA 플레이그라운드(구구단 구현하기 추가미션)",
        "excerpt":"아래 모든 내용은 인프런 강의 ‘만들어 가면서 배우는 JAVA 플레이그라운드’의 내용입니다.   추가 미션 문제      사용자에게 입력 값을 받아서 구구단을 출력   입력값이 11 이라면 2 * 1 부터 2 * 11 까지 ~ 11 * 1 부터 11 * 11 까지 한번에 출력   현재 상황: 11을 입력해서 11 * 1 ~ 11 *11 은 출력할 수 있으나 2,3,4,5,6,7,8,9,10,11 단을 한꺼번에 출력하는 것이 안됨.   import java.util.Scanner;  public class Finalmission {     public static void main(String[] args) {         System.out.println(\"출력할 구구단의 값은? :\");         Scanner scanner = new Scanner(System.in);         int number = scanner.nextInt();          int[] result = new int[number];         for(int j = 2; j &lt;= number; j ++) {         \tfor(int i = 0; i &lt; result.length; i++) {             \tresult[i] = j * (i + 1);             \tSystem.out.println(result[i]);              }         }     } }  ","categories": [],
        "tags": ["code","Java"],
        "url": "/posts/gugudan/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "영단어 정리",
        "excerpt":"  🗂  A      access   to find information, especially on a computer    (주로 컴퓨터에서)정보를 찾는 것      Users can access their voice mail remotely.   whatever thing is accessed by the URL you supply        allow   to make something happen, especially something helpful or useful.    어떤일이 일어나는 것을 가능하게 만들다.        append   to add something to a piece of writing.    글에 어떤 내용을 덧붙이다.      덧붙이다   첨부하다        assign   to give a particular time, value, place etc to something.    특정 시간, 값, 장소등을 어떤 것에게 배정하다. (할당 / 대입하다.)      How much time have you assigned for the meeting?   첨부하다        automate   to start using computers or machines to do a job, rather than people    어떤 일을 하기 위해 사람 대신 컴퓨터나 기계를 사용하다.      Cash machines automates two basic function of a back - deposits and withdrawals.   Build tools are programs that automate the creation of executable applications from source cord.     🗂️  B      bypass   to avoid obeying a rule, system, or someone in an official position.    규칙, 시스템, 공식적인 자리에 있는 사람에게 복종하는 것을 피하는 것      Francis bypassed his manager and wrote straight to the director.   You can bypass basic setup steps that are already familiar to you.     🗂️  C      configure   to arrange something, especially computer equipment, so that it works with other equipment.    어떤 것을 미리 준비해두다. 특히 다른 도구들과 함께 작동될 수 있도록 컴퓨터 도구들 준비해두다.      This project is configured to fit the exaples in this tutorial.        compatible   if two pieces of computer equipment of software are compatible, they can be used together, especially when they are made by different companies.     소프트웨어에서 사용되는 도구 두가지가 compatible 하다면, 그것은 두가지가 함께 사용될 수 있다는 것을 의미합니다. (특히, 다른 회사에서 만들어진 두가지 도구 일 때 말이죠.)      Will the software on my PC be compatible with a Mac?      🗂️  D      define   to describe something correctly and thoroughly, and to say what standards limits qualities etc it has that make it different from other things     어떤 것을 명확히 묘사하는 것, 그리고 그것이 다른 것들과는 다른 어떤 기준, 한계 등을 가지고 있는지 말하는 것.      the ability to define clients' needs     🗂️  E      executable   a computer file that can be run as a program    프로그램으로 실행 될 수 있는 파일.   (명사 / 형용사 둘 다 executable)    🗂️  G      goes a long way towards(to)   If you say that something goes a long way towards doing a particular thing, you mean that it is an important factor in achieving that thing.    something 은 a particular thing 을 달성하기 위한 중요한 요소이다.      Implementing the trends will go a long way to building a functional site.   :: 그 트렌드를 구현하는 것은 잘 작동하는 사이트를 만들기 위한 중요한 요소가 될 것이다.    Although not a cure, it goes a long way towards making the patient's life tolerable.   :: 치료법은 아니지만, 그것은 환자의 삶을 견딜 수 있게 만드는데 큰 도움이 된다.      🗣️ goes a long way towards 발음 들어보기   🗂️  I      invoke   to operate a computer program    컴퓨터 프로그램을 작동시키다.      In small projects, developers often manually invoke the build process          instruction   a command given to a computer to carry out a particular operation.    특정한 일을 수행하기 위해 컴퓨터에게 주어진 명령어.      to put a set of instructions into a computer in a form that it can understand and use.     🗂️  M      manually   operated or done by hand or without the help of electricity, computers etc    기계나 전기의 도움 없이 사람으로부터 수행됨.      It would take too long to do a manual search of all the data.   In small projects, developers often manually invoke the build process        metadata   information that describes what is contained in large computer databases, for example who wrote the information, what it is for, and in what form it is stored    큰 컴퓨터 데이타베이스에 무엇이 저장되어 있는지 알려주는 정보이다. 예를 들면 누가 이 정보를 작성했고, 무엇을 위한 것이고, 어떤 형식으로 저장되었는지에 관한 정보를 알려준다.      Spring Boot Annotations is a form of metadata that provides data about a program.        map onto   to match something or have direct relationship with something    어떤 것을 연결하거나 직접적인 관계를 가지는 것.      Spring Boot Annotations is a form of metadata that provides data about a program.     🗂️  P     protocol   an established method for conneting computers so that they can exchange information    컴퓨터들이 서로 정보를 교환할 수 있는 방법        phase   one of the stages of a process of development or change    개발 또는 변화 중인 절차의 한 단계      a new drug that is in the experimental phase   the first phase of renovation should be done by January     🗂️  R      retrieve   to get back information that has been stored in the memory of a computer    큰 컴퓨터 데이타베이스에 무엇이 저장되어 있는지 알려주는 정보이다. 예를 들면 누가 이 정보를 작성했고, 무엇을 위한 것이고, 어떤 형식으로 저장되었는지에 관한 정보를 알려준다.      Spring Boot Annotations is a form of metadata that provides data about a program.     🗂️  T      transfer   to copy recorded information from one system to another   시스템에 기록된 정보를 다른 시스템에 복사하는 것.      Spring Boot Annotations is a form of metadata that provides data about a program.     🗂️ U     underlying cause/principle/problem etc   the cause, idea etc that is the most important, although it is easily not noticed    알아차리기 힘들지만 가장 중요한 원인이나 아이디어.      the underlying causes of her depression      ","categories": ["vocabularies"],
        "tags": ["studying","learning","vocabularies"],
        "url": "/vocab/verb/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "[20220107] Gradle/Build tools/Building/상속",
        "excerpt":"  오늘의 공부는 Gradle 이 무엇인지 알아보며 시작해본다. Gradle 은 웹 애플리케이션을 만들 때 자동으로 자료들을 모아주고 테스트해주고 빌드해주는 소프트웨어다. ‘a build system’ 또는 ‘a build automation tool’ 이라고 하는데 구글링을 해보니 한국말로도 ‘빌드 도구’ 라고 번역되어 있다. 그렇다면 build tool 은 정확히 무엇일까?   Build tools는 작성된 코드를 응용 프로그램으로 만들어주는 프로그램이라고 한다. 작은 규모의 프로젝트에서는 개발자들이 컴퓨터의 도움없이 이 작업을 하곤 하지만 규모가 큰 프로젝트에서는 컴퓨터 프로그램인 build tools가 이런 작업을 행하는게 실용적이다. Gradle이 이 빌드 도구 중 하나인 것이다   Building한다는 것에는 여러가지 세부 단계들이 포함되어 있고 크게 두가지로 단계로 나누어진다.     compiling : 컴파일링은 사람이 작성한 코드를 컴퓨터가 이해하고 사용할 수 있는 형식으로 바꾸는 것        linking : 링킹은 컴파일링 된 파일들을 하나의 실행 가능한 파일로 만들어주는 것               상속(Inheritance)   스프링 부트를 이용한 게시판 만들기에 관심이 생겨서 글들을 읽어보다가 Gradle이 정확히 무엇인지 궁금해졌었고, 개념만 공부했을때는 와닿지 않았던 상속이 어떤 느낌으로 사용되는지 약간 알게 되었다. 그래서 한번 더 상속에 대해 정리해보려 한다.   자바에서 상속은 한 클래스가 다른 클래스의 속성을 취하는 것이다. 상속을 사용하므로써 우리는 이미 있는 어떤 클래스의 메소드와 필드(변수)를 다시 사용할 수 있다. 객체를 재사용할 수 있다는 점에서 상속은 객체 지향 프로그램에서 중요한 규칙이다.   extends means that you are creating a subclass of the basic class you are extending.    ","categories": ["TIL"],
        "tags": ["software","learning","공부 기록"],
        "url": "/til/gradle/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "[20220111] Spring Boot Annotation/REST resources",
        "excerpt":"  Spring Boot Annotation  스프링 부트 애노테이션은 메타 데이터의 한 타입이다. (메타 데이터는 거대한 데이터베이스 속에 무엇이 들어있는지 알려주는 정보인데, 예를 들면 누가 이 정보를 기록했고, 무엇을 위한 정보이고, 어떤 형식으로 저장되었는지를 알려준다.) 애노테이션은 프로그램에 대한 정보를 보충하기 위해 사용되는데 어플리케이션의 일부는 아니다. 작동하는 코드에 직접적인 영향을 미치지 않는다.  컴퓨터가 이해할 수 있는 주석으로 생각하면 되려나?    REST resources  Spring boot 애노테이션 중 @RestController 라는 것이 있었고 이것을 사용하면 RESTful한 web services 를 만들 수 있다라고 하여 REST란 무엇인지 검색해보고 있다.  검색 중 stack overflow 에 What are REST resources? 라는 질문글을 읽어보게 됐는데 질문자의 ‘REST resources에 관한 몇개의 글을 읽어봤지만 글들이 너무 추상적이어서 오히려 전보다 더 헷갈림’이라는 말에 크게 공감했다. 답변자 중 한명은 ‘REST resources에 관한 글들이 추상적인 이유는 REST resource 라는 개념이 추상적이기 때문’이라고 했다.  여러명의 답변을 정리해보자면,     “whatever thing is accessed by the URL you supply”  그게 무엇이든 네가 제공한 URL 로 찾을 수 있는 정보   A resource is anything that’s important enough to be referenced as a thing in itself.  resource 는 ‘어떤 것’이라고 부를 수 있을만한 그 어떤 것이든 될 수 있다.   Data responded back are the resources  요청해서 받은 데이터가 resources 다.   흠… 감이 오는 것 같기도..? 몇개 더 읽어봐야겠다.  ","categories": ["TIL"],
        "tags": ["software","learning","공부 기록"],
        "url": "/til/annoation/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "[20220113] Java Container/Content pane/Classes and Objects",
        "excerpt":"  💭  국비 Java 학원 수업 개강일이 얼마 남지 않았다. 지금까지는 JAVA에 대해 예습해보았고 커리큘럼에 있는 다른 것들도 미리 한번씩 봐두면 좋을 것 같아서 담당자님께 설명 들었던 것을 떠올리며 커리큘럼을 보고 있다. Java GUI에 대해서는 한번도 알아본적이 없는 것 같아서 검색해 보던 중 코드를 작성하며 정리해주신 블로그를 발견했다. 코드와 설명을 적어주셔서 참고하며 공부해보고 있다.   Java Swing 에서 Container 란?  하나의 컨테이너는 여러개의 레이어들을 가지고 있다. 레이어를 \b컨테이너를 덮고 있는 투명한 필름이라고 생각할 수 있다. Java Swing에서 objects를 담기 위해 사용되는 이 레이어를 content pane이라고 한다.      content pane = container 속 layer    Container가 가지고 있는 content pane layer에 objects가 추가된다. getContentPane() 메소드가 컨텐트 페인 레이어를 불러온다. 그러면 objects를 그 안에 추가할 수 있다.   컨텐트 페인을 구글링해보았더니 아래와 같은 사진들이 나온다. pane의 사전적 의미는 창문이나 문에 쓰이는 유리의 한 조각이다. 사전적 의미를 함께 떠올리면 좀 더 이해하기가 쉽다.      Constructor in Java  생성자에 대한 몇개의 강의도 듣고, 생성자를 만들어보기도 했지만 왜 생성자를 사용하는지 궁금하다. (분명히 예전에 강의를 봤는데 기억이 안난다😵;)  생성자(Constructor)는 코드의 집합인데, new 연산자를 통해 클래스 안의 객체의 상태를 초기 설정 하는데 사용되며 메소드와 비슷하다.   Java Classes and Objects  이 페이지를 번역하며 공부  클래스(classes)와 객체(objects)는 자바에서 가장 중요한 개념이다. Java의 모든 것들은 클래스, 그리고 객체와 관련되어있다. attributes, methods도 마찬가지다. 예를 들어보자, 현실 세계에서 자동차는 객체다. 자동차는 색, 무게와 같은 속성(attributes)을 가지고 있다. 또 자동차는 움직이고 멈추는 메소드도 가지고 있다. (메소드를 어떻게 번역하면 좋을까? 기능? 작동방식?) 클래스는 자동차를 만드는 사람이나 회사 또는 청사진으로 비유된다.      Creat an Object     자바에서 객체는 클래스로부터 만들어진다.  public class Main {                 //클래스 이름은 항상 대문자로 시작   int x = 5;    public static void main(String[] args) {     Main myObj = new Main();       // 클래스명 + 오브젝트명 설정 = new 연산자 + 클래스명();     System.out.println(myObj.x);   }  }   Java this Keyword  이 페이지를 번역하며 공부   public class Point {   public int x = 0;   public int y = 0;    //생성자 Constructor   public Point(int a, int b) {     x = a;     y = b;   } }  위의 작성된 코드를 보면, class … (다음에 계속)  public class Point {   public int x = 0;   public int y = 0;    //생성자 Constructor   public Point(int x, int y) {     this.x = x;     this.y = y;   } }  ","categories": ["TIL"],
        "tags": ["software","learning","공부 기록"],
        "url": "/til/javaGui-copy/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Java this Keyword / MySQL 데이터베이스 삭제하기 / ORM",
        "excerpt":"  💭  벌써 1월 14일이라니 시간이 참 빠르다. 오늘은 어제 알아보던 것에 이어서 Java this keyword를 보면서 시작해본다.   Java this Keyword  이 페이지를 번역하며 공부    &lt;Using this with a Field&gt;   this keyword를 사용하는 가장 흔한 이유는 field(필드변수)의 이름이 메소드 패러미터나 생성자 패러미터와 같을 때 덮어씌여지는 것을 방지하기 위해서이다. 아래 두 예제는 이름이 Point 인 클래스를 만드는 두가지 방법을 보여준다.   public class Point {   public int x = 0;   public int y = 0;    //생성자 Constructor   public Point(int a, int b) {     x = a;     y = b;   } }  위의 작성된 코드에서는 fields의 이름이 각각 x, y이고 생성자 패러미터는 각각 a, b 이다. 두가지의 이름이 다르기 때문에 문제가 생기지 않는다.   public class Point {   public int x = 0;   public int y = 0;    //생성자 Constructor   public Point(int x, int y) {     this.x = x;     this.y = y;   } }  하지만 위 코드에서는 fields 의 이름과 생성자 패러미터의 이름이 같다. 이때 fields 앞에 this. 를 붙여주어야 한다.      MySQL 데이터베이스 삭제하기   터미널을 열고 /usr/local/mysql/bin/mysql -u root -p 을 입력해줍니다. 그리고 비밀번호를 입력해줍니다. (내가 기억하려고 써보는 MySQL 실행시키는 방법)  show databases; 를 입력하면 아래 사진처럼 어떤 데이터베이스들이 있는지 보여줍니다. 저는 example 이라는 이름의 데이터베이스를 삭제할거에요.      DROP DATABASE example 을 입력하면 삭제 됩니다.      Java ORM  이 페이지를 번역하며 공부   Java ORM은 Object-Relational Mapping의 약자로 Java objects와 Relational databases 사이에서 데이터를 변환해주는 기술이다.   public class ContactInfo {   int id;   String name;   String email;  }   위 3가지의 필드를 가지고 있는 ContactInfo라는 클래스가 있다고 가정해보자. 그리고 이 정보들을 MySQL 데이터베이스에 저장하고 싶다. 이때 ORM을 이용해서 어플리케이션의 데이터베이스에 객체들을 담을 테이블을 만들 수 있다. 테이블은 contactinfo라는 이름을 가지게 되고 id, name, email 세개의 열(columns)을 가진다.  ","categories": ["TIL"],
        "tags": ["learning","MySQL","Java","this keyword","ORM"],
        "url": "/til/java-continued/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Accessing Data with JPA",
        "excerpt":"  💭  오늘은 많은 자료들을 봤지만 확실히 이해한 것들은 없는 느낌이다.   Accessing Data with JPA  이 페이지를 참고  package com.example.accessingdatajpa;  import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id;  @Entity //Entity annotation : JPA entity 라는 것을 알려줌. public class Customer {    @Id   @GeneratedValue(strategy=GenerationType.AUTO) //annotate id 필드 - ID가 자동으로 만들어져야 한다는 것을 알려줌.   private Long id; // annotated with @Id - JPA가 이 필드를 ID로 인식함.   private String firstName;   private String lastName; //firstName과 lastName은 unannotated 됨. 같은 이름으로 columns에 mapped 되었다고 여겨짐    // Default constructor 다른 이유없이 JPA를 위해서 존재함. 직접적으로 사용하지 않기 때문에 protedted로 지정.   protected Customer() {}    // 이 생성자를 이용해서 데이터베이스에 저장 될 instances 를 만듬     public Customer(String firstName, String lastName) {     this.firstName = firstName;     this.lastName = lastName;   }   ","categories": ["TIL","공부 기록"],
        "tags": ["software","learning","JPA"],
        "url": "/til/%EA%B3%B5%EB%B6%80%20%EA%B8%B0%EB%A1%9D/go/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "HTTP / 백준 2558번 / Java Abstraction",
        "excerpt":"  💭     백엔드 개발자 로드맵을 보고 각 항목에 관련된 글을 읽어보려 한다.   백준 문제 풀이하며 레벨 올리기!   Java에 대해 공부하기   Domain name resolution  이 페이지를 참고  Domain name resolution은 도메인 이름을 IP 주소로 변환하는 처리 과정을 말한다. 하나의 도메인 이름은 하나의 IP 주소와 연결되고, 하나의 IP 주소는 여러개의 도메인 이름들과 연결될 수 있다. 이것은 여러개의 도메인 이름이 하나의 같은 IP 주소를 가질 수 있는 것을 의미한다.   Application Protocols : HTTP and World Wide Web  이 페이지를 참고  인터넷에서 가장 흔하게 사용되는 서비스 중 하나는 World Wide Web 이다. Web을 작동시키는 응용 프로그램 프로토콜은 HTTP(Hyper Text Transfer Protocol)이다. HTTP를 HTML과 헷갈리지 말자. HTML은 웹 페이지를 작성하는 언어이다. HTTP는 웹 브라우저와 웹 서버가 서로 정보를 교환하기 위해 사용하는 통신 규약이다. HTTP는 응용 프로그램 레벨의 통신규약인데, HTTP가 통신 규약 스택에서 TCP 위에 있고 특정 응용프로그램(웹 브라우저, 웹 서버와 같은)으로부터 이용되기 때문이다.   HTTP는 비연결형 문자 기반 프로토콜이다. 클라이언트(웹 브라우저)가 웹 서버에 이미지, 웹 페이지 등을 요청한다. 클라이언트가 요청한 뒤 이미지나 웹 페이지가 전송 완료되면 클라이언트와 서버 사이의 연결이 끊긴다. 새 요청이 있을 때마다 다시 연결한다. 대부분의 프로토콜은 연결 지향적이다. 이것은 서로 정보를 주고 받고 있는 컴퓨터가 인터넷을 통해 계속해서 연결을 유지한다는 뜻이다. HTTP는 그러지 않다. 클라이언트로부터 HTTP 요청이 이루어지기 전에 먼저 서버와 새롭게 연결이 되어야 한다.   당신이 웹 브라우저에 URL 을 입력할 때 어떤 일이 일어날까?     URL이 도메인 이름을 포함하고 있다면, 브라우저는 먼저 domain name server를 연결합니다. 그리고 도메인 이름에 연결된 IP 주소를 찾아옵니다.   웹 브라우저는 웹 서버와 연결되고 원하는 웹 페이지를 불러오기 위해 HTTP 요청을 보냅니다. (통신 규약 스택을 통해)   웹 서버는 요청을 확인하고 웹 페이지를 확인합니다. 만약 요청으로 들어온 페이지가 있다면, 웹 서버는 페이지를 전송합니다. 만약 서버가 요청 들어온 페이지를 찾을 수 없다면, 서버는 HTTP 404 error 메시지를 보냅니다. (웹서핑을 해본 사람이면 알겠지만 404 는 ‘페이지를 찾을 수 없음’을 의미합니다.)   웹 브라우저가 요청한 페이지를 받으면 연결이 끊어집니다.   그리고 브라우저가 페이지를 분석하며 어떤 요소들(이미지, 작은 응용프로그램들)이 더 필요한지 찾습니다.   브라우저는 필요한 요소들을 가져오기 위해 서버에 새로이 연결하고, 요소들을 요청합니다. (각 요소마다 따로 따로 새 요청을 합니다.)   브라우저가 모든 것들(이미지, 작은 응요프로그램 등)을 가져오면, 브라우저의 윈도우창에 완전한 페이지가 나타납니다.     백준 2588번 문제 풀어보기  2588번 문제   아래 사진은 (세 자리 수) × (세 자리 수) 의 답을 구하는 과정을 보여준다.      (사진의 출처는 백준 사이트의 해당 문제 페이지입니다.)   여기서 (3),(4),(5),(6)에 해당하는 수들을 출력하는 프로그램을 만들면 된다. a = (1), b = (2) 라고 할 때, (3)은  a * (b의 1의 자리수), (4)은  a * (b의 10의 자리수), (5)은  a * (b의 100의 자리수) 이니까 입력 받은 b 를 먼저 각각 하나의 1의 자리 숫자로 쪼개고, 쪼개진 각 수에 a 를 곱해보자고 생각했다. 백의 자리수를 쪼개는 방법을 검색하다 이 페이지 찾았다. 아래 방법으로 숫자를 쪼개서 하나씩 구할 수 있다.   class Main {   public static void main(String[] args) {      int num = 1020;      while (num &gt; 0) {        System.out.println( num % 10);        num = num / 10;        }     }   }   그리고 세시간동안 혼자 생각해보며 (3), (4), (5) 까지는 구했는데 (아래처럼 작성) (6)을 구하지 못하고 답을 찾아봤다. 문제의 레벨을 봤을때 물론 엄청 간단할거라 생각했지만… 길을 잘못 들어도 한참 잘못 들었더라 하하..   import java.util.*;  class Main {     public static void main (String[] args) {         Scanner sc = new Scanner(System.in);         int a, b;         a = sc.nextInt();         b = sc.nextInt();          int[] arr = new int[3];         int[] arr2 = new int[3];          while (b &gt; 0) {         \tfor(int i = 0; i &lt; arr.length; i++) {         \tarr[i] = b % 10;         \tb = b / 10;         \tarr2[i] = a * arr[i]; \t          \tSystem.out.println(arr2[i]);          }      }   }  }                 다른 분이 올린 답을 보고 생각해봅니다.   import java.util.*;  class Main {     public static void main (String[] args) {         Scanner sc = new Scanner(System.in);         int a, b;         a = sc.nextInt();         b = sc.nextInt();          System.out.println(a * (b % 10));         System.out.println(a * ((b / 10) % 10));         System.out.println(a * (b / 100));         System.out.println(a * b);     }  }             패드에 써가면서 생각해보기        Java Abstraction  Abstract Classes and Methods   데이터 추상화는 중요한 세부 정보들은 숨기고 꼭 보여져야하는 정보들만 유저들이 볼 수 있도록 하는 것이다. 데이터 추상화는 abstract classes 나 interfaces를 통해 이뤄질 수 있다. abstract 키워드는 non-access modifier 이다.  아래 표는 Acccess Modifier 와 Non-Access Modifier 를 보여준다.                  Acess Modifiers       Non-Access Modifiers                       private       static                 default or No Modifier       final                 protected       abstract                 public       synchronized                         trasient                         volatile                         strictfp                      Abstract class는 객체를 만들 수 없도록 제한된 클래스이다.            Abstract method는 Abstract class 에서만 사용될 수 있다. abstract methods는 바디 부분이 없다.       abstract class Animal {   public abstract void animalSound(); // public 과 abstract 가 같이 사용되네..?   public void sleep() {     System.out.println(\"Zzz\");   } }   위 코드를 보면 알 수 있듯이, 하나의 abstract class는 abstract method와 일반적인 method 둘다 가질 수 있다.   Animal Obj = new Animal(); // abstract class인 Animal 클래스는 객체를 만들 수 없으므로 에러 발생   Abstract class에 접근하기 위해서는 Abstract class를 상속 받는 subclass를 만들어야 한다.   // Abstract class abstract class Animal {   // Abstract method   public abstract animalSound(); //바디 없음   // Regular method   public void sleep() {     System.out.println(\"Zzz\");   } }  // Animal 클래스를 상속받는 Subclass class Pig extends Animal {   public void animalSound() {     // 위 Abstract 메소드의 바디가 여기서 작성됨     System.out.println(\"The pig says: wee wee\");   } }  class Main {   public static void main(String[] args) {     Pig myPig = new Pig(); // Pig 객체 만들기     myPig.animalSound();     myPig.sleep(); //Pig 객체가 Anmal 클래스를 상속받으므로 sleep 메소드 사용 가능    } }   ","categories": ["TIL"],
        "tags": ["software","learning","공부 기록"],
        "url": "/til/theinternet/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "E-mail / 백준 2884번 문제 풀어보기",
        "excerpt":"  💭     How Does the Internet Work? 라는 글 읽기   백준 문제 풀기   Java   Application Protocols: SMTP and Electronic Mail  많이 사용되는 인터넷 서비스 중 하나는 이메일이다. 이메일은 Simple Mail Transfer protocol 또는 SMTP 라고 불리는 어플리케이션 레벨의 통신규약을 사용한다. SMTP 역시 HTTP와 같은 텍스트 기반의 통신규약이지만 HTTP와 다르게 연결 지향적이다. SMTP는 HTTP보다 더 복잡하다. 더 많은 명령어들과 고려해야 할 사항들이 있다.   우리가 이메일을 읽기 위해 Mail client를 열었을 때 일어나는 일은 다음과 같다.      Mail client(메일을 보내고 열기 위해 메일 서버에 접근하는 프로그램. 맥북이나 아이폰 기본 어플인 Apple mail, Google mail, Microsoft OUtlook 등이 있다.)가 기본 메일 서버에 연결한다. 메일 서버의 IP와 도메인 이름은 보통 메일 클라이언트가 설치 될 때 함께 설정 된다.   메일 서버는 \b자신의 메일 클라이언트가 맞는지 확인하기 위해 언제나 첫번째 메시지를 보낼 것이다.   클라이언트는 SMTP HELO 명령을 전송하고 서버는 250 OK 라는 메시지로 답할 것이다.   클라이언트가 메일을 보내는지, 확인하는지 등의 따라 SMTP 명령을 보낼 것이고 서버는 그에 따라 맞는 답변을 보낼 것이다.   이런 요청/응답 연결은 클라이언트가 SMTP QUIT라는 명령어를 보내기 전까지 계속될 것이다. SMTP QUIT 명령을 받은 서버는 goodbye 라고 응답할 것이고 연결은 끊어진다.      (이거를 메일 클라이언트들이 해준다는 거겠지?)   💭   이 글은 꽤 오래전에 쓰여졌는데 마지막 부분에서 작성자는, 이 글에 쓰여진 인터넷이 작동하는 원리가 얼마나 오래 같은 방식을 유지할 것인가에 대해 물었다. 나도 글을 읽으며 요즘도 이런 방식을 사용하는지 의문이 들기도 해서 최신의 정보도 함께 찾아보면 좋을 것 같다는 생각이 들었다.       백준 2884번 문제 풀기   아침잠이 많아 맨날 지각하는 상근이를 위해 친구 창영이가 아이디어를 던져줍니다. ‘45분 빠르게 알람을 맞춰봐!’ 상근이는 자기가 45분 빠르게 알람을 맞추면 되는데..프로그램을 만들기로 결심했어요. 나중에 개발자가 되려나봐요.🙃   시간과 분을 나타내는 정수 두개를 입력받고 45분 전으로 설정된 시간을 출력하는 문제입니다.   일단 if문 항목에 있는 문제라 if 문을 사용해야 한다는 힌트는 가지고 있습니다.  분(m)으로 입력받은 값 m 이 45보다 크다면 45를 빼서 입력받은 시간과 함께 출력하면 되고 45보다 작다면, m = 60 - (45 - m) 으로 생각하면서 코드를 써봤는데 틀렸다. 이클립스에서는 예제대로 작동하는데 뭔가 잘못된 것 같다. 이 문제에 시간을 많이 써서 답을 찾아보기로! (아래 코드는 내가 작성한 틀린 코드)    import java.util.*;  class Main {     public static void main (String[] args) {         Scanner sc = new Scanner(System.in);         int h, m;         h = sc.nextInt();         m = sc.nextInt();          if(h &gt; 0 &amp;&amp; m &gt;= 45) {           int hour = h;         \tint min = m - 45;         \tSystem.out.println(hour + \" \" + min);         }          if(h &gt; 0 &amp;&amp; m &lt; 45 ) {         \tint hour = h - 1;         \tint min = 60 - (45 - m);         \tSystem.out.println(hour + \" \" + min);         }          if(h == 0 &amp;&amp; m &gt;= 45) {         \tint hour = 23;           int min = m - 45;           System.out.println(hour + \" \" + min);         }          if(h == 0 &amp;&amp; m &lt; 45) {         \tint hour = 23;           int min = 60 - (45 - m);           System.out.println(hour + \" \" + min);         }     }  }    답 구글링을 해보니 정말 간단하게 코드를 작성하셨다. 어떻게 코드를 작성하는지에 대해 생각해보면 좋을 것 같다. 가장 첫번째가 되어야 하는 조건을 구별하는 것을 연습해야겠다. 오늘은 문제 풀이에 시간을 더 쓸 수 없을 것 같아서 내일 한번 더 보고 생각해보기로! 언제나 블로그에 답 남겨주시는 개발자 분들께 감사하며..!  ","categories": ["TIL"],
        "tags": ["software","learning","공부 기록"],
        "url": "/til/email/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "return Keyword in Java / Java statements",
        "excerpt":"  💭     Java   Returning a Value from a Method  이 페이지를 참고   메소드는 아래 상태가 되면 자신을 실행시킨 코드로 돌아온다.     메소드의 모든 statements를 수행했을 때   return statement에 도달 했을 때        throws an exception (covered later),      메소드를 정의할 때 return type을 선언한다. 메소드의 바디에서 값을 받기위해 return statement를 사용한다. void 로 정의된 메소드는 값을 리턴하지 않기 때문에 바디 부분에 return statement를 포함하지 않아도 된다. 포함 할 수도 있는데   Java Statements  이 페이지를 참고   Java statements 는 자바 프로그래밍 언어가 무엇을 해야하는지 지시해주는 것이다. assignment statement는 아래와 같이 값을 변수에 대입시킨다. (할당한다.)   double entryFee = 15.75;   모든 Java statements는 세미콜론(;)으로 끝맺어야한다. Java는 세미콜론까지 정보들을 처리한다. 아래 declaration statement는 전달된 메소드를 이용해서 화면에 정보를 나타나게 한다.   System.out.println(\"Line 1\");  ","categories": ["TIL"],
        "tags": ["software","learning","공부 기록"],
        "url": "/til/copy/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Persist something? ORM과 JPA",
        "excerpt":"  💭   Persist something? Persistence?  이 페이지를 참고     Persistence는 아주 간단히 말하자면 영구적으로 저장(담아 둔다는)한다는 뜻이다. 자바를 이용하면서 우리는 오브젝트의 값을 데이터베이스에 저장한다. ORM은 JPA가 제공하는 표준 규격을 이용해 오브젝트를 데이터 베이스에 담는다. (새 튜플의 형태로) JPA에서 오브젝트들은 Entity로 변환된다. (엔티티는 오브젝트를 데이터 베이스의 테이블로 매핑하기 위해 사용됨)  persisting an entity는 오브젝트(엔티티로 변환된)를 데이터베이스에 영구적으로 저장한다는 뜻이다.   ‘Persist’는 어플리케이션이 종료된 후에도 계속해서 데이터가 남아있는 것을 의미한다. 어플리케이션이 종료되거나 사용자가 세션을 종료하고 새 세션을 시작해도 에전 데이터가 사라지지 않고 계속해서 저장돼있는 것이다.   Implementation  이 페이지에서 가져옴  컴퓨터 공학에서, Implementation(구현)이란 기술적으로 정리해놓은 규격서나 알고리즘을 프로그래밍 혹은 소프트웨어 배치를 통해 프로그램이나 소프트웨어의 부분, 다른 컴퓨터 시스템을 구축하는 것을 말한다. 하나의 규격서나 표준에도 다양한 구현이 있을 수 있다. 예를 들면, 웹 브라우저는 W3C에서 정한 규격서의 구현을 포함하고 있다. 또, 소프트웨어 개발 도구는 프로그래밍 언어의 구현을 포함하고 있다.       JSP (Java Server Pages)  이 페이지를 참고     웹 어플리케이션을 만들기 위해 사용되는 서버 쪽 기술.   동적 웹 컨텐트를 만들기 위해 사용된다.        (이 페이지에서는)     JSP 태그는 Java 코드를 HTML 페이지에 넣기 위해 사용된다.       Servlet Technology의 신식(?) 버전이다. (구글링 해보니 Servlet이 더 빠르지만 코드 작성하고 읽기는 JSP가 더 쉽다고 합니다.)  ","categories": ["TIL","공부 기록"],
        "tags": ["software","learning","JPA","ORM","Persistence"],
        "url": "/til/%EA%B3%B5%EB%B6%80%20%EA%B8%B0%EB%A1%9D/aboutjpa/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "JSP란...? / Tomcat Server & Eclipse로 JSP 작성 후 실행해보기",
        "excerpt":"  💭 ..      자바 웹 개발자 과정 수업을 듣기 시작한지 일주일이 지났다.    자바의 기본적인 문법은 여러가지 온라인 강의를 통해서 예습을 하고 시작했던터라 어렵지 않게 수업을 듣고 있다. 수업 커리큘럼에 JSP가 포함되어 있는데, 아직 JSP가 어떤것인지 잘 몰라서 한번 알아보려고 한다.     요즘 어떤 정보에 대한 글을 읽거나, 기술에 대해 알아보기 전에 '지금도 여전히 사용되는가?' 라는 질문을 먼저 검색해보게 된다. 나의 수준에서는 뭐든 배워두면 도움이 되겠지만, 배울 것은 너무나 많고 시간은 충분하지 않아서 자꾸만 정보의 중요성에 대해 생각해보게 된다. 언제나 새로운 것들이 마구 쏟아지는 지금 같은 시대에는 주로 사용되는 기술들도 빠르게 변한다. 그렇기 때문에 자꾸 위와 같은 질문을 검색해보는 것 같다. 새로운 기술이 언제나 좋은 것은 아니지만 대부분의 경우 새로운 기술이 더 빠르거나, 더 간단하게 복잡한 일을 처리하거나, 전 기술의 단점을 보완해서 나오는 경우가 많이 때문에 새로운 기술들에 대해 더 알고 싶은 것 같다.     JSP에 대해서도 구글링해보니 새로운 프로젝트에는 더이상 사용되지 않는 것 같지만, JSP에 대한 기본적인 것들을 알아두면 도움이 되는 것 같다. 작은 프로젝트를 진행할때는 여전히 사용되기도 하고 예전에 만들어진 어플리케이션들을 살펴봐야 할 수도 있고, 서블릿과 JSP가 자바 웹 개발의 기본적인 것들이라 스프링, hibernate을 배우기 전에 배워야 한다는 의견도 있다. 그리고 나는 지금 듣는 과정중 JSP에 대해 배우게 될 것이고, 테스트도 봐야해서 기본적인 것들을 알아보려고 한다.    🧑‍💻 JSP (Java Server Pages)  이 페이지의 내용을 참고   JSP는 서블릿처럼 웹 어플리케이션을 만드는 것에 사용된다. 서블릿과 같은 일을 하지만 더 많은 기능들을 가지고 있기 때문에 서블릿의 확장된 버전으로 생각해도 되겠다. JSP 페이지는 주로 HTML 태그와 JSP 태그로 이루어진다. (JSP 태그를 이용해서 자바 코드를 HTML 페이지에서 사용할 수 있다.) JSP페이지는 기술 파트와 디자인 파트를 나눌 수 있기 때문에 서블릿보다 유지가 쉽다. Expression Language와 Custom Tags와 같은 부가 기능을 제공하기도 한다.   💡 서블릿과 비교했을 때 JSP의 장점은 무엇이 있을까?          JSP는 서블릿을 확장한 기술이기 때문에 서블릿의 모든 기능들을 사용할 수 있다. implicit objects, predefined tags, expression language 그리고 custom tags와 같은 추가된 기능들을 사용할 수 있다.            JSP는 비즈니스 로직과 프레젠테이션 로직을 쉽게 분리 할 수 있다. 덕분에 JSP는 쉽게 관리 할 수 있다.            JSP 페이지가 수정되었더라도 프로젝트를 다시 컴파일 하거나 디플로이 할 필요가 없다. 서블릿 코드는 바뀐 부분들을 업데이트하고 리컴파일 해야하지만 JSP는 그럴 필요가 없기 때문에 빠르게 개발할 수 있다.            JSP에서는 Action tags, JSTL, Custom tags 등 많은 태그를 이용할 수 있기 때문에 서블릿보다 더 적은 코드 작성을 필요로 한다.       💡 JSP의 Lifecycle   JSP 페이지들은 아래 변화 단계를 따른다.     Translation of JSP Page   Compilation of JSP Page   Classloading (the classloader loads class file)   Instantiation (Object of the Generated Servlet is created).   Initialization (the container invokes jspInit() method).   Request processing (the container invokes _jspService() method).   Destroy (the container invokes jspDestroy() method).      Note!    jspInit(), _jspService() and jspDestroy() 는 JSP의 라이프사이클 메서드.    JSP는 JSP translator의 도움을 받아 서블릿(.java file)으로 변환(변형?)된다.  JSP translator는 JSP 페이지를 서블릿으로 변환하는 웹 서버의 한 부분이다. 서블릿이 된 JSP 페이지는 compiler 에 의해 컴파일 되고 클래스 파일로 변환된다. 서블릿에서 일어나는 모든 프로세스들은 후에 JSP에서 수행된다.   🐈 Tomcat Server &amp; Eclipse로 JSP 작성 후 실행해보기  이 페이지의 내용을 참고   톰캣 서버는 가장 좋은 웹 서버 중 하나이고, 아파치에서 개발한 오픈소스 자바 서블릿 컨테이너이다. 톰캣은 고유의 특징과 빠른 속도, 그리고 J2EE specifications를 실행하는 점 때문에 많은 개발자들이 이용하고 있다.   위 페이지를 참고하며 이클립스와 톰캣을 이용해 JSP 페이지를 만들어본다.           프로젝트 익스플로러에서 마우스 우클릭 New &gt; Dynamic Web project ✅               프로젝트 이름을 입력 &gt; Next ✅               프로젝트 이름을 입력 &gt; Next ✅               Next &gt; finish ✅                  프로젝트 익스플로러에 프로젝트가 만들어진 것을 볼 수 있습니다. ✅               src 위에서 우클릭 &gt; New &gt; JSP File ✅               Next &gt;✅               Finish 버튼 클릭 ✅               JSP 파일이 만들어졌습니다. &lt;body&gt; 부분에 Hello Earth! 를 입력 ✅               프로젝트에서 우클릭 &gt; Run As &gt; 1 Run on Server ✅               Apache &gt; Tomcat 서버 클릭 &gt; Next &gt; Add and Remove 창에서 Finish ✅               자동으로 사파리 창이 뜹니다. \b입력했던 Hello Earth!가 잘 뜨는걸 보니 JSP페이지가 잘 돌아가고 있습니다.          🙋 JSP Syntax 어떻게 작성하는데?      아래 작성된 태그가 .jsp 파일 맨 위에 추가 된다.            &lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;            JSP 페이지는 JSP   ✍️ Scriptlet    JSP scriptlet는 자바 언어로 쓰여진 코드, 변수, 메서드 선언부, 기호, 부호 등을 담을 수 있다.  ","categories": ["TIL"],
        "tags": ["learning","JSP","Java","Tomcat Server","Eclipse IDE"],
        "url": "/til/aboutJSP/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Java 배열 이용하여 정수를 내림차순으로 정렬하기",
        "excerpt":"  💭  입력받아 배열에 저장한 정수를 내림차순으로 정렬하기  (내림차순 - 값이 큰 순서에서 작은 순서로 정렬)   import java.util.Scanner;  public class Main {  \tpublic static void main(String[] args) {       Scanner sc = new Scanner(System.in);     //입력값을 받아 배열의 크기 정하기     System.out.println(\"배열의 크기를 입력하세요. : \");     int[] arr = new int[sc.nextInt()];      //for 문을 이용해 배열에 값 저장하기     for(int i = 0; i &lt; arr.length; i++) {         System.out.println((i + 1) + \"번째 정수 입력\");         arr[i] = sc.nextInt();     }      //내림차순으로 정렬하기      int box = 0;      for(int i = 0; i &lt; arr.length; i++) {         for(int j = i + 1; j &lt; arr.length; j++) {                  if(score[j] &gt; arr[i]) {                   box = arr[i];                        arr[i] = arr[j];                    arr[j] = box;                       }           }         }      //정렬된 배열 출력     for(int i = 0; i &lt; arr.length; i++) {       System.out.println(\"arr[\" + i + \"] : \" + arr[i]);     }     } }      ","categories": ["TIL"],
        "tags": ["learning","Java","Array","Descending order"],
        "url": "/til/decsendingOrder/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Java 추상화(Abstraction)와 메소드 재정의(Overriding)",
        "excerpt":"  💭 ..     자바 웹 개발자 과정 수업 2주차    중간에 연휴가 있어서 일수로는 7일차다.     오늘은 Overriding과 abstract 클래스와 메소드에 대해 배웠다.     강사님의 설명을 들으며 몇주전 abstract 에 대해 혼자 공부했던 기억이 나서 블로그를 보니..     오늘 처음 듣는 것 같았던 것들이 불과 이주전에 글로 써보기까지 했던 것들이었다.     처음엔 '공부를 한거야 만거야?'라고 스스로에게 물었는데 정리해둔걸 보니 '그래도 틀린 것들을 적어둔건 아니었구나 그때는 열심히 했네.'하는 생각이 들었다. 나는 지금 하고 있는 공부, 취업준비가 국비과정이 끝나면 모두 딱! 끝나버릴거라고 생각하지 않는다. 취업은 사실 바로 됐으면 하지만...! (네카라쿠배 바라는거 아니니까ㅋㅋㅋ) 어딜 취업하든 계속해서 아는 것을 넓혀나가야 할 것 같다는 생각이 든다. 배우면 배울수록, 조금씩 더 많이 알아갈수록 왠지 그럴 것 같다는 생각이 든다. 7일차고 어제 잠을 못자서 오후에는 피곤함이 조금 느껴졌는데 그래도 재미있었다. 아직은 자바를 배우고 있어서 그런걸수도..ㅎㅎ 아무튼 그래서 예전에 정리해뒀던거 + 오늘 배운 것들을 함께 정리해보려고 한다.     Let’s get started!  Overriding을 구글에 검색해보니 사전적 의미가 가장 먼저 나온다.      (adj) more important than any other considerations. \b가장 먼저 고려되는…    Overriding methods (메소드 재정의)는 부모 클래스로부터 상속받은 메소드를 자식 클래스가 그대로 사용하지 않고 바디 부분을 변경해서 사용하는 것이다. Overriding 이라는 단어의 사전적 의미 그대로 부모 클래스의 메소드를 override한 자식클래스의 메소드가 가장 중요한 것으로 고려된다. (그러므로 수정된 자식 클래스의 메소드의 기능이 사용된다.) ‘추상화 Abstraction’과  ‘메소드 재정의 Overriding method’는 서로 관련이 있다. 먼저 추상화에 대해서 알아보자.   Java Abstraction  Abstract Classes and Methods 이 페이지를 참고   데이터 추상화는 중요한 세부 정보들은 숨기고 꼭 보여져야하는 정보들만 사용자들이 볼 수 있도록 하는 것이다. 또, 응용 프로그램의 설계 부분과 구현하는 부분을 나누기 위해 사용된다. 추상화는 abstract classes 나 interfaces를 통해 이뤄질 수 있다.  abstract 메소드와 클래스는 책의 목차로 비유하고, override 된 메소드는 내용에 비유해주셨다.   (여기서 abstract 키워드는 non-access modifier 이다.  아래 표는 Acccess Modifier 와 Non-Access Modifier 를 보여준다.)                  Acess Modifiers       Non-Access Modifiers                       private       static                 default or No Modifier       final                 protected       abstract                 public       synchronized                         trasient                         volatile                         strictfp                      Abstract class는 객체를 만들 수 없도록 제한된 클래스이다.  Abstract class를 상속받는 자식클래스를 만들어서 자식클래스를 객체화 할 수 있다.            Abstract method는 Abstract class 에서만 사용될 수 있다. abstract methods는 바디 부분이 없다. (Abstract method만 있으면 interfaces)       코드를 보며 알아보자!   abstract class Animal {   public abstract void animalSound(); //abstract method (바디 없음)   public void sleep() {               // 일반적인 method     System.out.println(\"Zzz\");   } }   위 코드를 보면 알 수 있듯이, 하나의 abstract class는 abstract method와 일반적인 method 둘다 가질 수 있다.   Animal Obj = new Animal(); // abstract class인 Animal 클래스는 객체를 만들 수 없으므로 에러 발생   왜 객체를 만들 수 없는지 생각해보자. 객체는 클래스라는 설계도를 이용해서 만든다. 자동차를 떠올려보자. 자동차를 만들기위해 설계도를 만들었는데 그 중 한 부분이 없어진 것이다. 그렇다면 자동차를 만들 수 있을까? (만들수도 있겠지만ㅎㅎ) 온전한 자동차를 만들 수는 없을 것이다. 메소드는 객체에서 기능 부분을 담당한다. 그런데 자동차의 기능 중 한가지가 빠진것이다. 브레이크나 엑셀이 빠진다면..?  위의 코드를 보고 생각해보자면, Animal이라는 클래스에 animalSound라는 메소드가 텅 비어있는 것이다. 그래서 객체를 만들 수 없는 것이다.   Abstract class에 접근하기 위해서는 Abstract class를 상속 받는 subclass를 만들어야 한다.   // Abstract class abstract class Animal {   // Abstract method   public abstract animalSound(); //바디 없음   // Regular method   public void sleep() {     System.out.println(\"Zzz\");   } }  // Animal 클래스를 상속받는 Subclass class Pig extends Animal {   public void animalSound() {     // 위 Abstract 메소드의 바디가 여기서 작성됨     System.out.println(\"The pig says: wee wee\");   } }  class Main {   public static void main(String[] args) {     Pig myPig = new Pig(); // Pig 객체 만들기     myPig.animalSound();     myPig.sleep(); //Pig 객체가 Anmal 클래스를 상속받으므로 sleep 메소드 사용 가능    } }   ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Java","Abstraction","Overriding in Java"],
        "url": "/til/overriding/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "SQL 정리",
        "excerpt":"  💭     SQL    오늘은 IT국비지원교육 18일차 날이다. 16일간의 자바 여행을 잠깐 마치고 SQL 을 배우기 시작했다.     SQL은 생각보다 어렵지 않아서 자바를 배울 때보다는 편한 마음으로 수업을 듣고 있다.     기본적인 statements들은 많이 사용해 보면 외우게 될 것 같지만 머릿속에서 정리가 덜 된 느낌이라 블로그 글로 정리해 본다.     ⌨️ SQL(Structured Query Language)   SQL(Structured Query Language)은 데이터베이스에 저장된 데이터에 접근하고 조작하기 위해 사용되는 표준 언어다.   ✍️ SQL Statements? 프로그래밍 언어에서 Statements 란?   ✋ 잠깐 Statements가 무엇인지 예시를 보며 알아보자.       System.out.println(\"Hello World\");  -&gt; 자바에서 Hello World를 화면에 출력하는 Statement       Bicycle redBike = new Bicycle();  -&gt; 자바에서 객체를 만드는 Statement         SELECT * FROM Friends;  -&gt; Friends 라는 이름의 테이블의 모든 컬럼을 가져와 보여주는 Statement       SELECT Fname FROM Friends;  -&gt; Friends 테이블의 Fname 컬럼의 정보를 가져와 보여주는 Statement   Statements란 각 프로그래밍 언어의 문법에 맞게 쓰여진 문장으로, 수행되어야 하는 작업을 표현한 문장이라고도 할 수 있겠다.   🤘SQL을 이용해서 데이터 베이스에 테이블을 만들어보자     CREATE TABLE your_table (     column1 varchar2(10) primary key,     column2 number(5) not null,     column3 varchar2(15),     column4 date   );  위의 SQL 쿼리로 테이블을 만들 수 있다. ↓ 아래는 만들어진 테이블. (아직 데이터는 입력하지 않았다.)      🔊run a SQL query    ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Java"],
        "url": "/til/sql/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "프로그래밍에서 Iterations란? / 코딜리티의 open reading material를 읽어보며 for 문에 대해 알아보자.",
        "excerpt":"  🧱     Iterations    30분 작성한 글 날린거 실화냐..     '본격적으로 취업 준비를 해보자!' 하는 생각이 들었고, 블로그의 취직 성공기들을 읽어보다가 코딜리티라는 사이트를 알게 되었다. 리트코드나 프로그래머스는 한번씩 둘러봤는데, 코딜리티는 처음 듣는 곳이라 궁금해져 가입 후 연습문제를 풀기 전 open reading material을 읽어보려고 한다.    첫 레슨은 Iterations에 관한 글입니다.  Open reading material about Iterations 링크    프로그래밍에서 iterating이란 프로그램의 한 부분을 반복하는 것을 말합니다. 이 레슨에서는 Iterations를 수행하는 기초적인 프로그래밍 구조에 대해 알아볼 것 입니다. 바로 “for”과 “while” 반복문(loops)입니다.   ⚙️ For loops   반복문의 구조에 대해 먼저 알아봅시다. 만약 정해진 횟수만큼 반복하는 작업을 하려 한다면, 한 그룹에 속해있는 각각의 요소들에 대해 반복을 수행하려 한다면 for 문을 사용하면 됩니다.   For loop systax    (이 글에서는 python을 기준으로 설명합니다. 그런데 코드가 좀 다른건지.. 글에 적힌대로 VScode에서 실행하니까 에러가 나네요..?)    for some_variable in range_of_values:     loop_body   # 처음 개발 공부를 Python으로 시작했는데 자바만 공부하다보니 많이 어색하네요.  위 for문은 range_of_values의 크기만큼 반복하며 loop body의 내용을 수행합니다. range_of_values의 현재 값은 some_variable의 값에 할당됩니다. 가장 간단한 형태로 아래처럼 작성될 수 있습니다.     for i in range(0, 100):     print i     위 코드는 0부터 99까지의 모든 정수를 출력합니다. 0 ~ 어떤 정수 범위의 반복문 수행은 많이 사용됩니다. (Python list나 배열의 인덱스가 0부터 시작하는 주된 이유입니다.) 아래 반복문은 위의 반복문과 똑같은 값을 출력합니다. 0부터 시작이라면 0은 생략 가능하죠.    for i in range(100):     print i   예시 : 우리에게 양의 정수인 n 이 주어졌습니다. factorial을 구해볼건데요. 예를 들어 factorial 3은 3 * 2 * 1 입니다. factorial n을 구하여 변수 factorial 에 할당해봅시다.    factorial = 1   for i in range(1, n + 1):     # factorial n 의 값을 구할 수 있음     factorial *= i   또 다른 예시 : * 표로 공백으로 띄어진 삼각형을 출력해봅시다. 삼각형은 n 이라는 행을 가지고 있고, n은 양의 정수로 주어집니다. 각 행은 연달아 1, 2, …, n 개의 *을 가지고 있습니다. 예를 들면, n = 4 일때, 아래의 삼각형이 출력되어야 합니다.      *     * *     * * *     * * * *  이 삼각형을 출력하기 위해서는 두개의 반복문이 필요합니다. 하나의 반복문 안에 다른 반복문 하나가 있어야하죠. 바깥쪽의 반복문은 반복될 때마다 각 행을 출력하고 안쪽의 반복문은 반복될 때마다 *(별 asterisk) 하나를 출력합니다.    for i in range(1, n + 1):     for j in range(i):         print ' *',          # 맨날 자바 for문 작성하다가 python 으로 하니까 너무 좋다.     print    # 안쪽 for문의 바디에 해당됨. 개행 역할  (위에서도 잠깐 언급한 것처럼 이 자료의 코드 그대로 VScode에 돌리면 에러가 나네요..? Python이 아닌건가요? 아래 코드로 돌리면 제대로 별이 나옵니다.)    for i in range(1, 5) :     for j in range(i) :         print(' *', end=\"\")     print('')  range function에는 한가지 인자가 더 추가 될 수 있는데, 바로 step 이다. range(10, 0, -1) 은 10, 9, 8, 7, …, 1 까지의 범위를 의미한다. start 값은 10, stop 값은 0, 이 사이를 -1만큼씩 순차적으로 내려온다는 의미가 된다. 이렇게 세개의 인자를 사용할 때는 start 값을 생략할 수 없다.   또 다른 예시 : 이번에는 아래와 같은 삼각형을 출력해 봅시다. n개의 행을 가지고 있는 거꾸로 된 대칭 모양의 삼각형입니다. 각 행은 2n-1, 2n-3, …, 3, 1개의 *을 가지고 있어야 하고 0, 2, 4,…, 2(n-1)만큼의 공백을 가지고 있어야 합니다. 예를들어 n = 4인 삼각형은 아래처럼 출력되어야 합니다.    * * * * * * *     * * * * *       * * *         *  이 예제에서 우리는 세개의 반복문을 사용합니다. 하나의 바깥쪽 반복문과 두개의 안쪽 반복문입니다. 바깥쪽 반복문은 반복할때마다 하나의 행을 출력합니다. 첫번째 안쪽 반복문은 공백을 출력하고 두번째 안쪽 반복문은 *을 출력합니다.    for i in range(n, 0, -1) :     for j in range(n - i) :       print ' ',     for j in range(2 * i - 1) :       print ' *'     print    위의 코드로 별을 출력해보면 (출력되도록 print 부분을 수정하더라도) 공백을 찍는 부분의 식이 좀 잘못되어 있는 같다. 이 예제의 두번째줄이 공백을 출력하는 부분인데 n = 4 일때 (n-i)로 공백을 출력하게 되면 0, 1, 2, 3개의 공백을 출력하게 된다. 예제에서 출력되어야 하는 공백의 수는 0, 2, 4 이다.    만약 별과 별 사이에 공백이 없다면 위의 코드가 맞는데,, 내가 파악하지 못한 부분이 있는걸까?  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","python","코딜리티"],
        "url": "/til/Iterations/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "깃헙은 왜 기본 브랜치의 이름을 main으로 바꿨을까?",
        "excerpt":"💭     깃헙에 대해 배워가면서 한가지 궁금한 점이 생겼습니다.      블로그로 정보를 찾거나 구글링을 하다 보면 사람들은 레퍼지토리 안에 master 브랜치를 기본으로 가지고 있고,     레퍼지토리를 생성하면 master 브랜치가 생성된다는데. 제가 레퍼지토리를 만들면 언제나 main 이라는 이름의 기본 브랜치가 생성되었거든요.      '내가 뭔가 설정을 잘못한걸까?'하는 생각이 들어 구글링을 하기 시작했습니다.     그러다가 깃헙이 더이상 master branch라는 이름을 사용하지 않는다는 것을 알게되었어요. 왜일까? 궁금해서 이유를 찾아보니     생각보다 더 멋진 이유로 기본 브랜치의 이름을 main으로 바꿨다는 것을 알게 되어서 공유해 봅니다.       왜 깃헙은 master branch의 이름을 main으로 바꾸었을까?  Why GitHub renamed its master branch to main   여기 master branch에서 main branch로의 큰 변화가 일어난 이유가 있다.   시초부터, Git 분산 버전 관리 도구의 기본 branch name은 master로 설정되었다.  모든 깃 repository는 master branch를 가지고 있었다. master branch는 소프트웨어 개발 분야에서 없어서는 안 될 역할을 담당하고 있었다.  많은 프로젝트들에서 master branch는 실제 소스, 즉 모든 테스트를 거친 잘 작동하는 코드라는 것을 의미했다.   하지만 master 라는 용어는 컴퓨터 세계에서나 다른 세계에서나 더 이상 사람들이 좋아하지 않는 용어이다. Git 그리고 Github은 다른 사람들과 다르지 않았다. 2020년 10월 1일부터, 새롭게 생성되는 모든 깃헙의 레퍼지토리는 main 이라는 이름의 기본 branch를 생성한다. 깃헙은 더이상 master라는 기본 브랜치를 생성하지 않는다.  왜 깃헙이 master 브랜치의 이름을 main 브랜치로 바꾸었는지, 그리고 이것이 개발자들에게 어떤 영향을 미칠지 알아보자.   문화적 정서  2020년 여름, 컴퓨터 산업이 master and slave라는 용어를 사용한다는 것이 모두의 주목을 받았다. 많은 시위와 커져가는 사회적 동요 속에서, 이 유해하고 한물간 용어는 더 이상 적합하지 않은 것으로 고려되었다.   Software Freedom Conservancy는 “Conservancy와 Git 프로젝트는 초기 브랜치 이름인 ‘master’가 일부 사람들에게 불쾌감을 준다는 것을 알고 있으며, 그 용어의 사용으로 인해 상처를 입은 사람들에게 공감합니다.”라고 말했다.   사람들이 생각하는 것과는 달리, 깃의 master 브랜치에는 특별한 기능이 없다.  사용자들은 레퍼지토리에 해를 입히지 않고 master 브랜치를 삭제하거나 제거할 수 없다고 생각한다. 이것은 잘못된 사실이다. master 브랜치는 레퍼지토리에 맨 처음 브랜치가 만들어졌을 때 함께 생성된 기본 설정된 이름이라는 점 빼고는 다른 브랜치들과 다른 점이 없다.    master 브랜치를 삭제하거나 이름을 바꾸거나 심지어는 삭제 후에 새로운 master 브랜치를 만들 수도 있다.   깃헙의 이런 변화는 과거의 만들어진 레퍼지토리에는 영향을 주지 않는다. 또한 만약 깃헙 사용자가 master라는 이름의 브랜치를 사용하고 싶다면 사용할 수 있다.  깃헙은 master라는 용어를 금지하는 것은 아니다. 그저 사용을 격려하지 않는 것일 뿐이다.   매사추세츠주 캠브리지에 있는 HubSpot의 수석 설계자인 Whitney Sorenson은 깃헙이 master 브랜치의 이름을 main으로 변경하며 얻을 이점이 한시적으로 겪을 장애물보다 훨씬 크다고 했다. 그는 이러한 변화가 회사 시스템에 차별이 없는 언어를 더하기 위한 보다 큰 내부 계획의 일부라고 말했다. 그의 팀은 또한 whitelist와 blacklist를 allowlist와 blocklist로 교체하고 있다. Sorenson은 이메일로 “지금 이러한 변화를 만드는 것에는 시간이 걸리지만 그건 단지 일회적인 기술적 희생일 뿐, 내부적으로나 외부적으로 모두에 지속적인 영향을 미칠 것이다.”라고 말했다. 또 그는 “우리는 이 일을 장기전으로 보고 있으며, 차별이 없는 언어는 사람과 사람 사이의 소통에서 중요한 만큼 우리가 코딩하고, 그것으로 어떤 것을 구축할 때도 중요하다는 것을 안다.”라고 했다.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Github","Article"],
        "url": "/til/mastertomain/",
        "teaser": "/assets/images/teaser.jpg"
      }]
