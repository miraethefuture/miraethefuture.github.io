var store = [{
        "title": "영단어 정리",
        "excerpt":"  🗂  A      access   to find information, especially on a computer    (주로 컴퓨터에서)정보를 찾는 것      Users can access their voice mail remotely.   whatever thing is accessed by the URL you supply        allow   to make something happen, especially something helpful or useful.    어떤일이 일어나는 것을 가능하게 만들다.        append   to add something to a piece of writing.    글에 어떤 내용을 덧붙이다.      덧붙이다   첨부하다        assign   to give a particular time, value, place etc to something.    특정 시간, 값, 장소등을 어떤 것에게 배정하다. (할당 / 대입하다.)      How much time have you assigned for the meeting?   첨부하다        automate   to start using computers or machines to do a job, rather than people    어떤 일을 하기 위해 사람 대신 컴퓨터나 기계를 사용하다.      Cash machines automates two basic function of a back - deposits and withdrawals.   Build tools are programs that automate the creation of executable applications from source cord.     🗂️  B      bypass   to avoid obeying a rule, system, or someone in an official position.    규칙, 시스템, 공식적인 자리에 있는 사람에게 복종하는 것을 피하는 것      Francis bypassed his manager and wrote straight to the director.   You can bypass basic setup steps that are already familiar to you.     🗂️  C      compatible   if two pieces of computer equipment of software are compatible, they can be used together, especially when they are made by different companies.     소프트웨어에서 사용되는 도구 두가지가 compatible 하다면, 그것은 두가지가 함께 사용될 수 있다는 것을 의미합니다. (특히, 다른 회사에서 만들어진 두가지 도구 일 때 말이죠.)      Will the software on my PC be compatible with a Mac?          configure   to arrange something, especially computer equipment, so that it works with other equipment.    어떤 것을 미리 준비해두다. 특히 다른 도구들과 함께 작동될 수 있도록 컴퓨터 도구들 준비해두다.      This project is configured to fit the exaples in this tutorial.        conform    to obey a law, rule etc 규칙에 순응하다.       An app that uses SwiftUI app life cycle has a structure that conforms to the APP protocol    SwiftUI 앱 라이프 사이클을 사용하는 앱은 그 앱의 프로토콜에 순응하는 구조를 가지고 있다.         consecutive   consecutive numbers or periods of time follow one after the other without any interruptions.    consecutive nunmbers 이나 consecutive peridos of time은 중간에 끊어짐 없이 계속해서 하나의 수가 다른 하나의 수를 따르는 것을 말합니다.      Can they win the title for the third consecutive season?     걔네 삼년 연속으로 우승할 수 있을까?     🗂️  D      define   to describe something correctly and thoroughly, and to say what standards limits qualities etc it has that make it different from other things     어떤 것을 명확히 묘사하는 것, 그리고 그것이 다른 것들과는 다른 어떤 기준, 한계 등을 가지고 있는지 말하는 것.      the ability to define clients' needs     🗂️  E      executable   a computer file that can be run as a program    프로그램으로 실행 될 수 있는 파일.   (명사 / 형용사 둘 다 executable)    🗂️  G      goes a long way towards(to)   If you say that something goes a long way towards doing a particular thing, you mean that it is an important factor in achieving that thing.    something 은 a particular thing 을 달성하기 위한 중요한 요소이다.      Implementing the trends will go a long way to building a functional site.   :: 그 트렌드를 구현하는 것은 잘 작동하는 사이트를 만들기 위한 중요한 요소가 될 것이다.    Although not a cure, it goes a long way towards making the patient's life tolerable.   :: 치료법은 아니지만, 그것은 환자의 삶을 견딜 수 있게 만드는데 큰 도움이 된다.      🗣️ goes a long way towards 발음 들어보기   🗂️  I      invoke   to operate a computer program    컴퓨터 프로그램을 작동시키다.      In small projects, developers often manually invoke the build process          instruction   a command given to a computer to carry out a particular operation.    특정한 일을 수행하기 위해 컴퓨터에게 주어진 명령어.      to put a set of instructions into a computer in a form that it can understand and use.     🗂️  M      manually   operated or done by hand or without the help of electricity, computers etc    기계나 전기의 도움 없이 사람으로부터 수행됨.      It would take too long to do a manual search of all the data.   In small projects, developers often manually invoke the build process        metadata   information that describes what is contained in large computer databases, for example who wrote the information, what it is for, and in what form it is stored    큰 컴퓨터 데이타베이스에 무엇이 저장되어 있는지 알려주는 정보이다. 예를 들면 누가 이 정보를 작성했고, 무엇을 위한 것이고, 어떤 형식으로 저장되었는지에 관한 정보를 알려준다.      Spring Boot Annotations is a form of metadata that provides data about a program.        map onto   to match something or have direct relationship with something    어떤 것을 연결하거나 직접적인 관계를 가지는 것.      Spring Boot Annotations is a form of metadata that provides data about a program.     🗂️  P     protocol   an established method for conneting computers so that they can exchange information    컴퓨터들이 서로 정보를 교환할 수 있는 방법        phase   one of the stages of a process of development or change    개발 또는 변화 중인 절차의 한 단계      a new drug that is in the experimental phase   the first phase of renovation should be done by January     🗂️  R      retrieve   to get back information that has been stored in the memory of a computer    큰 컴퓨터 데이타베이스에 무엇이 저장되어 있는지 알려주는 정보이다. 예를 들면 누가 이 정보를 작성했고, 무엇을 위한 것이고, 어떤 형식으로 저장되었는지에 관한 정보를 알려준다.      Spring Boot Annotations is a form of metadata that provides data about a program.        robust   a robust system, organization is strong and not likely to have problems    강하고, 문제가 쉽게 일어나지 않음      a robust metal cabinet   for a more robust way to communicate identity      🗂️  T      transfer   to copy recorded information from one system to another   시스템에 기록된 정보를 다른 시스템에 복사하는 것.      Spring Boot Annotations is a form of metadata that provides data about a program.     🗂️ U     underlying cause/principle/problem etc   the cause, idea etc that is the most important, although it is easily not noticed    알아차리기 힘들지만 가장 중요한 원인이나 아이디어.      the underlying causes of her depression      ","categories": ["vocabularies"],
        "tags": ["studying","learning","vocabularies"],
        "url": "/vocab/verb/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "JDBC로 오라클 클라우드 DB와 연결하여 이클립스 콘솔 창에 데이터 불러오기",
        "excerpt":"  💭 ..     맥북 유저에게 국비 수업이란...?    처음 국비 수업을 듣기로 결심했을 때 가장 걱정이 되었던 것은 나에겐 Windows 운영체제를 사용하는 랩탑이 없다는 것이었다. 국비 수업은 Windows를 기준으로 진행되기 때문에 macOS로 수업을 듣다가 문제가 생기면 강사님의 도움을 받기가 쉽지 않다. 수업 전 진행된 오티에서 강사님도 되도록이면 Windows를 사용할 것을 권했다. 나는 macOS를 사용한 지 오래되었고, 국비 수업을 듣기 전 독학하며 구글링 실력을 꽤 키웠다고 생각했기 때문에 굳이 Windows 운영체제의 랩탑을 구하려고 하지 않았다. 내가 혼자 해결할 수 있을 거라는 원인 모를(ㅎㅎ) 자신감이 있었다.  이클립스 IDE나 Java는 이미 설치해서 사용하고 있었기 때문에 수업 중 설치하는 시간에 문제가 없었다. 그 후로 쭉 문제없이 수업을 잘 들었다. 작은 에러들은 구글링으로 해결할 수 있었다. 그러던 중 데이터베이스에 대해 배우는 주가 시작되었다. 국비 수업이 시작되기 전, 수업에 대한 정보들을 검색해 보던 중 m1 칩 맥북은 오라클을 사용할 수 없다는 것을 알게 되었고 아래 도움이 된 글 목록 중 첫 번째에 있는 블로그의 글을 보고 미리 오라클 클라우드에 가입 후 DB를 생성하고 SQL Developer와 연동은 해둔 상태였다. 하지만 당시에는 DB와 Java로 작성된 프로그램을 연결하려면 JDBC를 이용해야 한다는 것을 몰랐다. DB와 Java를 연결하는 수업이 시작되었고 많은 분들이 JDBC driver를 다운로드하고 연결하는 과정에 어려움을 겪었다. 나도 다르지 않았다.  아무것도 모르던 4개월 전, 깃헙 페이지로 개발 블로그를 만들려고 구글링을 하며 오랜 시간을 삽질했던 때가 있었다. 그때는 한 가지 문제를 해결하려고 3일, 4일을 구글링하고도 원하는 답을 찾지 못할 때도 있었다. 그때의 기억이 떠올라서 식은땀이 쫙 났다.      'DB와 자바를 연결하지 못하면 수업을 듣기 힘들 텐데 어쩌나.. 밤을 새워서라도 해야겠다.'  라고 생각하고 있었는데 다행히 벌써 많은 분들이 애플 실리콘칩 맥북 + 오라클 클라우드 DB를 연동하는 방법에 대한 블로그 글을 올려주셨고 덕분에 생각보다 빠르게 해결할 수 있었다. 수업이 끝나기 전에 연결이 잘 되어서 엄청 기쁘고 다행이라는 생각이 들었다.     다음에 또 필요할 때를 대비해 기록을 남겨둔다. 국비 수업을 들으려는 다른 macOS 유저들에게도 조금이나마 도움이 되길 바란다.    🔦 도움이 된 글  1. Apple Silicon m1 맥북에서 Oracle Database 사용하기  2. Apple Silicon) M1 으로 oracle&amp;eclipse 연동하기 (3)  3. okky 쿠잉님 댓글   1. JDBC의 역할   JDBC는 DB와 Java를 연결해 주는 API입니다. 자바 언어로 작성한 프로그램에서 데이터 베이스에 접근하고 여러 가지 데이터와 관련된 작업을 수행할 수 있게 되죠. 예를 들면, 이클립스에서 몇 가지 자바 클래스와 메서드 그리고 SQL 문을 사용하여 직접 DB에 접근해 데이터를 검색, 추가, 삭제, 수정할 수 있게 되는 것입니다.   2. SQL Developer를 이용해 테이블 만들기   먼저 저는 SQL Developer를 이용하여 오라클 클라우드 DB에 간단한 테이블을 하나 만들어 주었습니다. 테이블 이름은 stardew_valley 입니다.                          VNAME       ADDRESS       AGE                       1       Gus       The Stardrop Saloon       48                 2       Abigail       Pierres General Store       24                 3       Sebastian       24 Mountain Road       26              3. Java 프로그램 내에서 연결된 DB의 데이터에 접근하기   먼저 작업하고 있는 Java project에 ojdbc8.jar를 추가합니다. 위 도움을 받은 글 목록 중 두번째 블로그 글을 보면 꼭 ojdbc8.jar을 받아야 한다고 하셨는데요. 저도 처음에 다른 버전으로 받았다가 제대로 실행되지 않는 문제를 겪었습니다.   import java.sql.*;  public class Jdbc_test {   public static void main(String[] args) {      String url = \"jdbc:oracle:thin:@데이터 베이스 이름_high?TNS_ADMIN=전자지갑 압출 풀어준 폴더의 경로\";     String userid= \"데이터베이스 userid\"; // 변경하지 않았다면 admin     String pwd = \"데이터베이스 접속 비밀번호\"; // DB 생성 시 지정했던 비밀번호       try{        // 오라클 드라이버 로딩       Class.forName(\"oracle.jdbc.OracleDriver\");        // DB에 연결       Connection con = DriverManager.getConnection(url, userid, pwd);        // sql문 작성 - DB에 저장되어있는 테이블에서 모든 레코드 정보 가져오기       String sql = \"select * from stardew_valley\"; // \"\"; 안에 sql문 작성 후 sql 변수에 할당        // 작성한 sql문을 DB로 전달하기 위해 연결       PreparedStatement ps = con.prepareStatement(sql);        // 실행 후 결과값을 ResultSet 타입의 변수에 할당       ResultSet rs = ps.executeQuery();        // 반복문 이용 결과값 출력       while(rs.next()) { // next() 메서드는 값이 있으면 true 반환 -&gt; 값이 없을 때가지 반복         String vname = rs.getString(\"vname\");         String address = rs.getString(\"address\");         int age = rs.getInt(\"age\");          // 임시 header 출력         System.out.println(vname + \"\\t\" + address + \"\\t\" + age);        }        // 연결되어있던 객체들 닫아주기       ps.close(); con.close(); rs.close();      } catch(Exception e) {       e.printStackTrace();     }   } }  실행하면 작성해 준 임시 header 아래로 위 표와 같은 모든 데이터를 console 창에 출력합니다.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Java","Oracle Cloud","Database"],
        "url": "/til/jdbc/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "A Swift Tour : 디지털 시계 앱을 만들며 스위프트 배워보기",
        "excerpt":"💭 ..     Swift는 어떤 언어일까?    디지털시계 앱을 만들며 Swift의 기초적인 것들을 알아봅니다.         1. ContentView와 ContentView_Previews  Intro to SwiftUI: Digital Clock &lt;- 블로그의 글을 보며 공부합니다.   //  ContentView.swift //  Your Digital Clock  import SwiftUI  struct ContentView: View {     @State var date = Date()     var body: some View {          ZStack {             Image(\"unsplash-photo\")             .resizable()             .scaledToFill()             .ignoresSafeArea()          VStack {              Text(\"\\(timeString(date: date))\")                  .font(.system(size: 160))                  .fontWeight(.bold)                  .foregroundColor(Color.white)                  .onAppear(perform: {let _ = self.updateTimer})                 // 여기 이해 안됨. date: date               Text(\"\\(greeting())\")                  .font(.system(size: 75))                  .foregroundColor(Color.white)               Text(\"\\(dateString(date: date))\")                  .font(.system(size: 20))                  .foregroundColor(Color.white)                  .onAppear(perform: {let _ = self.updateTimer})                  .offset(y: 100)                } // VStack            } // ZStack        } // body       // ContentView structure     var timeFormat: DateFormatter {         let formatter = DateFormatter()         formatter.dateFormat = \"hh:mm:ss a\"         return formatter     } // 시간 부분 Formatter      var dateFormat: DateFormatter {         let formatter = DateFormatter()         formatter.dateFormat = \"yyyy/MM/dd EEEE\"         return formatter     }      func timeString(date: Date) -&gt; String {         let time = timeFormat.string(from: date)         return time     }      func dateString(date: Date) -&gt; String {         let time = dateFormat.string(from: date)         return time     }       var updateTimer: Timer {         Timer.scheduledTimer(withTimeInterval: 1, repeats: true, block: { _ in             self.date = Date()         })     } // timeInterval 마다 블락 안의 코드가 실행됨      func greeting() -&gt; String {         var greet = \"\"          let midNight0 = Calendar.current.date(bySettingHour: 0, minute: 00, second:00, of: date)!         let nightEnd = Calendar.current.date(bySettingHour: 3, minute: 59, second: 59, of: date)!          let morningStart = Calendar.current.date(bySettingHour: 4, minute: 00, second: 0, of: date)!         let morningEnd = Calendar.current.date(bySettingHour: 11, minute: 59, second: 59, of: date)!          let noonStart = Calendar.current.date(bySettingHour: 12, minute: 00, second: 00, of: date)!         let noonEnd = Calendar.current.date(bySettingHour: 16, minute: 59, second: 59, of: date)!          let eveStart = Calendar.current.date(bySettingHour: 17, minute: 00, second: 00, of: date)!         let eveEnd = Calendar.current.date(bySettingHour: 20, minute: 59, second: 59, of: date)!          let nightStart = Calendar.current.date(bySettingHour: 21, minute: 00, second: 00, of: date)!         let midNight24 = Calendar.current.date(bySettingHour: 23, minute: 59, second: 59, of: date)!          if ((date &gt;= midNight0) &amp;&amp; (date &lt;= nightEnd)) {             greet = \"Good Night\"         } else if (date &gt;= morningStart) &amp;&amp; (date &lt;= morningEnd) {             greet = \"Good Morning\"         } else if ((date &gt;= noonStart) &amp;&amp; (noonEnd &gt;= date)) {             greet = \"Good Afternoon\"         } else if ((date &gt;= eveStart) &amp;&amp; (eveEnd &gt;= date)) {             greet = \"Good Evening\"         } else if ((date &gt;= nightStart) &amp;&amp; (midNight24 &gt;= date)) {             greet = \"Good Night\"         }          return greet      } // func greeting  } // ContentView 끝   struct ContentView_Previews: PreviewProvider {     static var previews: some View {         ContentView()         .previewInterfaceOrientation(.landscapeLeft)     } }  Xcode에서 처음 프로젝트를 열면 ContentView 그리고 ContentView_Previews라는 이름을 가진 두개의 structure가 기본적으로 생성되어 있습니다. 이 글에서는 이 두가지의 structure를 이용하여 간단한 디지털 시계앱을 만들어보며 시간/날짜 정보를 불러오는 방법에 대해 알아보겠습니다.   ContentView: View와 var body: some View에서 View는 이 structure가 View protocol을 따를 것이라는 의미입니다. Protocol은 요구사항을 가지고 있습니다. View 프로토콜의 가장 주요한 요구사항은 body property가 있어야 한다는 것입니다.   body property 부분에는 스크린에 나타날 view들이 작성됩니다. 이때의 view는 프로토콜 view가 아닌 Text view, Image view, Button view와 같은 SwiftUI의 built-in view 또는 외부 프레임의 view들을 말합니다. 위 코드에서는 ZStack의 하위에 Image view와 VStack이, 그리고 VStack 하위에는 Text view가 body property 안에 작성되었습니다.   2. 현재 날짜와 시간 정보 가져오기   struct ContentView: View {   @State var date = Date() }           ‘@State’ property wrapper는 해당 변수가 모니터링 되고 있다는 것을 의미합니다.            ‘Date()’는 사용자가 있는 지역의 날짜와 시간 정보를 가져옵니다.       import SwiftUI  struct ContentView: View {     @State var date = Date()     var body: some View {         VStack {           Text(\"\\(date)\")         }     } }  struct ContentView_Previews: PreviewProvider {     static var previews: some View {         ContentView()     } }   시간 정보는 초마다 계속해서 바뀌므로 property wrapper인 @State 를 사용해서 바뀐 시간을 계속해서 업데이트, 반영해 주고 문자열 date에 escape character \\ 를 추가해서 Date()를 담고 있는 date 변수의 할당되어 있는 정보를 문자열로 가져옵니다.   3. DateFormatter  import SwiftUI  struct dateString: View {     @State var date = Date()     var body: some View {         Text(\"\\(date)\")     } }  struct dateString_Previews: PreviewProvider {     static var previews: some View {         dateString()     } }   위 코드로 가져온 날짜/시간 데이터를 화면에 출력해봅니다. 아직 형식을 지정해주지 않았기 때문에 아래 사진처럼 보여집니다. 날짜, 시간, 분이라는 정보가 포함되어 있지 않고 나열된 문자열로써 나타납니다.      시간 부분의 형식을 먼저 지정해보겠습니다.   var timeFormat: DateFormatter {   let formatter = DateFormatter()   formatter.dateFormat = \"hh:mm:ss a\"   return formatter }   DateFormatter는 시간/날짜 데이터를 문자열 형식으로 보여지게 하는 Class입니다. dateFormat은 DateFormatter Class의 instance property입니다. 데이터를 받은 사람이 사용할 수 있는 날짜/시간 데이터의 형식 중 하나입니다.     hh - 12시간 표기법 시간   mm -  분   ss -  초   a - am/pm   그 다음으로는 가져온 시간 데이터를 문자열로 바꿔주는 function을 작성해봅니다.  func timeString(date: Date) -&gt; String {   let time = timeFormat.string(from: date)   return time }   여기까지 수정 👷   4. Live Time   SwiftUI가 State variable에 일어난 변화들을 감시합니다. @State는 스스로 변화를 만들지는 않습니다.  Date() initializer는 시간의 한 지점을 가져옵니다. 우리가 방금 만든 디지털 시계가 자동으로 흘러가지 않는 이유이죠.   우리가 보는 시계들처럼 초가 흘러가고 60초가 지나면 1분이 늘어나게 만드려면 매초마다 date variable을 새로 고침해주어야 합니다.  그러려면 Timer 객체를 사용하면 됩니다. Timer는 일정 시간이 지나면 특정 메세지를 타겟 객체에 보냅니다. Timer을 설정해주면 SwiftUI가 @State의 변화를 인식하고 그것에 따라 우리의 시계를 업데이트 해줄 것입니다.   Timer 객체를 생성하는 코드를 작성해봅니다.   var updateTimer: Timer {   Timer.scheduledTimer(withTimeInterval; 1, repeats: true,     block: {       self.date = Date()       })   }   scheduledTimer() 메서드를 이용합니다. 첫번째 인자는 withTimeInterval이고 시간의 간격을 입력해줍니다.  두번째는 repeat 입니다. 반복할 것인지 아닌지 bool 타입으로 입력해줍니다.  세번째는 block 입니다. Timer가 반복될 때마다 작동될 코드를 작성해줍니다.   아직은 초마다 시계가 움직이지 않죠? 한 단계가 더 남아있습니다. Text View 아래에 .onAppear modifier을 사용하여 Timer가 스크린에 나타나도록 해줍니다.   Text(\"\\(timeString(date: date))\")   .onAppear(perform: {let _ = self.updateTimer})   .onAppear(perform: action) 은 function modifier 입니다. View가 나타나면 action을 수행합니다. self.updateTimer function은 저장할 필요가 없는 값을 반환하기 때문에 ‘let _‘을 사용했습니다. underscore 는 아무것도 할당하고 싶지 않다는 것을 나타냅니다. 이 스텝까지 잘 마치셨다면 디지털 시계가 초마다 움직이는 것을 볼 수 있을 것입니다!   5. Time of Day Greeting   시간에 따라 달라지는 인사말을 추가해볼 것입니다.     4:00:00am to 11:59:59am -&gt; Morning   12:00:00pm to 4:59:59pm -&gt; Afternoon   5:00:00pm to 8:59:59pm -&gt; Evening   8:00:00pm to 3:59:59am -&gt; Night  위의 기준으로 시간을 나누고 각 시간대의 인사말이 시계 아래에 나타나도록 해봅시다.   func greeting() -&gt; String {         var greet = \"\"          let midNight0 = Calendar.current.date(bySettingHour: 0, minute: 00, second:00, of: date)!         let nightEnd = Calendar.current.date(bySettingHour: 3, minute: 59, second: 59, of: date)!          let morningStart = Calendar.current.date(bySettingHour: 4, minute: 00, second: 0, of: date)!         let morningEnd = Calendar.current.date(bySettingHour: 11, minute: 59, second: 59, of: date)!          let noonStart = Calendar.current.date(bySettingHour: 12, minute: 00, second: 00, of: date)!         let noonEnd = Calendar.current.date(bySettingHour: 16, minute: 59, second: 59, of: date)!          let eveStart = Calendar.current.date(bySettingHour: 17, minute: 00, second: 00, of: date)!         let eveEnd = Calendar.current.date(bySettingHour: 20, minute: 59, second: 59, of: date)!          let nightStart = Calendar.current.date(bySettingHour: 21, minute: 00, second: 00, of: date)!         let midNight24 = Calendar.current.date(bySettingHour: 23, minute: 59, second: 59, of: date)!          if ((date &gt;= midNight0) &amp;&amp; (date &lt;= nightEnd)) {             greet = \"Good Night.\"         } else if (date &gt;= morningStart) &amp;&amp; (date &lt;= morningEnd) {             greet = \"Good Morning\"         } else if ((date &gt;= noonStart) &amp;&amp; (noonEnd &gt;= date)) {             greet = \"Good Afternoon.\"         } else if ((date &gt;= eveStart) &amp;&amp; (eveEnd &gt;= date)) {             greet = \"Good Evening.\"         } else if ((date &gt;= nightStart) &amp;&amp; (midNight24 &gt;= date)) {             greet = \"Good night.\"         }          return greet      }   Calendar.current.date(bySettingHour…) 메서드는 주어진 date 데이터에 특정한 시간을 나타내는 variable을 만듭니다. 여기서는 우리가 위에서 만든 @State date가 주어진 날짜 데이터입니다.   아래 부분은 나누어 놓은 시간대와 현재 시간을 비교하는 부분입니다. 현재 시간과 비교해서 해당되는 인사말을 greet 변수에 담고 반환합니다. 여기까지 하면 시간을 스크린에 띄우는 것은 완성!   … 디지털시계 만들기는 계속 됩니다.      ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift"],
        "url": "/til/basicSwift2/",
        "teaser": "/assets/images/yourDigitalClock.png"
      },{
        "title": "SwiftUI Tutorial: 여러 개의 View를 만들고 결합하기",
        "excerpt":"SwiftUI Tutorial을 따라가며 아래 Landmark앱을 만들어 보겠습니다. 튜토리얼의 출처는 SwiftUI Essentials: Creating and Combining Views 입니다.      ☑️ What I Learned From This Tutorial:      SwiftUI 프레임워크와 다른 프레임워크를 함께 사용하는 방식   여러개의 파일을 하나의 View로 합치기   Stack의 사용법   지도와 관련된 Structures   alignment: .leading   Divider()   Spacer()              1. Stacks을 이용해 텍스트 배치하기: ContentView.swift   // ContentView.swift // Landmarks  import SwiftUI  struct ContentView: View {   var body: some View {      VStack(alignment: .leading) {          Text(\"경복궁\")             .font(.title)             .foregroundColor(.black)          HStack {              Text(\"Gyeongbokgung Palace\")                 .font(.subheadline)             Text(\"Korea\")                 .font(.subheadline)         } // HStack 끝         .font(.subheadline)         .foregroundColor(.secondary)          Divider()         Text(\"About Gyeongbokgung\")             .font(.title2)         Text(\"Gyeongbokgung, also known as Gyeongbokgung Palace or Gyeongbok Palace,         was the main royal palace of the Joseon dynasty.         Built in 1395, it is located in northern Seoul, South Korea.\")             .font(.body)      } // VStack     .padding()   } }  struct ContentView_Previews: PreviewProvider {   static var previews: some View {       ContentView()     } }   이 부분에서는 Stack과 Spacer()를 이용해서 Text view를 배치하는 것에 대해 알아보았습니다. .foregroundColor(.secondary)는 옅은 회색을 화면에 보여줍니다. alignment가 기본적으로는 가운데로 지정되어 있고 왼쪽 정렬을 하려면 (alignment: .leading)을 사용하면 됩니다.    아래는 위 코드가 화면에 그려진 결과입니다. Divider()를 이용해 콘텐츠를 나누는 줄을 그릴 수 있습니다.      2. 지도와 관련된 데이터 불러오기: MapView.swift   // MapView.swift // Landmarks  import SwiftUI import MapKit  struct MapView: View {     @State private var region = MKCoordinateRegion(         // 경복궁의 위도와 경도         center: CLLocationCoordinate2D(latitude: 37.580_535, longitude: 126.977_341),         span: MKCoordinateSpan(latitudeDelta: 0.05, longitudeDelta: 0.05)         )      var body: some View {         Map(coordinateRegion: $region)     } }  struct MapView_Previews: PreviewProvider {     static var previews: some View {         MapView()     } }   SwiftUI 프레임워크를 추가하고 그 외에 또 다른 프레임 워크를 추가하면,  (여기서는 MapKit라는 프레임워크를 추가했습니다.)  추가된 프레임워크와 관련된 SwiftUI의 특정 기능에 접근할 수 있게 됩니다.   MKCoordinateRegion는 위도, 경도로 표시된 특정 좌표 평면상의 지역을 직사각형의 형태로 가져오는 Structure입니다. 위 코드에서는 가져온 지역 정보를 region이라는 이름의 private state variable에 담았습니다.   center: 와 span:은 파라미터 입니다.  center: 는 가운데 오게 될 지역의 위도, 경도  span: 은 지도가 보여질 크기를 나타내는 horizontal span과 vertical span이 들어올 것입니다.   CLLocationCoordinate2D은 국제 좌표계를 기준으로 특정 지역의 위도 경도를 이용하여 지역 좌표 object를 생성하는 Structure입니다. center: 파라미터를 지나는 값이니 생성된 좌표 object를 중심점으로 사용한다는 뜻이겠죠?   MKCoordinateSpan은 지도로 표현된 지역의 가로와 세로 크기를 표현하는 Structure입니다. delta values를 이용해서 원하는 줌 레벨을 설정할 수 있습니다. delta value이 커지면 줌 레벨은 작아집니다. delta value가 작아지면 줌 레벨을 커지면서 더 가까이 지도를 볼 수 있습니다.   body property의 Map()은 Generic Structure로, 사용할 지도 인터페이스를 보여주는 역할을 합니다. 위 코드에는 표현되지 않았지만 사용자의 위치를 보여주거나 이동경로를 추적하는 등의 기능을 합니다.  아래는 위 코드가 화면에 그려진 결과입니다. 더블 클릭을 하여 화면을 확대하거나, 양쪽으로 끌어 움직일 수 있습니다.        3. 동그라미 모양으로 이미지 잘라내기: CircleImage.swift   //  CircleImage.swift //  Landmarks  import SwiftUI  struct CircleImage: View {     var body: some View {         Image(\"kbpalace\")             .clipShape(Circle())             .overlay {                 Circle().stroke(.white, lineWidth: 4)             } //overlay {}             .shadow(radius: 7)     } }  struct CircleImage_Previews: PreviewProvider {     static var previews: some View {         CircleImage()     } }  이 부분에서는 .clipShape(Circle()) 메서드를 사용하여 이미지를 동그랗게 잘라냅니다. .overlay 부분에서는 테두리가 될 부분을 만들어 줍니다. overlay 메서드는 레이어를 만들어 줍니다. 우리가 앞에서 만들었던 동그라미 모양의 사진 위에 레이어가 한층 생기는 거죠. Circle().stroke(.white, lineWidth: 4)는 동그라미 모양의 테두리를 그려줍니다. .shadow는 그림자를 그려줍니다.     4. Views를 결합하기   //  ContentView.swift //  Landmarks  import SwiftUI  struct ContentView: View {     var body: some View {         VStack {             MapView()                 .ignoresSafeArea(edges: .top)                 .frame(height: 300)              CircleImage()                 .offset(y: -130)                 .padding(.bottom, -130)              VStack(alignment: .leading) {                 Text(\"경복궁\")                     .font(.title)                 .foregroundColor(.black)                 HStack {                     Text(\"Gyeongbokgung Palace\")                         .font(.subheadline)                     Spacer()                     Text(\"Korea\")                         .font(.subheadline)                 } // HStack                 .font(.subheadline)                 .foregroundColor(.secondary)                  Divider()                 Spacer()                 Text(\"About Gyeongbokgung\")                     .font(.title2) //                Spacer()                 Text(\"Gyeongbokgung, also known as Gyeongbokgung Palace or Gyeongbok Palace, was the main royal palace of the Joseon dynasty. Built in 1395, it is located in northern Seoul, South Korea.\")                     .font(.body)                 Spacer()               } // VStack             .padding()              Spacer()         } // 가장 바깥쪽 VStack      } }  struct ContentView_Previews: PreviewProvider {     static var previews: some View {         ContentView()     } }    이제 위에서 만든 모든 View 들은 합쳐줍니다. .offset() 메서드의 y 파라미터의 값을 주어 원래의 dimension에서 콘텐츠를 조금 올려줍니다. .offset() 메서드가 없다면 VStack 안에서 겹치지 않고 나열되어 있을 것입니다.       ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift"],
        "url": "/til/landmarks/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Codility_Developer Training: 배열 챕터의 문제 CyclicRotation",
        "excerpt":"CyclicRotation 문제 읽기   1. 문제를 파악해보자   N개의 정수로 이루어진 배열이 주어집니다. 배열의 Rotation이란 각각의 element를 오른쪽 인덱스로 옮긴다는 뜻입니다. 맨 마지막 인덱스에 있던 요소는 첫 인덱스로 이동합니다.   //the rotation of array A A = [3, 8, 9, 7, 6] // is A = [6, 3, 8, 9, 7]  위의 예제는 배열 A를 한번 rotate한 결과입니다.   목표는 배열 A를 K번 오른쪽 인덱스로 한칸씩 이동시키는 것입니다.   [3, 8, 9, 7, 6] -&gt; [6, 3, 8, 9, 7] [6, 3, 8, 9, 7] -&gt; [7, 6, 3, 8, 9] [7, 6, 3, 8, 9] -&gt; [9, 7, 6, 3, 8]  위의 예제는 3번 rotate한 결과입니다.   2. 로직을 생각해보자   일단 아직은 더 익숙한 언어인 Java로 구체적인 수를 적용하여 코드를 작성해봅니다.  package array;  public class CyclicRotaion {   public static void main(String[] args) {      // 주어진 배열     int[] A = {3, 8, 9, 7, 6};      // 마지막 인덱스의 값 빈 변수에 할당하기     int p = A[A.length-1];      // 한칸씩 옮기기     A[A.length-1] = A[A.length-2];     A[A.length-2] = A[A.length-3];     A[A.length-3] = A[A.length-4];     A[A.length-4] = A[A.length-5];      // 0번째 인덱스에 옮겨두었던 마지막 인덱스 값 할당하기     A[A.length-5] = p;      for(int i = 0; i &lt; A.length; i++) {       System.out.print(A[i] + \" \");     } // for문   } }  위 코드의 실행 결과는 6, 3, 8, 9, 7입니다.   3. 이클립스에서 작성한 문제 해결 코드   package array;  import java.util.Scanner;  public class CyclicRotaion {   public static void main(String[] args) {        // 주어진 배열       int[] A = {3, 8, 9, 7, 6};        // 마지막 인덱스의 값 빈 변수에 할당하기       // 배열의 크기에 상관없이 항상 마지막 인덱스 값을 나타냄.       int p = A[A.length-1];        for(int i = 1; i &lt;= (A.length-1); i++) {           A[A.length-i] = A[A.length-(i+1)];       }        // 0번째 인덱스에 옮겨두었던 마지막 인덱스 값 할당하기       A[A.length-A.length] = p;        // 배열의 값을 출력하는 for문       for(int i = 0; i &lt; A.length; i++) {           System.out.print(A[i] + \" \");       }   } }  반복되는 부분을 for문을 사용하여 작성해줍니다.   4. 코딜리티에 제출한 문제 해결 코드   아래는 최종 정리해서 코딜리티에 제출한 코드입니다.   class Solution {   public int[] solution(int[] A, int K) {     // write your code in Java SE 8      int p = 0; // 마지막 인덱스의 값 옮겨둘 변수      while(K &gt;= 1) { // while문 사용하여 반복할 횟수 K이용        p = A[A.length-1];        for(int i = 1; i &lt;= (A.length-1); i++) {            A[A.length-i] = A[A.length-(i+1)];          } // for문 끝        A[A.length-A.length] = p;       K--;      } // while 문 끝      return A;   } // 메서드 끝 }        내가 푼 풀이의 정확도는 87%        분석 결과를 보니 빈 배열이 입력되었을 때 프로그램이 꺼지는 문제가 발생.   … 문제 해결은 계속됩니다.   추가해야 할 글      문제 해결 과정   빈 배열이 입력되었을 때 프로그램이 꺼지는 문제 해결하기  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Codility","코테"],
        "url": "/til/cyclicRotation/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "JavaScript: 팝업창 가운데에 띄우기",
        "excerpt":"아무런 설정을 하지 않고 window.open() 메서드를 사용해서 팝업창을 띄웠더니 화면 맨 왼쪽 위에 팝업창이 나타납니다. 이 팝업창을 가운데로 옮겨보았습니다.   도움을 받은 글: How to center a popup window on screen?   1. &lt;head&gt;태그 안에 JS function 작성하기     &lt;!DOCTYPE html&gt;   &lt;html&gt;   &lt;head&gt;     &lt;title&gt;Title of the document&lt;/title&gt;     &lt;script type=\"text/javascript\"&gt;             function login_window(url, title, w, h) {                 var left = (screen.width - w) / 2;                 var top = (screen.height - h) / 2;                 var myWindow = window.open(url, title, 'resizable=yes, width=' + w + ', height=' + h + ', top=' + top + ', left=' + left);             }     &lt;/script&gt;   &lt;/head&gt;  script 태그 안에 자바 스크립트 function을 작성해 줍니다.   저는 로그인하는 팝업창을 띄우는 것이라 function의 이름을 login_window라고 하였습니다. url, title, w, h와 같이 네 개의 파라미터를 작성해 줍니다. 이때는 파라미터의 이름이라 아무 이름이나 적어줍니다.   left, top 변수   두 개의 변수를 만들어 줍니다. 각각의 변수에는 (전체 스크린 한 면의 길이 - 내 팝업창 한 면의 길이) / 2 값이 할당됩니다. 그 값이 내 팝업창의 왼쪽 면의 위치, 위쪽 면의 위치가 됩니다.   window.open() 메서드   window.open() 메서드에 파라미터를 작성해 줍니다. 이때는 function에서 적어주었던 파라미터를 이용합니다. url, title은 똑같이 작성해 주고 resizable은 yes, width에는 function의 파라미터를 통과해서 들어온 w를 사용, height에는 h를 사용합니다. left와 top 변수도 사용합니다.   2. body 태그 부분 작성     &lt;body&gt;     &lt;ul&gt;         &lt;li class=\"signin-btn\" onclick=\"login_window('signin.html', 'Sign in to Otopi', '380', '500')\"&gt;&lt;span&gt;Sign in&lt;/span&gt;&lt;/li&gt;     &lt;/ul&gt;   &lt;/body&gt;  body 부분에 function을 사용할 곳에 function 이름과 파라미터를 사용하여 작성해 줍니다. 제가 만든 웹 페이지에서는 Sign in이라는 리스트를 클릭하면 팝업창이 생성됩니다. 클릭 시 function login_window가 실행됩니다. 파라미터를 통해 팝업창의 url, title, w, h의 크기를 전달합니다. 크기를 작성할 때 px을 적지 않도록 주의해 줍니다.   3. 가운데 정렬된 모습     ","categories": ["TIL"],
        "tags": ["learning","공부 기록","HTML","CSS","JavaScript"],
        "url": "/til/popup-center/",
        "teaser": "/assets/images/main_octopi.png"
      },{
        "title": "Playgrounds: Learn to Code 1",
        "excerpt":"Playgrounds: Learn to Code 1  아래 모든 내용들은 Playgrounds에서 학습하며 정리한 내용입니다.    모든 내용의 출처는 Playgrounds임을 밝힙니다.   Function: Grouping Tasks   Function은 여러개의 commands를 하나로 묶어 이름을 붙인 것입니다.    그리고 아무때나 원할 때 호출하여(call) 사용할 수 있습니다.     func tieMyShoe() {     loop()     swoop()     pull()   }      func 키워드 사용   function에 이름을 지어줍니다.   function은 언제나 이름 뒤에 ()를 붙여줍니다.   curly braces(중괄호 { }) 안에 commands를 추가해줌으로써 function이 어떤 기능들을 수행할지 정합니다.   필요할 때 언제든 tieMyShoe() 라는 이름을 사용하여 호출, 사용할 수 있습니다.   Composition   가끔씩 coding problem을 해결하려면 새로운 behavior을 수행하기 위해서 기존의 가지고 있던 commands를 혼합하여 함께 사용해야 할 떄가 있습니다. 이 과정을 compositon이라고 합니다. 원하는 행동을 수행할 command는 없지만 기존의 code를 합침으로써 원하는 행동을 할 수 있게 됩니다. 만약 여러번 같은 compositon을 수행해야 한다면 어떨까요? 그렇다면 여러개의 혼합된 코드를 여러번 사용하게 됩니다. 이럴때는 이 composition을 하나로 묶어 function으로 만들 수 있습니다.   function을 사용하므로써 코드를 간단하게 만들고 복잡한 일도 더 간단하게 처리할 수 있습니다.      반복되는 패턴을 파악합니다.   그 패턴을 function으로 만듭니다.   Decomposition   function 안에 다른 function을 호출할 수 있습니다. 더 큰 문제를 더 작은 조각으로 나누는 과정을 Decomposition이라고 합니다. 작은 일을 처리하는 function을 만들고 다른 funtion안에 그 functions을 사용하므로서 더 큰 문제를 해결하는 것 - 더 큰 문제를 작은 function으로 나누는 것을 Decomposition 이라 합니다.   Decompose a solution across multiple Function   작은 tasks를 해결하는 functions을 이용하는 것은 도움이 됩니다. 이 작은 일을 처리하는 function을 다른 function안에서 호출하므로써 더 큰 task를 해결 할 수 있게 됩니다. 더 작은 function으로 나누는 것은 코드의 가독성도 높여줍니다. 보통 function의 이름은 각 기능을 나타내도록 짓기 때문이죠.   또, 코드를 작성하는 과정을 단순화 시켜줍니다. 더 큰 task를 해결하기 위한 function을 작성한 뒤에는 작은 일을 처리하는 각각의 commands들은 신경쓰지 않을 수 있죠.      작은 명령 패턴을 찾는다.   명령들을 호출하는 function을 만든다.   만들어진 function으로 문제를 해결한다.   앱을 만든다는 것은 엄청나게 많은 작은 문제들의 해결방법을 찾는 것입니다. 작은 문제들의 해결책을 찾은 뒤에 코더들은 그 해결책을 모아 더 큰 문제를 해결합니다.   📖 틈새 영어 단어: Tweak      Tweak the code inside solveRow():     tweak은 작은 변화를 만든다는 뜻입니다.    For loops      ‘for’ 키워드를 사용합니다.   loop가 실행 될 횟수를 적어줍니다.   curly braces 안에 반복할 commands를 적어줍니다.     for eachSeed in 1...4 {     makeHole()     placeSeed()     moveFiveInchesForward()   }   앞서 coding tasks를 분할하기 위해 문제를 해결하며 반복되는 패턴을 function으로 만들어 보았습니다. 이제 loop를 이용하며 한 function을 여러 번 반복해서 호출할 수 있습니다. 어떤 코드를 순서대로 실행하는 것을 반복하는 것입니다. loops를 이용하면 반복해서 해야 할 일을 단순화 시킬 수 있습니다.      먼저 가장 가까이 있는 작은 문제를 해결할 패턴을 찾습니다.   다음 문제에서도 이 패턴이 적용되는지 알아봅니다.   적용이 된다면 반복합니다.   해결할 수 있는 작은 문제에 대한 해결책을 찾고 여러 개의 해결책을 모아 큰 문제를 해결하는 것은 좋은 문제 해결 방법 접근입니다.   Conditional Code   예상할 수 없는 것에 대해 어떻게 계획을 짤까요?    코드 안에서는 if문을 이용하여 각기 다른 조건들에 대한 계획을 짭니다.     if lightIsGreen {     moveForward()   } else {     wait()   }     ‘if’ 키워드를 사용합니다.   참 / 거짓으로 답할 수 있는 조건을 적어줍니다.   조건이 참(true)일 때 실행 할 commands를 if block 안에 적어줍니다.   조건이 false 일 때 실행될 코드는 else를 이용해서 적어줍니다.   메세지가 오’면’ 메세지가 왔다는 알림 소리가 울리고, 사파리는 웬 사이트를 열기 전에 인터넷이 연결되어 있는지 확인합니다. 연결되어 있다’면’ 웹사이트로 이동하죠.   Boolean condition   if - else문에서 if의 Boolean 조건이 true이면 if {} 안의 코드가 실행되고   false이면 else {} 안의 조건이 실행됩니다.     func solveRightSide() {     if isOnGem {       turnLeft()       collectGem()     }   }    for i in 1...2 {     solveRightSide()     moveForward()   }   위와 같은 방식으로도 사용할 수 있습니다. function안에 if문을 작성하고 for문을 이용해서 fuction을 호출하는 방식입니다. 이렇게 하므로써 코드를 재사용할 수 있습니다.   👷‍♂️ 여기까지 정리  Logical Operators   code에서 operator는 action을 보여주는 심볼입니다. 논리연산자는 조건문을 더 명확하게 특정지어줍니다.     &amp;&amp; (AND)                                               (OR)                           ! (NOT)   위의 각 연산자들은 각자의 방법으로 조건문을 변화시킵니다.      AND(&amp;&amp;) 논리 연산자는 모든 조건들이 true일 때만 코드가 실행됩니다.                                   OR(                       ) 논리 연산자는 조건 중 적어도 하나가 true일 때 코드가 실행됩니다.                           NOT(!) 논리 연산자는 조건을 반대로 만듭니다.   While Loops   While loop는 반복할 횟수가 명확히 정해져있지 않을 때 어떤 조건이 true인 동안 { } 안에 작성된 코드를 반복해서 실행합니다. 조건문과 함께 while 반복문을 사용하면 좀 더 다양한 상황에 문제를 해결할 수 있습니다.    때때로 coding problem을 어떻게 해결하는지는 어떤 옵션이 더 낫게 느껴지는지에 따라 정해집니다. coder들은 더 빠른 결과를 내는 해결책, 또는 재사용성이 높은 것이 어떤 것인지 자신의 의견에 기초에 결정하게 됩니다.   코딩에서는 문제와 여러개의 해결책들 중 어떤 것을 선택하는지에 대해 배우는 것이 중요합니다. 때때로 한 문제에 대한 어떤 접근은 다른 것과 비슷하게 문제를 해결하고 어떤 것은 다른 해결책보다 더 효율적이고, 재사용이 가능하고, 많은 상황에 적용 가능하기도 합니다. 적절한 도구(approprite tools)를 결정하는 힘이 길러집니다.   Land of bounty 다시 해보기  더 효율적인 방법 찾아보기   Nesting loops   nest one loop inside another은 루프안에서 다른 루프를 사용하는 것을 의미합니다. 루프 안에서 사용된 루프를 nested loops라고 합니다. 이때 바깥쪽의 루프를 Outer loop 안쪽의 루프는 inner loop라고 합니다. 다양한 상황에서 nested loops를 사용할 수 있습니다.   while loop와 Boolean 타입의 조건을 함께 사용할 때는 조건이 언제가는 false가 되야합니다. 만약 계속해서 true가 되면 무한 반복하는 infinite loop이 되고 이것은 컴퓨터를 멈추게 만들 수도 있습니다.      Algorithms   알고리즘은 규칙의 집합 그리고 그것을 기반으로 한 지시입니다. 예를 들어 네비게이션은 목적지로 가는 가장 빠른 길을 찾는 알고리즘을 이용합니다. 이때 알고리즘은 거리와 평균 속도를 비교하고, 현재의 교통량을 이용하여 가장 짧은 루트를 찾습니다. 알고리즘은 다양한 상황에서 적용 가능합니다.   알고리즘을 코드로 적용하기 전에 pseudocode를 이용하여 먼저 생각해볼 수 있습니다. pseodocode는 코드와 비슷한 형태이지만 진짜 코드는 아닌, 사람이 이해할 수 있는 언어로 만든 코드와 비슷한 구조를 가지고 있는 형태입니다.     navigate around wall {     if a block is on right side {       go forward     } else if blocks are in the front and on the right {       turn left       go forward     } else {       turn right       go forward     }   }   pseudocode의 예시입니다. 진짜 작동하는 코드아니고 알고리즘을 만들기 위해 생각을 코드의 구조로 나타낸 것입니다.   다른 상황에서 동일하게 적용되는 알고리즘을 만드는 것이 코딩의 힘입니다. 다양한 상황에서 문제를 해결하는 프로그램을 만드는 것이죠. 에를 들어 search engine의 algorithms은 우리가 검색한 단어가 무엇이든 원하는 정보를 주기 위해 엄청나게 많은 웹사이트의 정보를 동일한 방식으로 처리합니다.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","Playgrounds"],
        "url": "/til/playgrounds/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Navigating Apps: About Me",
        "excerpt":"Sample Apps Tutorials: About Me(Navigating Apps)  아래 모든 정보의 출처는 apple developer 공식 페이지이며 개인의 학습 용도로만 사용되었음을 밝힙니다.   All information below comes from the official apple developer page and is for personal learning purposes only.   Navigating Apps: About Me   Section 1: Tabbed Interface   탭 형태의 interface를 만드는 방법에 대해 알아봅니다.   ContentView view   ContentView view는 처음 앱이 열리면 보게 될 화면을 나타냅니다. User interface(UI)는 body부분에 생성됩니다.   TabView     struct ContentView: View {     var body: some View {       TabView {         // place tab views here!         HomeView()             .tabItem {               Label(\"Home\", systemImage: \"person\")             }       }     }   }   TabView를 사용해서 tab UI를 생성할 수 있습니다. Tab view 안에 원하는 tab item 목록을 작성해줍니다.   tab을 만들기 위해서…     tab을 눌렀을 때 보여지길 원하는 view의 instance를 생성합니다. 첫번째 tab이 앱을 열었을 때 가장 먼저 보이는 view가 됩니다.   HomeView view 아래에 dot notation을 이용하여 .tabItem modifier를 추가해줍니다. tabItem이 없다면 tab은 텅 비어있는 상태로 나타납니다.   Label view의 Title, Icon 패러미터를 이용하여 tab에 이름을 붙여주고 아이콘을 생성해줍니다. tabItem modifier는 오직 Label, Text, Image views만 허용합니다. Button과 같은 다른 view들은 비어있는 탭을 만듭니다.     Section 2: Your Data   app의 데이터를 수정하기   Data.swift   샘플 프로젝트에 app의 모든 Data만 따로 담은 파일이 있습니다. SwiftUI에서는 앱의 데이터를 앱의 visual components와 따로 분리하는 것이 가장 좋은 방법입니다. SwiftUI에 대해서 배우는동안 ‘“source of truth”를 가진다’라는 개념을 자주 접하게 될 것입니다. 이것은 한 value를 오직 한 장소에서만 정의한다는 의미입니다. 데이터를 변경해보며 이것에 대해 더 알아볼 것입니다.   데이터의 설계도     import Foundation   import SwiftUI    struct Info {       let image: String       let name: String       let story: string       let hobbies: [String]       let foods: [String]       let colors: [Color]       let funFacts: [String]   }    let information = Info(      )   struct Info { }는 앱 데이터의 설계도(또는 청사진, blueprint)를 제공합니다. 이것은 앱이 가지고 있는 데이터의 type과 이름을 정의하는 속성들(properties)을 가지고 있습니다. 위에 코드에서 알 수 있듯이 이 앱의 데이터는 String type의 story property와 Color 값들의 배열인 colors property를 가지고 있습니다. 이   Data value와 전역변수     import Foundation   import SwiftUI    struct Info {       let image: String       let name: String       let story: string       let hobbies: [String]       let foods: [String]       let colors: [Color]       let funFacts: [String]   }    let information = Info(       image: \"Placeholder\",       name: \"Future\",       story: I'll be an awesome developer.\\n• 🐶🐱🛶️🎤🎧\\n•       🏄‍♀️♀️🥾🏂⛷📚 \",       hobbies: [\"bicycle\", \"ticket.fill\", \"book.fill\"],       foods: [\"🥐\", \"🌮\"],       colors: [Color.blue, Color.purple, Color.pink],       funFacts: [           \"The femur is the longest and largest bone in the human body.\",           \"White sand beaches are made of parrotfish poop.\",       ]   )   위의 information value는 데이터를 담기 위해 Info structure을 사용합니다. 이것은 전역 변수(global variable)로 프로젝트안 어떤 폴더에서든 변수의 이름을 사용하여 이용할 수 있습니다.   The source of truth   위에서 information의 name에 값을 주었다. name의 값은 딱 한 번 만 생성되고 이것은 source of truth를 만든다. 언제든, 어떤 component, 어떤 view에서든 name을 사용하고 싶다면    information.name  이라는 이름을 이용하여 조회할 수 있다.   Section 3: Home Tab   기본적인 SwiftUI 코드에 대해 알아봅니다.   HomeView.swift   이 프로젝트에서 HomeView는 첫번째 탭에 해당됩니다. 첫번째 탭은 앱을 처음 열었을 때 보게 되는 화면입니다. HomeView view의 body부분에는 화면에 그려지는 컨텐츠들이 작성됩니다.     var body: some View {         VStack {             Text(\"All About\")                 .font(.largeTitle)                 .fontWeight(.bold)                 .padding()              Image(information.image)                 .resizable()                 .aspectRatio(contentMode: .fit)                 .cornerRadius(10)                 .padding(40)              Text(information.name)                 .font(.title)         }     }   Views와 Modifiers      VStack: VStack은 컨텐츠를 화면의 위에서 아래로, 수직 방향으로 배치합니다.   Text(“string”): quotation marks 안에 있는 문자열을 화면에 보여줍니다. Text의 스타일을 바꾸기 위해 modifiers를 사용했습니다. (.font()/.fontWeight())   .padding(): 서로 다른 view들 사이에 각 view를 둘러싼 공간을 추가합니다. 괄호안에 값을 적지 않으면 SwiftUI의 기본 패딩이 적용됩니다. 값을 넣어 커스텀할 수 있습니다.   Image(): 여기서 Image view는 Data file에서 바꿔주었더너 이미지를 보여줍니다. information.image 라는 이름을 사용하나 것이 보입니다.   .resizable: resizable modifier는 화면에 사용 가능한 공간에 이미지를 적용시킵니다. 만약 resizable modifier를 사용하지 않으면 이미지의 full size로 나타나게 됩니다.   .aspectRatio: image가 원래의 비율로 유지되도록 합니다. .fit으르 사용하면 SwiftUI가 사용가능한 공간에 맞는 사이즈로 이미지 사이즈를 변경합니다. (.fill은 화면을 채우는 방식)   .cornerRadius: 어떠 view든 모서리를 둥그렇게 만들 수 있습니다.   Section 4: Story Tab   스크롤 뷰를 이용하는 방법에 대해 알아봅니다.   ScrollView   Text의 문자열이 너무 길어져서 한 화면에 담지 못하게 되면 ScrollView를 사용하여 스크롤 할 수 있습니다.    ScrollView {      Text(information.story)          .font(.body)          .padding()        }  information.story는 Data file에서 입력했던 story를 담고 있습니다.   Section 5: Favorite Tab   여러개의 다른 stacks와 loops를 사용해서 UI 만들기   ForEach(_:)     HStack {       ForEach(information.hobbies, id: \\.self) { hobby in           Image(systemName: hobby)               .resizable()               .frame(maxWidth: 80, maxHeight: 60)        }       .padding()   }   .padding()  여기서 ForEach문은 Data file의 information.hobbies 배열의 각 item들을 id: \\.self로 구분하여 접근합니다.   ##13 Section 6: Fun Facts Tab   랜덤으로 정보를 화면에 띄우는 버튼을 추가해서 interactive한 앱을 만들어 봅니다.   Button view   이 챕터에서는 Button을 누를때마다 다른 문자열 정보를 화면에 출력하는 방법에 대해 알아봅니다.     @State private var funFact = \"\"    var body: some View {     VStack {       // 다른 컨텐츠들 생략        Text(funFact)           .padding()        Button(\"Show Random Fact\") {         funFact = information.funFacts.randomElement()!       }     }     .padding()   }  funFact 변수가 @State를 사용하고 있기 때문에 fucFact를 사용하고 있는 Text view는 funFact의 변수에 값이 변경될 때마다 자동으로 업데이트 됩니다.   Button을 탭할 때마다 funFact에 랜덤 값을 할당합니다. funFact변수에 값이 바뀌므로 Text view의 값도 변하게 됩니다.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","Sample Apps Tutorials"],
        "url": "/til/aboutMe/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Navigating Apps: Choose Your Own Story",
        "excerpt":"Sample Apps Tutorials: Choose Your Own Story(Navigating Apps)  아래 모든 정보의 출처는 apple developer 공식 페이지이며 개인의 학습 용도로만 사용되었음을 밝힙니다.  All information below comes from the official apple developer page and is for personal learning purposes only.   Choose Your Own Story   Views 사이에서 동적으로 변화하는 navigation에 대해 알아봅니다.   사용자의 선택에 따라 다른 페이지로 이동하는 이야기를 만들어봅니다.     Section 1: Create Your Own Story   이야기를 구성하기 위해서 앱은 커스텀 타입인 Story의 instance가 필요합니다. Story는 또 다른 커스텀 타입인 StoryPage의 인스턴스로 이루어진 배열을 속성으로 가집니다. 각 StoryPage는 text 속성 부분과 choices 속성 부분으로 이루어져 있습니다.     // MyStory.swift    let story = Story(pages: [     StoryPage(       \"\"\" 이야기 부분 \"\"\"        choices: [           Choice(text: \"Front row!\", destination: 1),           Choice(text: \"Find somewhere in the middle\", destination: 1)           Choice(text: \"Back of the room\", destination: 2),            ]         ),       ]     )     // 위의 방식으로 StoryPage가 page20까지 Story의 배열 타입 패러미터로 작성되어 있습니다.  이야기 부분을 읽고 -&gt; 선택 -&gt; 페이지로 이동됩니다. 이동된 페이지에서도 마찬가지로 이야기 부분을 읽고 -&gt; 선택 -&gt; 해당 페이지로 이동합니다.   세개의 quotation marks   ””” “”” : String 값을 생성하는 특별한 방법입니다. 이 방법을 이용하면 여러 줄의 글을 쓸 수 있고 quotation marks도 사용할 수 있기 때문에 이야기와 같은 긴 글을 쓸 때 유용하게 사용할 수 있습니다.   The destination property   Choice의 destination property는 story navigation 앱의 키 요소입니다. destination의 숫자 값은 페이지의 index 번호입니다. 인덱스는 0부터 세기 때문에 1페이지는 0, 2페이지는 1의 식으로 숫자가 적용됩니다.   Section 2: Story Data Model   위에서 작성한 Story data를 구조화하는 방법에 대해 알아봅니다.   StoryModels.swift   이 앱에서는 Story라는 custom type을 이용합니다. Story의 instance를 생성해 스토리 페이지를 화면에 출력합니다. 각 페이지는 이야기 부분과 몇 개의 선택지로 이루어져 있습니다.     // StoryModels.swift    import Foundation    struct Story {      let pages: [StoryPage]      subscript(_ pageIndex: int) -&gt; StoryPage {       return pages[PageIndex]     }   }    struct StoryPage {     let text: String      let choices: [Choice]      init(_ text: String, choices: [Choice]) {       self.text = Text       self.choices = choices     }   }    struct Choice {     let text: String     let destination: Int   }   ☑️ What I Learned From This Part:       1. Custom Type 생성 과정            2. Custom type을 만드는 file에는 Foundation만 import 하면 될 때도 있음. (다른 framework를 추가해야 할 때도 많이 있음.)            3. init()의 이름을 사용하지 않는 패러미터        init(_ text: String) -&gt; text는 패러미터의 이름일 뿐 생성자가 사용될 때 사용하는 이름은 아님. 이 경우에는 생성자 사용시 이름없이 바로 “”” “”” 으로 문자열을 입력해주었음.            4. subscript의 이용      subscript     struct Story {        let pages: [StoryPage]        // subscript를 이용하여 StoryPage 타입의 배열 pages의 멤버 요소에 접근       // 인덱스 값을 이용해서 pages의 한 요소를 가져옴       subscript(_ pageIndex: Int) -&gt; StoryPage {           return pages[pageIndex]       }   }   StoryPage type   또 다른 custom type인 StoryPage는 이야기 부분인 text 상수 속성과 선택지 부분인 choices 배열 속성 부분으로 이루어져 있습니다. choices 배열은 사용자를 각 선택마다 다른 페이지로 이동시켜줍니다.   Choice type   Choice type도 custom type입니다. 선택지 버튼에 나타나는 문자열 부분과 페이지 인덱스 부분인  Int type의 destination 속성으로 이루어져 있습니다.   Section 3: Creating a Navigation view   StoryView.swift     // StoryView.swift    import SwiftUI    struct StoryView: View {      var body: some View {       NavigationView {         StoryPageView(story: story, pageIndex: 0)       }       .navigationViewStyle(.stack)     }   }    sturct ContentView_Previews: previewProvider {     static var previews: some View {       StoryView()     }   }   NavigationView   StoryView는 이 앱의 top-level view입니다. 맨 처음 앱이 실행되면 보이는 view이죠. 각각의 story page를 화면에 보여주고 페이지 사이를 이동하기 위해서 NavigationView를 이용합니다. NavigationView view는 각 스토리 페이지를 담는 컨테이너와 같습니다. 한 장의 스토리 페이지를 보여주고 Navigation Link가 탭 될 때마다 다른 페이지로 변경됩니다.   NavigationView는 StoryPageView라는 콘텐츠를 가지고 있고 그것을 화면에 보여줍니다. 여기서 이용된 story는 MyStory Data file에서 전역변수로 만들어주었습니다. story 안의 StoryPage 중 pageIndex: 0을 사용하여 첫 번째 페이지를 보여줍니다.   Section 4: Displaying a Story Page   StoryPageView.swift     // StoryPageView.swift    import SwiftUI    struct StoryPageView: View {      let story: Story     let pageIndex: Int      var body: some View {       VStack {           ScrollView{             Text(story[pageindex].text)           }            ForEach(story[pageIndex].choices, id: \\Choice.text) { choice in               NavigationLink(destination: StoryPageView(story: story, pageIndex: choice.destination)) {                 Text(choice.text)                     .multilineTextAlignment(.leading)                     .frame(maxWidth: .infinity, alignment: .leading)                     .padding()                     .background(Color.gray.opacity(0.25))                     .cornerRadius(8)                 }}       }       .padding()       .navigationTitle(\"Page \\(pageIndex + 1)\")       .navigationBarTitleDisplayMode(.inline)     }   }   앱의 스토리를 화면에 출력하기 위해서 Story type을 사용합니다. Story type은 이야기에 대한 모든 정보들을 담고 있습니다. 이야기에 대한 데이터를 변경하려면 MyStory Data file로 이동해 story 전역변수에 담긴 내용을 수정해 줍니다.   VStack을 이용해서 text / choices를 수직으로 배치합니다. 이야기 부분에는 ScrollView를 사용함으로써 많은 내용을 담더라도 스크롤을 이용해 화면에 모두 보일 수 있도록 합니다. pageIndex는 현재 페이지의 index 번호를 나타냄으로 Text(story[pageIndex].text)는 현재 페이지의 text 부분을 가져와 화면에 보여줍니다.   ForEach structure   ForEach view는 여러 개의 view를 생성할 때 사용됩니다. 여기서는 현재 페이지의 choices 배열을 화면에 보여줍니다. 배열은 각각 선택지를 담고 있습니다. 선택지가 3개라면 3개의 버튼을, 4개라면 4개의 NavigationLink를 만듭니다. { } 안의 코드를 배열의 각 item마다 반복하기 때문에 같은 형태의 NavigationLink를 만듭니다.   id argument   SwiftUI는 배열의 각 item을 분리, 구별하기 위해서 id argument를 사용합니다. 여기서는 각 choice가 다른 text를 가지고 있기 때문에 text를 id로 사용합니다.   NavigationLink   NavigationLink는 두가지가 필요합니다.     destination(여기서는 스토리 페이지)   화면에 출력할 content(여기서는 선택지 Text)   이 앱에서 NavigationLink의 destination은 각 선택지가 연결되어 있는 페이지 입니다.     NavigationLink(destination: StoryPageView()) {        // 이곳에 화면에 출력될 content code를 작성합니다.    }   Navigation links는 NavigationView 아래서만 작동합니다.   Aligning Text     Text(choice.text)       .multilineTextAlignment(.leading)       .frame(maxWidth: .infinity, alignment: .leading)       .padding()       .background(Color.gray.opacity(0.25))       .cornerRadius(8)     multilineTextAlignment(.leading)는 여러줄의 text를 정렬하는 modifier입니다. leading은 왼쪽 정렬입니다.   frame은 보이지 않은 frame에 text를 담습니다. maxWidth값에 .infinity로 주면 frame은 가능한 가장 넓은  width값을 가지게 됩니다.   alignment: .leading은 frame 안에 있는 text를 왼쪽 정렬합니다.   Navigation Bar     } // VStack 끝나는 부분   .padding()   .navigationTitle(\"Page \\(pageIndex + 1)\")   .navigationBarTitleDisplayMode(.inline)      VStack 아래에 다른 콘텐츠나 스택이 없는 상황에서. .padding()을 주면 화면 안에서 VStack 주변에 적절한 양의 padding을 줍니다. 패딩을 주지 않으면 콘텐츠들이 화면에 딱 붙어서 보입니다.   아래쪽 modifier 두 개는 view가 NavigationView 아래에 사용되었을 때 적용됩니다. Navigation view는 navigation bar를 제공합니다. Navigation Bar에는 title과 뒤로 가기 버튼이 기본적으로 주어집니다. Extra button이나 text와 같은 커스텀 가능한 다른 아이템들도 있습니다.      .navigationTitle modifier를 이용해서 현재 페이지의 번호를 화면에 출력할 수 있습니다.        .navigationBarTitleDisplayMode로는 타이틀의 크기와 나타나는 스타일을 바꿀 수 있습니다. inline은 더 작은 글씨로 나타나게 합니다. automatic과 large도 선택할 수 있습니다. (적용해 보니 automatic과 large 둘이 똑같이 나옵니다. 더 큰 사이즈에 글자로 왼쪽 정렬해서 텍스트 안의 head부분처럼 보이네요.)            ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","Sample Apps Tutorials"],
        "url": "/til/chooseYourOwnStory/",
        "teaser": "/assets/images/choose2.png"
      },{
        "title": "Navigating Apps: Date Planner",
        "excerpt":"Sample Apps Tutorials: About Me(Navigating Apps)  아래 모든 정보의 출처는 apple developer 공식 페이지이며 개인의 학습 용도로만 사용되었음을 밝힙니다.   🐤 Date Planner 앱은 날짜별로 이벤트를 계획하고 정리하는 앱입니다.  이 튜토리얼에서는 list, 그리고 이벤트를 보여줄 동적 리스트를 생성하기 위해 observable data model에 대해 배웁니다.   Section 1: App Configuration   앱이 하나의 데이터 객체를 생성하고 그것을 전체 뷰 계층에서 사용 가능하도록 함으로써 views들 사이에서 데이터를 공유하는 방식에 대해 알아봅니다.   DatePlannerApp.swift     // DatePlannerApp.swift    import SwiftUI    @main   struct DatePlannerApp: App {       @StateObject private var eventData = EventData()      var body: some Scene {       WindowGroup {         NavigationView {             EventList()             // 더 넓은 화면을 사용할 때 (iPad의 가로 전체 화면 등) 필요한 요소                       // 화면이 나뉘어졌을 때 빈 화면에 placeholder로 Text view의 내용이 나타남             // 리스트의 아이템을 선택하면 해당 이벤트 뷰로 바뀌게 됨             Text(\"Select an Event\")                 .foregroundStyle(.secondary)         }         .environmentObject(eventData)       }     }   }  NavigationView      views를 이동하기 위해 앱의 top-level view에 NavigationView를 작성합니다.   NavigationView 아래에는 앱의 home view가 작성됩니다.   이 앱의 첫화면이자 home view는 EventList() 입니다.   iPad의 가로 화면과 같은 더 넓은 앱화면 구성에서, SwiftUI는 NavigationView를 이용할 때 여러개의 컨텐츠를 하나의 스택이 아닌 나란한 행들로 화면에 나타냅니다. 이 앱에서 EventList는 하나의 sidebar column에 나타납니다. 각 컨텐츠는 primary pane에 나타납니다.   var eventData     @StateObject private var eventData = EventData()   이 앱은 eventData라는 이름의 변수에 데이터를 저장합니다. eventData 변수는 @StateObject wrapper와 함께 observable object인 EventData의 instance를 만듭니다. SwiftUI는 observable object에 일어나는 변화를 추적합니다. 만약 변화가 생기면 SwiftUI가 자동으로 이 object를 사용하는 view를 업데이트 합니다.     } // NavigationView 끝   .environmentObject(eventData)   eventData를 전체 view 계층에서 사용하기 위해서 .environmentObject와 eventData instance를 사용합니다. 이것을 사용하므로써 앱의 모든 navigation view의 child views들 그리고 child view의 child view까지 이 데이터를 사용할 수 있게 됩니다.   Section 2: Event Model   아래에서 Event model은 이벤트를 구성하고 시각화하기 위해 필요한 모든 데이터를 가지고 있습니다.    Event 모델을 구성하는 방법에 대해 알아봅니다.   Event.swift     // Event.swift    import SwiftUI    struct Event: Identifiable, Hashable {     var id = UUID()     var symbol: String = EventSymbols.randomName()     var color: Color = ColorOptions.random()     var title = \"\"     var tasks = [EventTask(text: \"\")]     var date = Date()      var remainingTaskCount: Int {         tasks.filter { !$0.isCompleted }.count     }      var isComplete: Bool {         tasks.allSatisfy { $0.isCompleted }     }      var isPast: Bool {         date &lt; Date.now     }      var isWithinSevenDays: Bool {         !isPast &amp;&amp; date &lt; Date.now.sevenDaysOut     }      var isWithinSevenToThirtyDays: Bool {         !isPast &amp;&amp; !isWithinSevenDays &amp;&amp; date &lt; Date.now.thirtyDaysOut     }      var isDistant: Bool {         date &gt;= Date().thirtyDaysOut     }    }    Event planner는 데이터를 분류, 구성하기 위해서 여러개의 Event object의 모음(collection)을 사용합니다. 각각의 Event object는 캠핑, 여행, 생일파티와 같은 특정 이벤트를 나타냅니다.      Identifiable protocol은 이벤트의 리스트를 생성할 때 SwiftUI가 이벤트의 값을 다른 것들과 확실히 구별하고 그것을 업데이트 할 수 있도록 합니다.   📖 틈새 영어 단어: populate        The Event type contains all of the information you need to populate an event.       컴퓨터에서 데이터 베이스나 테이블에 정보를 입력하는 것을 말합니다.      Event Type    struct Event: Identifiable, Hashable {     var id = UUID()     var symbol: String = EventSymbols.randomName()     var color: Color = ColorOptions.random()     var title = \"\"     var tasks = [EventTast(text: \"\")]     var date = Date()   }  Event type은 하나의 이벤트를 만들기 위한 모든 정보를 가지고 있습니다. 심볼과 색, 이벤트의 이름, 이벤트 안에서 수행해야 할 tasks와 날짜입니다. task는 이벤트를 누르면 to-do 형식으로 나타납니다.   Computed properties   Stored properties 아래에는 computed properties가 있습니다. Computed properties는 날짜나 수행한 task 수를 기반으로 이벤트를 정렬할 수 있도록 합니다.     var isPast: Bool {     date &lt; Date.now   }  에를 들어 위의 isPast property는 현재 날짜, 시간보다 이벤트의 날짜 시간이 적으면 true를 반환합니다. 이것을 이용해 사용자들은 과거 이벤트를 위한 카테고리에 지난 이벤트들을 모아둘 수 있습니다.     UUID()   참고한 페이지   a Universally Unique Identifier의 약자입니다.   정적인 view를 만들때는 SwiftUI가 어떤 뷰를 우리가 이용하고 있는지 알고, 여러가지 작업을 할 수 있습니다. 하지만 우리가 동적인 view를 만들기 위해서 List나 ForEch문을 사용하면 SwiftUI는 각 아이템들을 구별할 방법이 필요해집니다. 이때 사용할 수 있는 것이 UUID()입니다.   Section 3: Event Task   하나의 EventTask는 하나의 to-do 아이템을 나타냅니다. 이 챕터에서는 어떤 방식으로 task 부분을 구성하는지 알아봅니다.   EventTask.swift     // EventTask.swift      import SwiftUI    struct EventTask: Identifiable, Hashable {     var id = UUID()     var text: String     var isCompleted = false     var isNew = false   }   Event type과 마찬가지로 EventTask type 역시 Identifiable protocol을 따릅니다. 이것은 SwiftUI이 리스트 속 to-do 아이템의 상태를 관리하고 업데이트 할 수 있도록 합니다. EventTask type은 id, text, isCompleted, isNew와 같은 to-do 아이템의 속성들을 가지고 있습니다.   사용자가 한 task를 완료했다고 표시하면, isCompleted를 true로 설정할 것입니다. 이렇게 함으로써 앱이 남아있는 task를 추적할 수 있게 합니다.   Section 4: Event Data   앱의 이벤트 목록에 정보를 채우기 위해 observable object인 EventData를 사용합니다. 이 섹션에서는 어떻게 데이터를 구성하고 업데이트하는지 알아봅니다.   EventData type     // EventData.swift    import SwiftUI    class EventData: ObservableObject {       @Published var events: [Event] = [           Event(symbol: \"gift.fill\",                 color: .red,                 title: \"Future's Birthday\",                 tasks: [EventTask(text: \"Wine\"),                         EventTask(text: \"Cheese plate\"),                         EventTask(text: \"Something too sweet\"),                         ],                 date: Date.roundedHoursFromNow(60 * 60 * 24 8 30)),           Event(symbol: \"theatermasks.fill\",                 //위와 같은 내용)       ]   }      EventData type은 어플에 나타나는 모든 이벤트에 대한 정보를 저장하고 수정합니다.   ObservableObject protocol을 따릅니다. 이것은 EventData에 있는 published values 중 어떤 것에든 변화가 일어나면 SwiftUI가 그 values를 사용하고 있는 view들(observers)을 찾고 자동으로 업데이트 해줍니다.   events property      EventData는 events라는 property를 가지고 있습니다. 위의 예시에서 이 property는 Event타입의 값을 가진 배열로 값이 미리 채워져 있습니다.   @Published property wrapper는 events 배열에 변화가 일어날때마다 SwiftUI가 변화를 인지하고 그 배열을 사용하는 view들을 업데이트 하게 합니다. 이것은 배열로부터 이벤트를 추가하거나 삭제하면 바로 UI에 보여지도록 합니다.   EventData의 메서드       ] // events 속성의 배열 끝부분      func delete(_ event: Event) {       events.removeAll { $0.id == events.id }     }    }  위의 메서드는 선택된 이벤트의 모든 정보를 삭제해줍니다.        Section 5: Event List   List view를 사용하여 앱의 주요 UI인 event list를 그리는 방법에 대해 알아봅니다.   @EnvironmentObject   DatePlannerApp.swift에서 가장 높은 레벨의 네비게이션 뷰는 EventData의 인스턴스를 통과시키기 위해 .environmentObject modifier를 사용합니다. 이것으로 모든 child views는 인스턴스에 쉽게 접근할 수 있게 됩니다.     // EventList.swift    import SwiftUI    struct EventList: View {       @EnvironmentObject var eventData: EventData       //...   }   Child view인 EventList에서 @EnvironmentObject property wrapper를 사용, EventData type을 주어 변수를 정의함으로써 EventData 인스턴스의 data에 접근할 수 있게 됩니다.   List view   목록을 생성하기 위해 List view를 사용하고 ForEach loop를 사용해서 앞에서 설정한 모든 시간대를 기준으로 반복합니다. (nextSevenDays, nextThirtyDays, future, past)  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","Sample Apps Tutorials"],
        "url": "/til/datePlanner/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Guided Swift Tour: 스위프트 기초 문법",
        "excerpt":"A Swift Tour 아래 모든 정보의 출처는 Swift 공식 문서이며 개인의 학습 용도로만 사용되었음을 밝힙니다.  All information below comes from the Swift documentation and is for personal learning purposes only.   문자열과 변수의 값     let apples = 3   let oranges = 5   let appleSummary = \"I have \\(apples) apples.\"   let fruitSummary = \"I have \\(apples + oranges) pieces of fruit.\"      \\ 와 ()를 이용해서 문자열 안에 변수의 값을 포함할 수 있습니다.   Array and Dictionary     // 배열   var thingsIWannaGet = [\"a chair\", \"plant\", \"tulips\"]    thingsIWannaGet.append(\"clothes\")   print(thingsIWannaGet)    // 딕셔너리   var occupations = [       \"Marcolm\": \"Captain\",       \"Kaylee\" : \"Mechanic\",   ]    occupations[\"Jayne\"] = \"Public Relations\"     []를 이용하여 배열과 딕셔너리를 생성할 수 있습니다.   key를 이용하여 값에 접근할 수 있습니다.   마지막 요소 다음에 ,(콤 )가 허용됩니다.   배열에 값을 추가시 배열의 크기는 자동으로 늘어납니다.   print(배열이름)을 이용하여 간단하게 배열을 출력할 수 있습니다.   빈 배열, 빈 딕셔너리 생성하기    var emptyArray: [String] = []  var emptyDictionary: [String: Float] = [:]   Optionals   값이 없을 수도 있는 상황에서 optionals를 사용합니다. Optional은 두가지 가능성을 나타냅니다.      값이 있어서 optional을 unwrap하여 그 값에 접근할 수 있다.   값이 없다.   optionals가 사용되는 방법   Int()   Int type은 문자열을 Int로 변환할 수 있는 initializer를 가지고 있습니다.    let possibleNumber = \"123\"   let convertedNumber = Int(possibleNumber)    print(convertedNumber)   // Prints \"optional(123)\"  위의 방식으로 문자열을 Int 타입으로 변환할 수 있지만 모든 문자열을 Int 타입으로 변환할 수 있는 것은 아닙니다. “hello, world”와 같은 문자열은 명확한 숫자 값을 가지고 있지 않기 때문에 변환되지 않습니다. 이렇게 initializer가 변환을 실패할 수 있는 경우가 있기 때문에 Int가 아닌 optional Int 값을 변환합니다. Optional Int는 Int? 라고 표기합니다. ‘?’는 Int값이 있거나 어떠한 값도 가지고 있지 않다는 것을 나타냅니다. (Bool, String과 같은 값은 가지지 않음)   nil   nil값을 할당함으로써 optional 변수에 값이 없는 상태를 설정할 수 있습니다.     let serverResponseCode: Int? = nil   optional이 아닌 constants나 variables과는 nil을 사용할 수 없습니다. 만약 값이 없는 변수 또는 상수가 필요하다면 항상 optional +  해당 타입을 사용해야 합니다.   만약 값을 할당하지 않고 optional variable을 정의하면 자동으로 nil값이 할당됩니다.     var surveyAnswer: String?   // surveyAnswer is automatically set to nil   Nil-Coalescing Operator   Nil-Coalescing Operator (a ?? b)는 만약 옵셔널 a가 값을 가지고 있다면 optional a를 unwrap 합니다. a가 nil이라면 default 값인 b를 리턴합니다.   If문과 Optionals    var optionalString: String? = \"Hello\"  print(optionalString == nil)  // false 를 출력함   var optionalName: String? = \"Future Kim\"  var greeting = \"Hello!\"  if let name = optionalName {    greeting = \"Hello, \\(name)\"  }  if와 let 그리고 없을수도 있는 값을 함께 사용할 수 있다. 없을 수 있는 값을 optionals라고 한다. Optional 값은 어떤 값을 가지거나 값이 없다는 것을 나타내기 위해 nil값을 가진다. 값의 type 뒤에 ? 를 작성하여 optional임을 표시합니다.  위의 optional value는 if문의 조건에서 unwrapped 되고 let 상수에 할당됩니다. unwrapped된 값은 안쪽 코드 블락에서 사용가능하게 됩니다.    var optionalName: String? = nil  var greeting = \"Hello!\"   if let name = optionalName {     greeting = \"Hello, \\(name)\"     } else {     greeting = \"Hello, No Name!\"   }    print(greeting)  위에 예제에서는 optionalName에 nil값을 주었을 때는 if문의 조건이 false이기 때문에 { } 속 코드를 스킵합니다. else문을 이용하여 nil 값인 경우에 실행할 코드를 작성할 수도 있습니다. 위의 예제는 Hello, No Name을 출력합니다.    let nickname: String? = nil  let fullname: String = \"Future Kim\"  let informalGreetring = \"Hi \\(nickname ?? fullName)\"   ?? operator를 사용하여 optional에 default 값을 줄 수 있습니다. 만약 optional이 nil을 가지고 있다면 기본값을 사용합니다.   Forced unwrapping   만약 어떤 optional이 확실히 값을 가지고 있다는 것을 안다면 optional의 이름 뒤에 !를 붙여줌으로써 그 optional의 값에 접근할 수 있습니다. !는 ‘나는 이 optional이 값을 가지고 있는 것을 명확히 알고 있으니 그것을 사용하라’라는 메세지를 효과적으로 전달합니다. 이것을 optional값이 forced unwrapping이라고 합니다.     if convertedNumber != nil {       print(\"convertedNumber has an integer value of \\(convertedNumber!).\")   }   Optional Binding   Optional binding은 optional이 값을 가지고 있는지, 가지고 있지 않은지 알아내기 위해 사용됩니다. 그리고 만약 값이 있다면 그 값을 일시적으로 constant나 variable로 사용 가능하도록 합니다. Optional binding은 optional안의 값을 확인하기 위해 그리고 그 값을 constant나 variable로 추출하기 위해 if문이나 while문과 함께 사용될 수 있습니다.     if let constantName = someOptinal {     satements   }     if let actualNumber = Int(possibleNumber) {     print(\"The string \\\"\\(possibleNumber)\\\" has an integer value of \\(actualNumber)\")   } else {     print(\"The String \\\"\\(possibleNumber)\\\" couldn't be converted to an integer\")   }   // Prints \"The string \"123\" has an integer value of 123\"  위의 코드는…   ‘만약 Int(possibleNumber)로부터 반환된 optional Int가 값을 가지고 있다면 그 옵셔널에 담겨 있는 값을 새로운 constant인 actualNumber에 할당하라’라고 읽을 수 있습니다.   만약 위의 변환 과정이 성공적으로 이루어졌다면, 새 constant인 actualNumber는 첫번째 branch(if 조건이 true일 때 실행되는 브랜치)에서 사용 가능하게 됩니다. 이미 초기화 되어있기 때문에 ! 를 사용하지 않아도 됩니다.   constants와 variables 둘다 Optional binding에서 사용될 수 있습니다. actualNumber의 값을 조작하고 싶다면 아래와 같이 코드를 작성했을 것입니다.    if var actualNumber = Int(possibleNumber) {    }   if문에는 필요한 만큼의 optional bindings와 Boolean 조건을 사용할 수 있습니다. 만약 optional bindings 안의 어떤 값이라도 nil이거나, Boolean중 하나라도 false이면 전체 if문은 false값을 가지게 됩니다.     if let firstNumber = Int(\"4\"), let secondNumber = Int(\"42\"), firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 {     print(\"\\(firstNumber) &lt; \\(secondNumber) &lt; 100\")   }   // Prints \"4 &lt; 42 &lt; 100\"    if let firstNumber = Int(\"4\") {     if let secondNumber = Int(\"42\") {       if firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 {         print(\"\\(firstNumber) &lt; \\(secondNumber) &lt; 100\")       }     }   }   // Prints \"4 &lt; 42 &lt; 100\"   if문 안의 Optional binding의 과정에서 생성된 constant나 variable는 if문의 body부분에서만 사용할 수 있습니다.   Implicitly Unwrapped Optionals   위에 묘사된 것처럼, optinals는 constants나 variables가 값이 없는 상태를 가질 수 있다는 것을 나타냅니다. if문을 이용하여 optionals에 값이 있는지 없는지 확인할 수 있습니다. 조건에 따라 optional binding을 이용하여 optionals를 unwrap하여 optional에 값이 있다면 그 값에 접근할 수 있게 됩니다.   가끔은, 어떤 optional에 값이 처음으로 설정된 후에 프로그램의 구조로부터 그 optional이 항상 값을 가지고 있을 거라는 것이 명확할 때가 있습니다. 이런 경우에는, 그 optional이 언제나 값을 가질 것이라는 것을 안정적으로 추측할 수 있기 때문에 그 optional에 접근할때마 값을 확인하고 unwrap할 필요를 제거하는 것이 도움이 됩니다.   이런 종류의 optionals는 implicitly unwrapped optionals라고 합니다.    optional로 만들고 싶은 type 뒤에 !를 붙여줌으로써 implicitly unwrapped optionals를 정의할 수 있습니다.   어떤 optinal이 정의된 후 바로 그 optional의 값이 있을 것이라는게 확인되고, 그 optional이 그 후로 계속해서 사용될 것이라는게 명확할 때 implicitly unwrapped optionals를 유용하게 사용할 수 있습니다.        let possibleString: String? = \"An optional string.\"   let forcedString: String = possibleString!    let assumedString: String! = \"An implicitly unwrapped optional string.\"   let implicitString: String = assumedString // ! 작성하지 않아도 됨   Switch     let vegetable = \"red pepper\"   switch vegetable {     case \"celery\":         print(\"Add some raisins and make ants on a log\")     case \"cucumber\", \"watercress\":         print(\"That would make a good tea sandwich\")     case let x where x.hasSuffix(\"pepper\"):         print(\"Is it a spicy \\(x)?\")     default:         print(\"Everything tastes good in soup\")   }   // Prints \"Is it a spicy red pepper?\"  Switch는 모든 자료형과 넓은 범위의 비교 연산자를 지원합니다. 조건이 일치하는 switch case의 코드를 실행한 뒤에 프로그램은 Switch문을 빠져나옵니다.   hasSuffix(_:)   특정 suffix(끝에 붙어서 어떤 한 다른 단어를 만드는 단어)로 끝나는 문자열인지 아닌지를 Boolean value를 리턴합니다. 위의 예시에서는 red pepper라는 문자열이 pepper로 끝나기 때문에 true를 반환합니다.   for-in과 Dictionary     let interestingNumbers = [       \"Prime\": [2, 3, 5, 7, 11, 13],       \"Fibonacci\": [1, 1, 2, 3, 5, 8],       \"Square\": [1, 4, 9, 16, 25],   ]    var largest = 0   for(_, numbers) in interestingNumbers {     for number in numbers {       if number &gt; largest {         largest = number       }     }   }   print(largest)   // Prints \"25\"   Dictionary는 순서가 없는 collection이기 때문에 for-in문을 사용하여 반복 수행하게 되면 임의의 순서로 작동하게 됩니다.    가장 바깥쪽 for-in loop의 (_, numbers) 중 앞쪽은 딕셔너리의 키를 numbers는   배열인 값을 의미합니다. 그러면 안쪽의 for-in loop는 값인 배열을 돌며 number의 각 요소를 할당합니다. 만약 number에 할당된 배열의 요소가 largest 보다 크다면 largest에 그 값을 할당합니다. 이렇게 각 키와 값을 돌며 가장 큰 수인 25를 출력합니다.   Tuples   Tuple은 여러개의 값을 하나의 합쳐진 그룹으로 만듭니다. 튜플 안의 값은 어떤 자료형이든 될 수 있고, 한 튜플안의 값은 같은 서로 다른 자료형을 가질 수 있습니다.   HTTP status code와 튜플   예를 들어 (404, “Not Found”)는 HTTP status code를 나타내는 튜플입니다. HTTP status code는 웹 페이지를 요청할 때 웹 서버로부터 리턴되는 특정한 값입니다. 404 Not Found 코드는 요청한 웹 페이지가 존재하지 않을 때 리턴되는 코드입니다.     let http404Error = (404, \"Not Found\")   // http404Error is of type (Int, String), and equals (404, \"Not Found\")  (404, “Not Found”)튜플은 HTTP status code에게 숫자와 사람이 읽을 수 있는 설명이라는 두개의 값을 주기 위해서 Int타입과 String타입을 하나의 그룹으로 만들었습니다. 이것은 “a tuple of type(Int, String)”이라고 할 수 있습니다.   제한이 없는 튜플   (Int, Int, Int) 또는 (String, Bool) 등의 튜플을 만들 수 있습니다. 값의 개수나 자료형의 제한이 없습니다.   Decompose a Tuple   튜플의 컨텐츠를 각각의 상수나 변수로 나눌 수 있습니다.     let (statusCode, statusMessage) = http404Error    print(\"The status code is \\(statusCode)\")   // Prints \"The status code is 404\"   만약 튜플의 값 중 몇몇의 값만 필요하다면  _(underscore)를 사용하여 필요 없는 값은 무시할 수 있습니다.     let (justTheStatusCode, _) = http404Error   print(\"The status code is \\(justTheStatusCode)\")   // Prints \"The status code is 404\"   Index를 이용하여 값에 접근하기     print(\"The Status code is \\(http404Error.0)\")   // Prints \"The status code is 404\"    print(\"The Status message is \\(http404Error.1)\")   // Prints \"The status message is Not Found\"  인덱스 번호를 이용해 각 값에 접근할 수 있습니다.   정의와 동시에 값에 이름짓기     let http200Status = (statusCode: 200, description: \"OK\" )  위의 과정을 하나로 합쳐 튜플을 정의함과 동시에 각 값에 이름을 줄 수 있습니다. 값에 이름을 붙여주면 그 이름을 이용하여 값에 접근할 수 있습니다.     print(\"The statusCode is \\(http200Status.statusCode)\")   // Prints \"The statusCode is 200\"   Functions와 튜플   튜플은 function의 리턴 값으로 사용될 때 특히 유용합니다. 웹 페이지를 가져오는 function은 페이지 가져오기가 성공했는지 실패했는지를 알려주기 위해 (Int, String) 튜플을 반환할 수 있습니다. 서로 다른 타입인 값을 가진 튜플을 리턴하는 function은 하나의 자료형인 하나의 값을 리턴하는 funtion보다 더 유용하게 사용될 수 있습니다.   NOTE   튜플은 관계가 있는 값들의 단순한 그룹들을 만드는데 유용합니다. 만약 데이터의 구조가 복잡하다면 class나 structure를 이용해 모델링하는 것이 더 좋은 방법이 될 것입니다.     Early Exit   guard statement는 if statement처럼 Boolean 값에 따라 코드를 실행합니다.   guard statement뒤에 오는 코드를 실행시키기 위해, 조건이 true여야만 하는 상황을 요구할 때 guard statement를 사용합니다. if문과 다르게 항상 else절이 함께 사용됩니다.     func greet(person: [String: String]) {     guard let name = person[\"name\"] else {       return     }      print(\"Hello \\(name)!\")      guard let location = person[\"location\"] else {       print(\"I hope the weather is nice near you.\")       return     }      print(\"I hope the weather is nice in \\(location).\")   }    greet(person: [\"name\": \"John\"])   // Prints \"Hello John!\"   // Prints \"I hope the weather is nice near you.\"    greet(person: [\"name\": \"Jane\", \"location\": \"Cupertino\"])   // Prints \"Hello Jane!\"   // Prints \"I hope the weather is nice in Cupertino.\"   만약 조건이 false라면 else 브랜치의 코드가 실행됩니다. 이런 경우에는 return, break, continue, throw등의 control transfer statement를 사용하여 코드 블락을 꼭 벗어나 주어야 합니다.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift"],
        "url": "/til/guidedTour/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Playgrounds: Learn to Code 2",
        "excerpt":"Learn to code 2  아래 모든 내용들은 Playgrounds에서 학습하며 정리한 내용입니다.    모든 내용의 출처는 Playgrounds임을 밝힙니다.   Variables   머리로 기억할 수 있는 것보다 더 많은 연락처를 저장한 스마트폰의 연락처 목록을 떠올려 봅시다. Coder는 변수(Variables)라는 컨테이너에 이름을 붙이고   정보를 담습니다. 우리가 수정하기 전까지는 연락처의 정보가 바뀌지 않듯 Variables의 정보는 우리가 변경하기 전까지 스스로 바뀌지 않습니다.     var name = \"Mia\"   var age = \"28\"      var 키워드를 사용합니다.   변수의 이름(name, age)이 필요합니다.   = (assignment operator, the equal sign)은 변수에 값을 할당합니다.   위의 변수 중 name은 String을 담고 있습니다. (“text”)   위의 변수 중 age는 Int(an integer, a whole number)를 담고 있습니다.   📖 틈새 영어 단어: a whole number        whole numbers       0을 포함한 자연수를 말합니다.       0, 1, 2, 3, 4, ....       변수를 할당한 뒤 다른 값을 할당할 수 있지만 자료형은 처음 할당한 값과 같아야 합니다. 만약 처음 String 타입의 자료를 담았다면 그 변수에는 게속해서 String 타입의 자료형을 담아야 합니다.     var age = 28   age = \"twenty-nine\" // 자료형이 다름으로 불가능   incrementing a value   incrementing a value는 현재 값과 비교하여 값을 증가시키는 코딩 패턴입니다.    var myNum = 0   myNum = myNum + 1  variable을에 할당된 수와 비교 연산자를 이용해서 while문의 Boolean 조건을 만들 수 있습니다. incrementing values 하며 반복 횟수 등을 기록할 수 있습니다.   변수 이름 정하기      camelCase: 첫번째 단어는 소문자로 시작 뒤로 이어지는 새 단어들은 대문자로 시작하도록 쓰는 방법입니다.   변수에 담길 값이 무엇인지 알려주는 이름으로 정합니다.   Constant   Constant(상수)는 variable(변수)와 같이 값을 담는 이름 붙인 컨테이너입니다. 하지만 프로그램이 실행되는 동안에는 값을 변경할 수 없다는 차이점이 있습니다.      ‘let’ 키워드를 사용합니다.   값이 변경되지 않는다는 것을 아는 경우 상수를 사용합니다.     let numberOfTries = 3   변수의 값과 상수의 값을 비교하는 식의 코드가 자주 사용됩니다.   Compound assignment operator     gemCounter = gemCounter + 1   gemCounter += 1   자료형(Types)   집을 지을 때는 blue print를 사용합니다. Blue print는 거실, 화장실, 침실과 같은 집의 기능들을 보여줍니다. 여러개의 집들을 지을 때 한 blue print를 이용한다면 그 집들은 모두 비슷한 모양으로 지어질 것입니다.   프로그래밍에서 type은 blue print와 같습니다. 그리고 instance는 blue print를 통해 지어진 집과 같습니다.   Blue print는 집의 특징(feature)과 작동 방식(behavior)을 알려줍니다.   Type에서 features는 properties라고 부르고 작동 방식(behavior)는 method라고 합니다.     Features: Color, Bedromms    var color = green   var bedrooms = 2    // property는 타입안에서 변수입니다.    Behaviors: Run Water, Turn on Lights    runWater()   turnLightsOn()    // method는 타입안에서 function입니다.   우리가 만든 여러개의 집중 하나의 차고를 열고 싶다고 가정해봅니다. 먼저 우리는 어떤 집인지 이름을 통해 지정합니다.     myHouse.openGarageDoor()  Swift에서 .(dot notation) 앞부분인 myHouse는 특정한 집을 가리키는 instance입니다.   . 뒷부분은 openGarageDoor()라는 myHouse의 메서드입니다.     bluePortal.isActive() = false  bluePortal이라는 인스턴스의 isActive()라는 메서드가 bluePortal을 켠다고 가정했을 때 ‘= false’는 bluePortal을 끕니다.   Using dot notation syntax   컴퓨터가 이해할 수 있는 코드를 작성하는 규칙을 syntax라고 합니다. Dot notation systax는 아래와 같이 생겼습니다.    greenPortal.isActive = true  Dot notation을 이용하면 특정 instance의 properties의 상태를 변경시킬 수 있습니다. 때때로 프로그램 안에서 여러번 instance의 propert의 상태를 변경해야합니다. greenPortal은 instance의 이름이고 isActive는 greenPortal의 property입니다.   State   State는 어떤 주어진 특정 시간에 변수에 담긴 정보를 말합니다.   instance에 이름을 부여하고 이름으로 그것을 나타내는 것은 프로그램 안에서 인스턴스의 요소들을 이용할 수 있게 해줍니다.   더 효율적인 문제 해결법을 찾는 것은 프로그램이 더 빠르게 작동한다는 것이고 그것은 사용자들이 앱을 사용할 때 행복해진다는 것입니다. 그리고 배터리가 얼만큼 오래 보존되는지와도 관련이 있습니다.   Factoring   코드를 효율적으로 작성하는 방법에 대해 생각해보는 것은 중요합니다. 작동하는 방식을 작은 단위로 나누어 재사용 가능한 function을 작성한다면 전체적으로는 더 적은 라인의 수로 코드를 작성할 수 있습니다. 이런 것을 factoring 코드라고 합니다. factoring the code는 재사용성을 높여줄 뿐 아니라 코드의 가독성을 높여주어 작성자 뿐 아니라 다른 누구든 코드가 어떻게 작성된건지 알아보기 쉽게 해줍니다.   //👷‍♂️ Learn to Code 2: Random Gems Everywhere 다시 풀기   Initialization   Initialization을 통해 instance를 만들 수 있습니다.     let expert = Expert()     let 키워드를 사용하여 constant를 생성합니다.   Type의 이름 + ()를 우측에 작성하여 초기화(Initialize) 합니다.     expert.turnLockUp()  expert라는 instance의 메서드 turnLockUp()을 호출하는 방식입니다. dot notation을 사용합니다. 메서드를 사용하기 위해서는 먼저 Initialize 해주어야 한다는 것을 기억합시다.   여러개의 instances   코드를 작성할 때는 큰 문제를 해결하기 위해 보통 여러개의 instance와 element를 함께 사용하게 됩니다. 만약 사진 편집 앱을 만든다면 이미지를 촬영하기 위해 카메라 앱을, 효과를 적용하기 위해 필터 라이브러리를 사용할 것입니다.   하나 이상의 instance를 사용할 때는 instance의 이름을 사용하여 각 instance의 메서드를 호출합니다.   Parameters   집을 여러가지 색으로 페인트 칠한다고 상상해 봅니다. 그렇다면 색마다 각기 다른 메서드를 만들 수 있겠죠.    paintGreen()   paintBlue()   paintOrange()  만약 초록색 페인트로 세 레이어에 걸쳐 색을 칠하고 싶다면 아래처럼 세번 paintGreen() 메서드를 호출할 수 있습니다.    paintGreen()   paintGreen()   paintGreen()   각 색마다 function을 만들어 사용하  대신에 Parameter를 이용해서 원하는 색을 사용할 수 있습니다.    func paint(color: Color)  color parameter는 function의 input value입니다. 패러미터는 Color와 같은 특정한 Type을 가집니다. function을 호출하면 작동방식 중 사용할 argument를 통과 시킵니다.    func paint(color: Color, layers: 3)  여러개의 패러미터를 가질 수 있습니다.     func move(count: Int) {     for i in 1...count {       moveForward()     }   }  Int Type의 count라는 패러미터를 가진 function move입니다. count는 function의 바디 부분에서 for문이 얼만큼 반복될지를 특정합니다. move function을 호출 시    move(count: 3)  argument 3을 통과시킴으로써 for문을 세번 돌릴 수 있게 됩니다.   여러개의 parameter를 이용하며 function이 동작하는 중 많은 부분을 커스터마이징 할 수 있습니다. 몇 번 반복문을 동작시킬지, Bool타입을 이용한다면 동작을 시킬지 시키지 않을지 등 많은 부분을 원하는대로 특정 지을 수 있습니다.   문제를 해결하며 작성해 본 예제 코드      let expert = Expert()    let character = Character()     var gemCount = 0     func turnMethod(up: Bool, times: Int) {        if up == true {            for i in 1...times {                expert.turnLockUp()            }            expert.turnRight()        } else {            for i in 1...times {                expert.turnLockDown()            }            expert.turnRight()        }    }     for i in 1...4 {        turnMethod(up: true, times: 4)    }     while gemCount != 3 {        if character.isOnGem {            character.collectGem()            gemCount += 1            character.turnRight()         }        character.moveForward()    }     for i in 1...4 {        turnMethod(up: false, times: 3)    }     while gemCount &lt; 7 {        if !character.isBlockedRight &amp;&amp; gemCount &gt; 5 {            character.moveForward()        } else if character.isBlockedRight &amp;&amp; character.isBlockedLeft{            character.moveForward()        } else if !character.isBlockedRight {            character.turnRight()            character.moveForward()        } else if character.isBlockedRight &amp;&amp; gemCount == 6 {            character.moveForward()        }         if character.isOnGem {            character.collectGem()            gemCount += 1            character.turnLeft()            character.turnLeft()            character.moveForward()        }    }  (패러미터를 이용한 funtion의 이용을 공부하며 작성해본 예제입니다. 더 적은 라인의 코드로 문제를 해결할 수 있을 것 같은데 아직은 자꾸만 코드가 길어집니다.)   Type과 Instances   하나의 type을 이용해 여러개의 instance를 만들 수 있습니다. type은 설계도, 청사진에 자주 비유됩니다. 같은 설계도를 사용해서 만든 instance이므로 같은 메서드를 사용해 같은 속성들에 접근, 이용할 수 있습니다.   World Building     let block1 = Block()   let block2 = Block()   let block3 = Block()   let block4 = Block()   let block5 = Block()    var gemCounter = 0    func stackBlocks(block: Block, col: Int, row: Int) {           world.place(block, atColumn: col, row: row)   }   func turnAround() {       turnLeft()       turnLeft()   }   func moveAndCollect(times: Int) {       for i in 1...times {           moveForward()           if isOnGem {               collectGem()               turnAround()           }       }   }    // stack blocks to get gems   stackBlocks(block: block1, col: 2, row: 2)   stackBlocks(block: block2, col: 2, row: 2)   stackBlocks(block: block3, col: 4, row: 2)   stackBlocks(block: block4, col: 6, row: 2)   stackBlocks(block: block5, col: 6, row: 2)    while gemCounter &lt; 3 {       moveForward()       if isOnClosedSwitch {           toggleSwitch()           turnRight()       } else if isBlocked &amp;&amp; isOnGem {           collectGem()           gemCounter += 1           turnAround()       } else if isOnOpenSwitch &amp;&amp; gemCounter &gt;= 1{           turnRight()       }   }  (여러개의 instance 사용 / factor codes into a function을 공부하며 작성한 예제. 처음 작성했을때는 else if가 세개 더 있었는데 문제를 해결하며 코드를 줄일 수 있었다.)   Array      [] = square brakets   , = a comma   위 두가지를 이용하여 배열(Array)를 만듭니다.     var ingredients = [icecream, bananas, chocolate, cherries]   배열은 아이템을 순서대로 나열한 목록입니다. 순서는 Index로 표현합니다. Index를 이용하여 각 item을 변경할 수 있습니다.     [icecream, bananas, chocolate, cherries]       0         1         2          3    ingredients[1] = strawberries   ingredients[3] = sprinkles    [icecream, strawberries, chocolate, sprinkles]       0           1            2          3   컴퓨터는 0부터 수를 세기 때문에 index 역시 0부터 시작합니다.   Array Methods   Swift에는 아이템을 삭제, 추가하는 등 간단한 동작을 수행하기 위해 array와 함께 사용되는 메서드가 있습니다.     [icecream, bananas, chocolate, cherries]       0         1         2          3    // remove(at: index numbers) 메서드   ingredients.remove(at: 2)    [icecream, bananas, cherries]       0         1         2    // append() 메서드   ingredients.append(sprinkles)    [icecream, bananas, cherries, sprinkles]       0         1         2         3    // insert(item, at: index number)   ingredients.insert(strawberries, at: 1)    [icecream, strawberries, bananas, cherries, sprinkles]       0            1         2         3          4  item이 추가, 삭제됨에 따라 index 번호가 자동으로 바뀝니다.   Iteration   배열에 담긴 각 아이템마다 같은 동작을 반복할 수 있습니다. 이런 과정을 iteration 이라고 합니다.     for item in ingredients {     place(item, in: bowl)   }   위 코드는 각 item 마다 place(item, in: bowl) 이라는 코드를 반복하며 수행합니다.     Code comments   // 를 이용하면 주석(code comments)를 작성할 수 있습니다. 주석은 코드의 대한 정보를 제공합니다. 앱을 이 코드를 실행하지 않습니다.   Item의 자료형   한 array안의 자료들은 모두 같은 자료형을 가지고 있어야 합니다.   만약 처음 integer 자료형의 배열을 만들었다면 String 아이템은 추가할 수 없습니다.   For-in loop     let columns = [0, 1, 2, 3, 4]    for i in columns {     world.place(Gem(0), atCol: i, row: 1)   }  For-in 반복문은 배열의 각 value마다 { } 안의 코드를 반복해서 실행합니다. 위 코드에서 i는 columns 배열의 각 값을 담는 변수입니다. 배열 columns의 값인 0, 1, 2, 3, 4가 i에 할당되고 각 값은 { } 안에 작성된 코드인 place 메서드의 atCol 패러미터의 인자로 통과됩니다. for-in 반복문이 돌때마다 (Gem(), 0, 1), (Gem(), 1, 1), (Gem(), 2, 1) … 식으로 코드가 실행됩니다. 더이상 할당될 값이 없으면 루프는 끝이납니다.   An array of type Coordinate   Coordinate의 인스턴스는 column과 row arguments를 이용하여 장소를 나타냅니다.     // Coordinate 인스턴스의 예.   let corner = Coordinate(column: 3, row: 3)    // blockLocations라는 Coordinate type의 배열 만들기   var blockLocations = [       Coordinate(column: 0, row: 0),       Coordinate(column: 3, row: 3),       Coordinate(column: 0, row: 3),       Coordinate(column: 3, row: 0)   ]   Array method     characters = [       Character(name: .blu),       Portal(color: pink),       Character(name: .hopper),       Gem()       ]    // Remove the portal.   characters.remove(at: 1)    // Remove the gem.   characters.remove(at: 2)    // Insert the expert.   characters.insert(Expert(), at: 1)   .remove() / .insert() / .append()   .removeFirst() / .removeLast / .removeAll   등이 있습니다.   Creating an empty array   값이 주어지지 않은 빈 배열을 만들 때에는 type을 정해주어야 합니다.     var newLocations: [Coordinate] = []   // 배열의 이름: [배열의 type] = []   Assign a removed item   때때로 한 배열에서 삭제한 아이템을 사용하고 싶을 때가 있을 겁니다. 다행히도 삭제된 item은 짧은 시간동안 저장됩니다. 그러므로 삭제된 값을 다른 변수에 할당하거나 다른 배열에 append 할 수 있습니다.     // Example    var rightColumn = world.column(7)   newArray.append(rightColumn.remove(at: 1))   위 예시 코드에서 newArray에 append된 좌표는 rightColumn에서 삭제된 좌표입니다.   위 코드에서 rightColumn은 메서드로 초기화되었습니다. world 인스턴스는 한 행, 또는 열에 모든 좌표를 가지고 있는 배열을 빠르게 생성할 수 있는 몇가지 메서드를 가지고 있습니다.     // Calling a method to create an array    var row1 = world.row(1)   var column5 = world.column(5)    var topRows = world.coordinates(inRows: [5, 6, 7])   var allCoords = world.allPossibleCoordinates   Fixing Index Out of Range Errors   Index out of range 에러를 찾고 해결해 봅니다.   Index를 사용해서 배열의 각 아이템에 접근할 수 있습니다. 배열의 아이템에 접근한다는 것은 그 아이템을 변수처럼 사용할 수 있게 된다는 것입니다.     // Using an index to access an item      let characters = [     Character(name: .byte),     Character(name: .blu),     Character(name: .hopper)   ]    // Byte toggles a switch   character[0].toggleSwitch    // Hopper jumps   character[2].jump()    // Index out of range error   character[3].collectGem()  위의 마지막 예제 코드처럼 존재하지 않은 index값에 접근하려고 하면 index out of range 오류가 발생합니다. 이것은 앱의 실행을 막는 bug이기 때문에 조심해야 합니다.   버그를 찾고 해결하는 것은 코더로써 중요한 일입니다. Index out of range 에러는 앱의 실행을 중단시키는 가장 흔한 에러 중 하나입니다.   Generate a Landscape   Int 타입의 배열을 이용하여 landscape을 생성해 봅니다.     // 각 인덱스에 할당되어 있는 값에 접근하기   var heights = [7, 3, 2, 4]   for i in 1...heights[0]  heights 배열의 0번째 인덱스에 할당된 값이 7이므로 위의 for loop은 7번 반복합니다.     // Example    var index = 0   for coordinate in allCoordinates {     for i in 1...height[index] {       world.place(Block(), at: coordinate)     }     index += 1   }   위 코드에서는 index 변수에 게속해서 누적으로 1을 더해주기 때문에 index out of range 에러가 발생한다. 이것을 막기 위해서 heights.count를 사용할 수 있다.     var index = 0   for coordinate in allCoordinates {     if index == heights.count {       index = 0 // Array out of bounds error를 막는 코드     }     for i in 0...heights[index] {       world.place(Block(), at: coordinate)     }     index += 1   }   heights.count는 배열의 아이템 수입니다. 아이템의 수가 10개라면 인덱스는 9까지 존재합니다. (0부터 시작하기 때문에) index == heights.count 라는 것은 인덱스가 10이 되었다는 것을 의미함으로 index out of range가 됩니다. 이것을 방지하기 위해 index가 heights 배열 아이템의 수와 같아졌을 때 0을 할당해주는 것입니다.   Randomized Lands   유니크한 월드를 만들어 보기 위해 randomization을 사용해 봅니다.     for i in 1...20 {     let localNumber = randomInt(from: 0, to: 12)     heights.append(localNumber)   }  랜덤 값을 이용하면 코드가 실행될때마다 조금씩 다른 결과를 만들 수 있습니다. 랜던 Boolean 타입을 사용할수도 있습니다.   Local variables   function이나 loop와 같은 code structure 안에서 정의된 변수를 local variable이라고 합니다. 위의 예시 코드에서는 localNumber가 이에 해당됩니다. local variable은 오로지 만들어진 code structure안에서만 사용할 수 있습니다. 그밖의 다른 곳에서는 사용할 수 없습니다.   Read and Tweak   이미 작성된 코드를 읽고, 수정하는 것은 코더에게 중요한 능력입니다. 다른 사람이 작성한 코드를 읽고 이해해야하는 일이 많을 것입니다. code comment를 이용하여 다른 사람들이 나의 코드를 좀 더 쉽게 이해할 수 있도록 하는 것도 좋은 방법입니다.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","Playgrounds"],
        "url": "/til/playgrounds2/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "iOS App Dev Tutorials: Scrumdinger",
        "excerpt":"Getting Started with Scrumdinger  아래 모든 정보의 출처는 apple developer 공식 페이지이며 개인의 학습 용도로만 사용되었음을 밝힙니다.  All information below comes from the official apple developer page and is for personal learning purposes only.   영어로 작성된 튜토리얼을 읽으며 정리하는 것이기 때문에 한국어로 읽었을 때 자연스럽게 읽히도록 관사 ‘a’가 생략된 단수형 단어들이 많이 등장합니다. 작성자가 너무 신경쓰이는 것ㅎㅎㅠ   🤘   SwiftUI를 이용한 완벽히 기능을 하는 앱을 만들어보며 iOS 앱 개발의 가장 중요한 부분들에 대해 알아봅니다.   Tour of the App   많은 소프트웨어 엔지니어링 팀들이 그날의 업무에 대한 계획을 짜기 위해 scrums라고 알려진 daily meeting을 합니다. Scrums는 미팅에 참석한 사람들이 어제 이뤄낸 성과들과 오늘 작업할 일, 그리고 그들의 작업에 영향을 미칠지도 모르는 장애물에 대하여 대화를 나누는 짧은 미팅입니다.   이 모듈은 사용자들의 데일리 scrums의 관리를 돕는 iOS앱인 Scrumdinger를 개발하는 과정을 안내합니다.   Scrums가 집중력있게 짧은 시간동안 진행될 수 있도록 Scrumdinger는 미팅에 참가한 사람들이 얼만큼 이야기해야 하는지를 시각적, 청각적 신호를 사용해 알려줍니다. 이 앱은 또한 남은 시간을 알려주는 스크린을 제공합니다.   Build Groups of Views   View는 UI의 한 부분을 정의합니다. 앱의 한 블락을 구성합니다. 간단하고 작은 view들을 조합하여 복잡한 view를 만듭니다.   ContentView.swift   기본 SwiftUI view file은 두개의 structures를 정의합니다. 첫번째 structure는 View 프로토콜을 따릅니다. View 프로토콜의 조건은 한가지로, 하나의 view를 리턴하는 body property를 가지는 것입니다. Body 속성 부분에는 view의 content, layout, behavior를 묘사합니다. 두번째 structure는 canvas에 프리뷰를 제공합니다.   Refactor ContentView.swift   ContentView의 이름 부분을 컨트롤 클릭합니다. Refactor -&gt; Rename을 클릭 후 이름을 변경합니다. (프로젝트 네비게이터에서도 이름이 변경됩니다.)   ProgressView   Body 속성 안에 ProgressView를 예비 데이터와 함께 작성해줍니다. ProgressView는 일정 시간의 지남과 남은 시간을 보여줄 수 있고, 로딩과 같은 남은 시간이 명확하지 않은 시간의 지남도 보여줄 수 있습니다.     Command-click “Embed in VStack”   ProgressView를 Command-click 후 “Embed in VStack”을 클릭하면 ProgressView가 VStack안에 들어오게 됩니다.   Label     첫번째 Text 아래에 라벨을 하나 만들어줍니다. 라벨의 제목은 “300”이고 “hourglass.bottomhalf.fill”이라는 system image를 사용했습니다. 시스템은 system images를 폰트로 취급하기 때문에 사용자의 디바이스 세팅에 대응하여 크기를 조절합니다.   Alignment     Seconds Elapsed와 Seconds Remaining을 담고 있는 VStack에 각각 leading, trailing alignment를 주면 왼쪽 정렬, 오른쪽 정렬 됩니다.   .font(.caption) modifier   .font(.caption) modifier는 Text의 글씨 크기를 줄여줍니다. SwiftUI의 view를 커스터마이즈하기 위해서는 modifiers라는 메서드를 사용합니다. 각각의 modifier는 새로운 view를 리턴합니다. 여러개의 modifier를 한 view에 적용할 수도 있습니다.   Circle()     Circle()       .strokeBorder(lineWidth: 24)  위의 코드를 작성함으로서 뻥 뚫린 24 굵기의 테두리를 가진 원형을 스크린에 출력할 수 있습니다.   Supplement Accessibility data   SwiftUI는 빌트인 accessibility를 가지고 있습니다. 아주 적은 양의 작업으로 accessibility가 앱을 지원하도록 할 수 있습니다. 예를 들어 text view안에 있는 문자열은 자동적으로 VoiceOver와 같은 기능을 할 수 있게 됩니다. 하지만 accessibility 기능의 강화를 위해서 추가적인 작업을 해야 할 때도 있습니다.   VoiceOver   기본적으로 VoiceOver는 system name을 읽어줍니다. 지금 만들어보고 있는 이 앱의 header 부분에 있는 system 이미지의 이름을 읽을 것입니다. hourglass.bottomhalf.fill과 같은 이름이죠.     } // systemImage를 사용했던 HStack 끝부분   .accessibilityElement(children: .ignore)  위의 코드를 작성하여 HStack의 child view의 사용될거라 예상된 accessibility를 무시해줍니다. 이런 과정은 사용자가 더 좋은 accessibility 경험을 할 수 있도록 할 것입니다.     } // systemImage를 사용했던 HStack 끝부분   .accessibilityElement(children: .ignore)   .accessibilityLabel(\"Time remaining\")  의미가 일치하는 이름을 사용하여 accessibility label을 HStack에 추가해줍니다.   사용자가 해당 요소의 목적을 이해할 수 있도록 이름 지어 줍니다. 이 부분에서는 system name 보다는 VoiceOver 사용자가 이해하기 쉬운 가장 중요한 정보를 표현하는 문자를 추가해주었습니다.     } // systemImage를 사용했던 HStack 끝부분   .accessibilityElement(children: .ignore)   .accessibilityLabel(\"Time remaining\")   .accessibilityValue(\"10 minutes\")  Child view의 값을 의도적으로 무시해주었기 때문에 값을 추가해주어야 합니다.   Create a Card View   Create a Color Theme      main color: view의 배경색   accent color: view의 글씨색   을 이용하여 Color Theme을 생성해봅니다.   New Group 만들기   Xcode 맨 왼쪽 아래에 + 버튼을 누르면 프로젝트 네비게이터에 New Group을 생성할 수 있습니다.    Color properties   view를 만들 것은 아니지만 Color properties를 이용하기 위해서 SwiftUI 프레임워크를 임포트 해줍니다.     // Theme.swift    import Foundation   import SwiftUI    enum Theme: String {       case bubblegum       case buttercup       case indigo       case lavender       case magenta       case navy       case orange       case oxblood       case periwinkle       case poppy       case purple       case seafoam       case sky       case tan       case teal       case yellow        // 각 main 컬러에 대응되는 accentColor를 설정해주는 property입니다.       var accentColor: Color {           switch self {               case .bubblegum, .buttercup, .lavender, .orange, .periwinkle, .poppy, .seafoam, .sky, .tan, .teal, .yellow: return .black               case .indigo, .magenta, .navy, .oxblood, .purple: return .white           }       }       // 이 enumeration의 rawValue를 사용하여 색을 생성하는 속성       var mainColor: Color {         Color(rawValue)       }   }    Create a Daily Scrum Model   DailyScrum의 주목적은 value data를 보여주는 것이기 때문에 struct를 만들어 value type으로 만들 것입니다.    (Models Group에 DailyScrum이라는 파일 새로 만들기 후 struct 생성)     struct DailyScrum {     var title: String     var attendees: [String]     var lengthInMinutes: Int     var theme: Theme   }   샘플 데이터를 제공하는 extension을 추가합니다.     extension DailyScrum {     static let sampleData: [DailyScrum] =     [         DailyScrum(title: \"Design\", attendees: [\"Future\", \"Anna\", \"Happ\", \"OShel\"], lengthInMinutes: 10, theme: .yellow),         DailyScrum(title: \"App Dev\", attendees: [\"Katie\", \"Gray\", \"Euna\", \"Luis\", \"Darla\"], lengthInMinutes: 5, theme: .orange),         DailyScrum(title: \"Web Dev\", attendees: [\"Chella\", \"Chris\", \"Christina\", \"Eden\", \"Karla\", \"Lindsey\", \"Aga\", \"Chad\", \"Jenn\", \"Sarah\"], lengthInMinutes: 5, theme: .poppy)     ]   }   Create the Card View   CardView는 DailyScrum 모델 데이터를 요약하고 제목, 참가 인원수, 시간을 보여줄 것입니다. 더 작은 views를 조립하여 CardView를 만들 것입니다. 각각의 views는 DailyScrum structure의 데이터 조각을 화면에 보여줄 것입니다.      Customize the Label Style   Scrum length와 clock 아이콘을 수평으로 쌓기 위해 label style을 만들어 봅니다. LabelStyle 프로토콜을 사용하여 여러개의 views에 같은 label style을 재사용하여 앱의 전반적인 디자인을 통일 시킬 수 있습니다.   (만약 커스텀 라벨 스타일을 만들고 싶지 않다면 built-in label styles를 사용할 수 있습니다.)     // TrailingIconLabel.swift    import SwiftUI    struct TrailingIconLabelStyle: LabelStyle {     func makeBody(configuration: Configuration) -&gt; some View {       }   }      TrailingIconLabel라는 이름의 새 스위프트 파일을 생성합니다.   LabelStyle 프로토콜을 따르는 TrailingIconLabelStyle라는 이름의 structure를 생성합니다. (아직 LabelStyle 프로토콜의 요구사항을 충족하지 않기때문에 컴파일러가 error를 throw합니다.)   비어있는 makeBody function을 생성합니다. (이제 에러가 사라집니다.)   이 스타일이 현재의 라벨 스타일인 뷰 hierarchy 안의 각각의 Label 인스턴스마다 시스템은 이 메서드를 호출합니다.     // TrailingIconLabel.swift    import SwiftUI    struct TrailingIconLabelStyle: LabelStyle {     func makeBody(configuration: Configuration) -&gt; some View {       HStack {         configuration.title         configuration.icon       }     }   }    // TrailingIconLabel.swift     import SwiftUI    struct TrailingIconLabelStyle: LabelStyle {       func makeBody(configuration: Configuration) -&gt; some View {           HStack {               configuration.title               configuration.icon               // 이 메서드의 사용으로 CardView의 오른쪽 Label의 title, icon 순서가 바뀜           }       }   }    extension LabelStyle where Self == TrailingIconLabelStyle {       static var trailingIcon: Self { Self() }       // trailingIcon에 TrailingIconLabelStyle 나 자신을 담아서 다른 곳에서 쉽게 사용할 수 있게 함.       // static 변수이기 때문에 어디서든 leading-dot syntax를 이용하여 사용할 수 있음.       // 위의 이유로 코드가 readable해짐.    }   Displaying Data in a List   SwiftUI ForEach view structure를 사용하여 DailyScrum object의 배열로부터 동적으로 행들을 만들 것입니다.   Display a List of Daily Scrums   ForEach를 이용하여 List view의 정보를 채워줍니다. (미리 작성해둔 sampleData 배열을 이용합니다.)          //  ScrumsView.swift    import SwiftUI    struct ScrumsView: View {       let scrums: [DailyScrum]        var body: some View {           List {               // ForEach closure 안에 CardView initialize 해주기               // 이 closure는 scrums Array에 있는 요소마다 CardView를 리턴함               ForEach(scrums, id: \\.title) { scrum in                   // 첫번째 scrum은 CardView의 속성으로 DailyScrum 타입임.                   // 두번째 scrum은 ForEach문에서 DailyScrum의 각 요소가 할당되는 곳                   CardView(scrum: scrum)                       .listRowBackground(scrum.theme.mainColor)                   // 각 scrum 요소의 theme main을 이용                }           }       }   }    struct ScrumsView_Previews: PreviewProvider {       static var previews: some View {           ScrumsView(scrums: DailyScrum.sampleData)       }   }   Make Scrums Identifiable   ForEach structure는 식별 가능한(Identifiable) 정보를 반복하여 실행하며 동적인 뷰를 만듭니다. 위에서 List 안에 사용한 ForEach에서는 요소를 식별하기 위한 key path로 title을 사용했습니다. (sample data의 title이 모두 달랐기 때문에 가능했습니다.) 하지만 만약 실제 사용자가 이미 존재하는 title과 같은 title로 새 scrum을 만든다면 문제가 발생할 수 있습니다.   User-generated content   사용자가 생성하는 컨텐츠를 사용하는 앱을 작동시키기 위해서 DailyScrum이 Identifiable 프로토콜을 따르도록 할 것입니다. 이것은 위에서 이용했던 방법처럼 title을 key path로 사용하는 것보다 더 안전하게 문제가 쉽게 일어나지 않은 방법이 될 것입니다. Identifiable 프로토콜의 요구사항은 id 속성을 갖는 것입니다.       struct DailyScrum: Identifiable {       let id: UUID          // UUID 타입의 id 속성 생성       var title: String       var attendees: [String]       var lengthInMinutes: Int       var theme: Theme        // init 생성자 생성       init(id: UUID = UUID(), title: String, attendees: [String], lengthInMinutes: Int, theme: Theme) {           self.id = id           self.title = title           self.attendees = attendees           self.lengthInMinutes = lengthInMinutes           self.theme = theme       }   }   App protocol   이제 ScrumsView를 앱의 루트 뷰로 만들어 줍니다. SwiftUI 앱은 App 프로토콜을 따르는 structure를 정의함으로써 생성할 수 있습니다. 앱의 바디 속성은 사용자가 주로 사용할 첫번째 화면을 보여주는 view hierarchy를 담은 Scene을 리턴합니다.     import SwiftUI    @main   struct ScrumdingerApp: App {       var body: some Scene {           WindowGroup {               ScrumsView(scrums: DailyScrum.sampleData)           }       }   }   WindowGroup   WindowGroup은 SwiftUI가 제공하는 scenes 중 하나입니다. iOS에서는, WindowGroup scene builder에 추가된 view가 기기의 전체 화면을 채우는 윈도우에 나타나게 됩니다.   Creating a Navigation Hierarchy   지금까지 views를 만들어 보았고 이제부터는 그 views 사이를 이동하는 방법에 대해 알아보겠습니다.   NavigationView와 Link     //  ScrumsView.swift    import SwiftUI    struct ScrumsView: View {       let scrums: [DailyScrum]        var body: some View {           List {               // ForEach closure 안에 CardView initialize 해주기               // 이 closure는 scrums Array에 있는 요소마다 CardView를 리턴함               ForEach(scrums) { scrum in                   // 첫번째 scrum은 CardView의 속성으로 DailyScrum 타입임.                   // 두번째 scrum은 ForEach문에서 DailyScrum의 각 요소가 할당되는 곳                   NavigationLink(destination: Text(scrum.title)) {                       CardView(scrum: scrum)                   }                   .listRowBackground(scrum.theme.mainColor)                   // 각 scrum 요소의 theme main을 이용                }           }           .navigationTitle(\"Daily Scrums\")   // -&gt; title은 부모 navigation stack 안쪽에           .toolbar {               Button(action: {}) {                   Image(systemName: \"plus\")               }               .accessibilityLabel(\"New Scrum\")           }       }   }    struct ScrumsView_Previews: PreviewProvider {       static var previews: some View {           // Navigation title을 위한 padding을 화면에 보여줌           NavigationView {               ScrumsView(scrums: DailyScrum.sampleData)           }       }   }    ScrumsView.swift 파일에 NavigationView와 NavigationLink를 추가하여 코드를 수정해줍니다.           영상에서 볼 수 있듯이 SwiftUI는 자동으로 디테일 뷰에서 Back 버튼을 추가하고 전 화면의 타이틀을 표시합니다.   Create the Detail View   계층 구조를 가지고 있는 앱(hierarchical apps)에서는, 더 높은 계층의 view에서 detailed view로 이동합니다. 그러므로써 더 특정된 데이터를 조작할 수 있습니다. 이 섹션에는 각 scrum의 디테일 뷰를 만들어 볼 것입니다.      DetailView.swift를 생성합니다.   DetailView.swift에 DailyScrum 타입의 scrum constant를 생성합니다.   ScrumsView.swift에 NavigationLink의 destination을 수정합니다.     ForEach(scrums) { scrum in       NavigationLink(destination: DetailView(scrum: scrum)) {           CardView(scrum: scrum)       }       .listRowBackground(scrum.theme.mainColor)       // 각 scrum 요소의 theme main을 이용    }  destination을 DetailView로 수정해주었습니다. (scrum: )은 DetailView의 constant이고 그 뒤에 오는 scrum은 ForEach문에 사용된 변수입니다.   DetailView with Visual Components   List   List view를 이용하여 scrum의 이름, 미팅 시간, 카드의 색, 참석자들의 목록을 디테일 뷰에 보여줍니다.     // DetailView.swift    struct DetailView: View {     let scrum: DailyScrum      var body: some View {         List {             Section(header: Text(\"Meeting Info\")) {                 Label(\"Start Meeting\", systemImage: \"timer\")                 Spacer()                 HStack {                     Label(\"Length\", systemImage: \"clock\")                     Spacer()                     Text(\"\\(scrum.lengthInMinutes) minutes\")                 }                 .accessibilityElement(children: .combine)                }           }       }   }  Sections List안의 목록의 그룹을 만들어서 눈에 보이는 구분점을 만들어줍니다.   .accessibilityElement(children: .combine)    위의 modifier를 이용하여 Label view와 Text view를 하나로 합쳐줍니다. (accessibility user를 위해)   Iterate Through Attendees     //DailyScrum.swift    struct DailyScrum: Identifiable {       let id: UUID       var title: String       var attendees: [Attendee]       var lengthInMinutes: Int       var theme: Theme        init(id: UUID = UUID(), title: String, attendees: [String], lengthInMinutes: Int, theme: Theme) {           self.id = id           self.title = title           self.attendees = attendees.map { Attendee(name: $0) }           self.lengthInMinutes = lengthInMinutes           self.theme = theme       }   }    extension DailyScrum {       struct Attendee: Identifiable {           let id: UUID            // id 속성은 let           var name: String            // id 속성에 defalut 값을 주는 생성자           init(id:UUID = UUID(), name: String) {               self.id = id               self.name = name           }       }   }   DailyScrum에 extension을 추가하여 안에 Attendee라는 structure를 만들어 줍니다. ForEach를 이용해 sample data의 참석자들을 DetailView에 보여줄 것 이므로 Attendee의 id, name 속성을 정의합니다. id 값에 디폴트 값을 주기 위해서 생성자를 만듭니다. 처음에 만들어 두었던 DailyScrum 모델에서 attendees의 타입을 [Attendee] (Attendee 타입의 배열)로 수정해줍니다.   map(_:)   map(_:)은 이미 존재하는 collection의 각 요소에 반복해서 변화를 적용하며 새로운 collection을 생성합니다.     // init 생성자 안   self.attendees = attendees.map { Attendee(name: $0) }  패러미터를 통해 들어온 attendees를 map을 이용해 반복해 돌면서 Attendee 타입으로 바꿔준다.(?)   ForEach     Section(header: Text(\"Attendees\")) {                 ForEach(scrum.attendees) { attendee in                     Label(attendee.name, systemImage: \"person\")                 }             }  Attendee가 identifiable 해졌으므로 ForEach를 사용하여 sample data를 통해 동적으로 참석자들의 리스트를 만들 수 있게 되었습니다.       Navigate Between Screens   DetailView에서 이동하는 view를 만들며 hierarchy 설정을 마무리해봅니다.     NavigationLink(destination: MeetingView()) {                     Label(\"Start Meeting\", systemImage: \"timer\")                         .font(.headline)                         .foregroundColor(.accentColor)                 }  NavigationLink를 추가하는 것은 label을 gesture recognizer 형태로 감싸줍니다. 이로 인해 사용자들을 이 행을 탭하여 meeting timer screen을 볼 수 있게 됩니다.   이렇게 navigation stack을 완성했습니다.   Managing Data Flow Between Views   사용자에게 정보를 보여주고 사용자와 상호작용하며 데이터를 수정해 보여주는 것은 대부분의 앱들에 기본이 되는 기능입니다. 앱의 UI가 현재 데이터의 상태를 잘 반영하도록 하기 위해 @State와 @Binding을 사용하는 방법에 대해 알아봅니다.   Source of Truth   한 정보의 여러가지 복사본을 유지하는 것은 앱을 버르고 이끄는 불일치를 초래할 수 있습니다. 데이터 불일치 버그를 피하기 위해 앱의 각 데이터들을 위해 a single source of truth를 사용합니다. 한 장소에 요소를 저장하세요. (the source of truth에) 그리고 몇개의 view든 그 데이터에 접근할 수 있습니다. Source of truth는 코드 전체 어디에든 작성할 수 있습니다.    Scrumdinger 앱에서는 모든 뷰들이 접근을 공유할 ScrumdingerApp에 source of truth를 생성할 것입니다.   Swift Property Wrappers   State   @State를 이용해 속성을 정의하면, 해당 view안에 a source of truth를 생성할 수 있습니다. 시스템은 @State property를 사용하는 뷰의 모든 요소들을 식별합니다. 사용자의 사용자와의 상호작용은 @State 속성의 값을 변화시킬 수 있고, 시스템은 @State를 사용하는 속성을 업데이트 함으로써 새로운 버전의 UI를 렌더링합니다.   @State의 값이 변하면 시스템은 업데이된 값을 사용하는 뷰를 다시 그립니다. 예를 들어 Scrumdinger 앱의 사용자가 하나의 scrum을 수정하면 ScrumsView는 업데이트 된 값을 화면에 보여주기 위해서 list를 다시 그립니다.   State property는 잠시 머무르는 상태를 관리하는 것을 돕기 때문에 private으로 정의하고 지속되야하는 저장에는 사용하는 것을 피해야 합니다.   Binding   @Binding을 사용하여 감싼 property는 읽기 그리고 쓰기에 대한 접근을 존재하는 source of truth와 공유합니다. (@State property 처럼…)    @Binding은 데이터를 직접적으로 담지 않습니다. 대신, 그 데이터를 업데이트하고 화면에 보여주는 source of truth와 view 사이의 양방향 연결을 생성합니다. 이 연결은 여러개의 뷰와 연결된 하나의 데이터가 항상 업데이트 된 상태로 유지되게 합니다.      Creating the Edit View   Update the Data Model   Edit view를 만들기 전에, DailyScrum.swift안에 새로운 타입인 Data를 생성합니다. Data는 DailyScrum에 편집이 가능한 모든 속성들을 담을 것입니다. 이 속성들을 edit view에 생성할 controls와 일치할 것입니다.     struct Data {       var title: String       var attendees: [Attendee]       var lengthInMinutes: Double       var theme: Theme   }  DailyScrum의 extensnion안에 Data structure를 정의합니다. 사용자가 Slider view를 이용해 미팅 시간을 조정하게 됩니다. Sliders는 Double 값을 이용하므로 lengthInMinutes의 자료형을 Double로 줍니다.   Foundation 프레임워크에 Data structure가 있기 때문에 DailyScrum의 extension에 Data structure를 정의해서 nested type으로 만들면서 (-&gt; DailyScrum.Data) 두개를 분리할 수 있게 됩니다.     struct Data {       var title: String = \"\"       var attendees: [Attendee] = []       var lengthInMinutes: Double = 5       var theme: Theme = .seafoam   }    var data: Data {       Data(title: title, attendees: attendees, lengthInMinutes: Double(lengthInMinutes), theme: theme)   }  그리고 각 속성에 기본값을 줍니다. 모든 속성이 기본 값을 가지고 있다면 컴파일러는 인자가 필요없는 생성자를 만듭니다. 이렇게 만들어진 생성자는 Data()로 호출되어 인스턴스를 생성할 수 있습니다.   DailyScrum 속성 값을 가지는 Data를 리턴하는 computed property\b도 생성해 줍니다.   Add an Edit View for Scrum Details      Edit View를 생성하고, scrum의 제목과 소요 시간을 수정하기 위해 이용되는 controls를 생성합니다.   Scrum 데이터의 변화를 Data 속성 형식으로 저장합니다.   @State property wrapper를 사용합니다.     @State private var data = DailyScrum.Data()  DetailEditView.swift 파일을 만들고 위의 코드를 추가하여 source of truth를 정의합니다.    Data 타입의 모든 속성에 기본값을 주었으므로 자동으로 생성된 생성자 DailyScrum.Data()를 @State property wrapper로 감싸줍니다. 오직 이 속성을 정의한 이 view에서만 접근 가능하도록 private 속성으로 정의합니다.     struct DetailEditView: View {       @State private var data = DailyScrum.Data()       var body: some View {           Form {               Section(header: Text(\"Meeting Info\")) {                   TextField(\"Title\", text: $data.title)               }           }       }   }  Form은 다른 플랫폼들에서 controls의 모양이 자동으로 적응된 모습으로 렌더링 되도록 합니다.   제목을 입력할 TextField를 생성합니다. TextField는 binding을 String으로 받아들입니다. $ syntax를 사용하여 data.title에 binding을 생성합니다. 현재의 뷰는 data 속성의 상태를 조작할 수 있게 됩니다.     HStack {       TextField(\"New Attendee\", text: $newAttendeeName)       Button(action: {           withAnimation {               let attendee = DailyScrum.Attendee(name: newAttendeeName)               data.attendees.append(attendee)               newAttendeeName = \"\"      // text field를 비워줌           }       }) {           Image(systemName: \"plus.circle.fill\")       } // 버튼 끝       .disabled(newAttendeeName.isEmpty)   }   Text field가 newAttendeeName의 binding을 가지고 있기 때문에 없는 값을 설정해주므로써 text fields의 컨텐츠를 비울 수 있습니다.   newAttendeeName이 비어있을 때는 버튼을 비활성화 시킵니다. 이것은 유저가 이름 없는 참석자를 추가하는 것을 방지해줍니다. 유저가 이름을 입력하면 버튼은 활성화됩니다.   Present the Edit View   DetailView에서 버튼을 누르면 Modal view의 형식으로 DetailEditView를 보여줄 것입니다.    @State private var isPresentingEditView = false    } // DetailView.swift - List view 끝부분   .navigationTitle(scrum.title)   .toolbar {       Button(\"Edit\") {           isPresentingEditView = true       }   }   .sheet(isPresented: $isPresentingEditView) {       DetailEditView()   }     sheet modifier는 현재 화면의 content를 부분적으로 가리는 modal sheet를 생성합니다.   Button을 누르면 위의 정의했던 isPresentingEditView가 true로 바뀌고 sheet가 가지고 있는 isPresentingEditView 바인딩이 true값을 가지게 되면서 DetailEditView가 modal sheet로 보여지게 됩니다.     .sheet(isPresented: $isPresentingEditView) {       NavigationView {           DetailEditView()               .navigationTitle(scrum.title)               .toolbar {                   ToolbarItem(placement: .cancellationAction) {                       Button(\"Cancel\") {                           isPresentingEditView = false                       }                   }                   ToolbarItem(placement: .confirmationAction) {                             Button(\"Done\") {                                 isPresentingEditView = false                             }                         }               }       }   }  ToolbarItem으로 modal view에 Cancel / Done 버튼을 생성합니다. Cancel버튼을 누르면 변경 사항이 저장되지 않고 취소되고 모달 뷰가 사라집니다. Done 버튼은 변경 사항이 저장되고 모달 뷰가 사라집니다. (아직 데이터를 진짜 저장할 수는 없습니다.)   Passing Data with Bindings   Add a Theme View   사용자가 각 scrum을 구별하기 쉽게 하기 위해 Color theme을 선택할 수 있도록 할 것입니다. 먼저 theme 의 components를 보여줄 theme view를 생성합니다.     //  ThemeView.swift    import SwiftUI    struct ThemeView: View {       let theme: Theme        var body: some View {           ZStack {               RoundedRectangle(cornerRadius: 4)                   .fill(theme.mainColor)               Label(theme.name, systemImage: \"paintpalette\")                   .padding(4)           }           .foregroundColor(theme.accentColor)           .fixedSize(horizontal: false, vertical: true)       }   }    struct ThemeView_Previews: PreviewProvider {       static var previews: some View {           ThemeView(theme: .buttercup)       }   }   fixedSize modifier를 사용하여 라벨의 원래 사이즈에 크기를 맞춰줍니다. Label에 패딩을 추가해주어서 더 보기 편하게 만들어 줍니다. 여기서 만든 view는 전체 컬러를 보여주는 list의 한 cell로 이용할 것입니다.   Add a Theme Picker   사용자가 meeting view의 theme 색을 선택할 수 있도록하는 custom interactive view를 생성합니다.     // ThemePicker.swift    import SwiftUI    struct ThemePicker: View {       @Binding var selection: Theme            var body: some View {           Picker(\"Theme\", selection: $selection) {               ForEach(Theme.allCases) { theme in                   ThemeView(theme: theme)                       .tag(theme)               }           }       }   }    struct ThemePicker_Previews: PreviewProvider {       static var previews: some View {           ThemePicker(selection: .constant(.periwinkle))       }   }  ThemePicker.swift 파일을 새로 생성해줍니다. DetailEditView에 들어갈 Picker view를 생성합니다. ForEach를 사용해 각 case로의 접근을 용이하게 합니다.   Theme.swift의 enum Theme에 CaseIterable, Identifiable 프로토콜을 추가해줍니다. id 속성은 case의 이름으로 추가해줍니다.     // DetailEditView.swift - body - Form   } Slider 있는 HStack 끝부분   ThemePicker(selection: $data.theme)  위의 ThemePicker 생성자는 theme selection에 일어난 변화를 data.theme으로 다시 돌려보냅니다.   constant(_:) type method   변경되지 않는 값을 가지는 binding을 생성합니다. PreviewProvider를 사용할 때, 다른 값들을 어떻게 보여주는지 알아보기 위해서 사용할 수 있습니다.   Pass the Edit View a Binding to Data   사용자가 scrum의 정보를 수정하면, 앱에 있는 여러개의 screen이 그 변경된 정보를 반영해야 합니다. 이 섹션에서는, 사용자가 Done 버튼을 눌렀을 때 edit view에 detail view의 scrum을 업데이트하는 binding을 추가합니다.   디테일 화면은 edit화면에서 만들어진 변경 사항을 업데이트 해야 합니다. 그래서 디테일 화면은 source of truth를 edit 화면과 공유합니다.   Edit 화면에 기존 scrum 정보 가져오기   Edit 버튼을 누르면 scrum에 입력되어 있던 기존 정보를 edit modal sheet에 보여주도록 설정해 봅니다.     .toolbar {       Button(\"Edit\") {           isPresentingEditView = true           data = scrum.data       }   }    data = scrum.data    // = 왼쪽에 있는 data   @State private var data = DailyScrum.Data()    // = 오른쪽 scrum. 뒤의 data   var data: Data {       Data(title: title, attendees: attendees, lengthInMinutes: Double(lengthInMinutes), theme: theme)   }  비어있는 생성자는 기본 값을 가진 인스턴스를 생성합니다. 이 값들을 선택한 scrum의 값으로 설정해줍니다.      튜토리얼 중 빠진 부분(?)     // DetailView.swift    ToolbarItem(placement: .confirmationAction) {       Button(\"Done\") {           isPresentingEditView = false           scrum.update(from: data) // &lt;- 계속해서 에러가 나던 부분       }   }  컴파일러가 위의 표시한 곳에서 자꾸 에러를 발생시켰다. 코드를 다르게 타이핑 한걸까해서 열심히 찾아보았지만 다른 부분은 없었다. Complete 버전의 프로젝트 파일을 받아서 확인해보던 중 DailyScrum.swift에서 튜토리얼에는 없던 function을 발견했다.     mutating func update(from data: Data) {       title = data.title       attendees = data.attendees       lengthInMinutes = Int(data.lengthInMinutes)       theme = data.theme   }  위의 코드를 DailyScrum의 extension에 추가해주면 정상적으로 작동한다.   이 튜토리얼에서는 ❕      @State property wrapper를 이용해서 value type의 source of truth를 생성해 보았습니다.   @Binding을 사용하여 다른 views의 state에 쓰기 권한을 공유해 보았습니다. (사용자로부터 입력받은 정보로 @State로 감싼 변수를 사용하는 views에 데이터를 업데이트한 것을 말하는 것 같습니다.)   Making Classes Observable   위에서는 @State와 @Binding을 이용하여 value type를 source of truth로 정의하는 것에 대해 알아보았습니다. 여기서는 앱의 UI를 위해 reference type을 source of truth로 정의하는 방법에 대해 알아봅니다.   @State property wrapper는 value types에만 적용할 수 있습니다. structures나 enumerations 같은 것이죠. SwiftUI는 reference type을 source of truth로 정의하는 property wrappers를 제공합니다.      @ObservableObject   @StateObject   @EnvironmentObject   reference type인 class와 함께 property wrappers를 사용하기 위해서는 class를 observable하게 만들어야 합니다.   Making a Class Observable   ObservableObject protocol를 따름으로써 class를 observable하게 만들 수 있습니다.    클래스 안의 properties 중 정보가 변경되었을 때 UI에 변화를 일으키는 properties를 선택하고 그 properties에 각각 @Published attribute를 추가해줍니다.     class ScrumTimer: ObservableObject {       @Published var activeSpeaker = \"\"       @Published var secondsElapsed = 0       @Published var seconds Remaining = 0       // ...   }  위 클래스의 속성은 한번의 scrum 세션에서 빈번하게 업데이트 될 것입니다. ScrumTimer는 published properties의 값에 변경 사항이 있을 때마다 observers에게 그것을 알려줍니다.          Responding to Events   Scene Architecture   App state에 대해 알아보기 전에, SwiftUI가 scenes를 구성하는 방법에 대해 복습해 봅니다.    Scene은 시스템이 관리하는, 라이프 사이클을 가지고 있는 앱의 사용자 인터페이스의 부분입니다.           앱을 만들기 위해서, App protocol을 따르는 structure를 정의합니다. @main attribute를 앞에 표시해줌으로써 시스템에게 이 structure가 앱의 entry point라는 것을 알려줍니다.            ScrumdingerApp.swift의 structrue속 body 부분에 Scene 프로토콜을 따르는 scenes를 추가했습니다. Scenes는 앱이 보여주는 뷰 계층을 담는 컨테이너 입니다.            SwiftUI는 WindowGroup과 같은 scenes를 제공합니다. 시스템은 scenes의 라이프 사이클을 관리하고 플랫폼에 맞는, 환경에 맞는 뷰 계층을 화면에 보여줍니다. 예를들어 iPadOS의 멀티테스킹은 같은 앱의 여러개의 더 작은 인스턴스들을 동시에 보여줄 수 있습니다.       Scene Phases and Transitions   앱의 실행 중, scene은 3단계의 변화가 있을 수 있습니다.      active : scene이 foreground에 있고, 사용자가 scene과 상호작용할 수 있습니다.   inactive : scene을 볼 수 있지만 시스템이 scene과의 상호작용을 중지시킵니다. 예를 들어 멀티 테스킹 모드에서 앱의 패널 볼 수 있지만 패널이 활성화되어 있지는 않습니다.   background : 앱은 작동되고 있지만 scene을 볼 수 없습니다. 앱의 종료 전에 scene은 이 단계에 들어갑니다.   Managing State and Life Cycle   Scrumdinger는 scrum이 바뀔 때마다 바뀌었다는 것을 사용자에게 알려줍니다. 이 key feature을 만들기 위해 scrum을 관리하는 모델을 제어하는 life cycle methods를 사용할 것입니다.   이 튜토리얼에서는 reference type models와 SwiftUI view를 이용하는 방법에 대해 알아봅니다.   Create an Overlay View   MeetingView.swift의 header 부분을 따로 분리합니다. MeetingHeaderView.swift라는 새 SwiftUI 파일을 생성하고 ProgressView와 HStack 부분을 MeetingHeaderView.swift로 옮겨 줍니다. 그리고 지금까지 static 데이터를 dynamic 데이터로 교체하기 위해 속성을 추가할 것입니다.     private var totalSeconds: Int {       secondsElapsed + secondsRemaining   }   private var progress: Double {       guard totalSeconds &gt; 0 else { return 1 }       return Double(secondsElapsed) / Double(totalSeconds)   }  ProgressView에서 progress를 나타내는 computed property입니다. totalSeconds가 0보다 크면 지난 시간을 전체 시간으로 나누어서 진행된 시간을 나타내줍니다.   Add a State Object for a Source of Truth   Value type models의 source of truth를 생성하기 위해서 @State 를 사용했습니다. ObservableObject 프로토콜을 따르는 reference type models의 source of truth를 생성하기 위해서는 @StateObject 를 사용합니다.     struct MeetingView: View {     @Binding var scrum: DailyScrum     @StateObject var scrumTimer = ScrumTimer()     // ...   }  @StateObject로 속성을 wrapping 한다는 것은 속한 해당 view가 그 object의 source of truth를 소유한다는 것을 의미합니다. @StateObject는 ScrumTimer를 MeetingView life cycle에 속박시킵니다.    ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift"],
        "url": "/til/scrumdinger/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Closures",
        "excerpt":"Closures 아래 모든 정보의 출처는 Swift 공식 문서이며 개인의 학습 용도로만 사용되었음을 밝힙니다.  All information below comes from the Swift documentation and is for personal learning purposes only.   { }  Closures는 기능을 담고 있는 완전한 블락으로 코드 안에서 사용될 수 있습니다.    Constants와 Variables의 references를 찾아내고 담을 수 있습니다.   이것을 closing over constants and variables한다고 합니다.   Swift는 capturing과 관련된 모든 메모리 관리를 처리해줍니다.   Functions and Closures   전역범위의 function 그리고 nested funtions는 모두 사실 특별한 케이스의 closures입니다.    클로저는 세가지 형태로 나눠집니다.      Global functions는 이름을 가지고 있지만 어떤 값도 capture하지 않는 클로저입니다.   Nested functions는 이름을 가지고 있고 자신을 감싸고 있는 function의 값을 capture할 수 있는 클로저입니다.   Closure expressions 주변의 값을 capture할 수 있는 가벼운 syntax로 쓰여진, 이름이 없는 클로저입니다.   Closure Expressions   Swift의 closure expressions는 간결하고 깔끔하도록 최적화된 syntax와 함께 명확한 스타일을 가지고 있습니다.    이 최적화는 아래의 네가지를 포함합니다.      패러미터와 리턴 값의 타입을 문맥의 흐름으로부터 추론합니다.   single-expressions closures로부터의 키워드로 표현되지 않은 returns   약칭으로 된 argument의 이름   Trailing closure syntax 👷   Closure expressions는 inline closures를 짧고 집중된 형태의 syntax로 작성하는 방식입니다.         💡       inline은 사용되기 전에 중간 변수에 할당되지 않고 바로 사용되는 것을 말합니다.            Closure expressions는 closures를 정확함과 의도를 잃지 않으면서 단축된 형태로 작성하기 위한 몇몇개의 syntax 최적화를 제공합니다.   The Sorted Method   Swift의 standard library는 sorted(by:)를 제공합니다. 타입이 명확하게 밝혀진 값을 가지고 있는 배열을 정렬하는 메서드입니다. 주어진 sorting closure의 출력결과를 기반으로 배열의 값을 정렬합니다. 정렬하는 과정이 완료되면 sorted(by:) 메서드는 타입과 사이즈는 같지만 조건대로 정렬된 새로운 배열을 리턴합니다. 원래의 배열은 수정되지 않습니다.   아래의 closure expressions의 예제는 String type의 값을 가진 names라는 배열을 알파벳 순서의 반대로 정렬할 것입니다.     let names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]  sorted(by:)메서드는 배열의 contents와 같은 자료형의 arguments 두개를 받아들이는 closure를 가지고 있습니다. 그리고 값들이 정렬되면 첫번째 값이 두번째 값의 전, 또는 후에 나타나야 한다는 것을 알려주는 Bool 값을 리턴합니다. 이 sorting closure는 첫번째 값이 두번째 값 전에 나타나야 한다면 true를 리턴합니다. 그리고 반대 상황에서는 false를 리턴합니다.   이 예시는 String값의 배열을 정렬하므로 sorting closure는 (String, String) -&gt; Bool 타입의 function이 필요합니다.   The sorting closure: 방식1   이 sorting closure를 제공하는 한 방식으로는, function을 작성하고 sorted(by:)메서드의 인자로 통과시키는 방법이 있습니다.     func backward(_ s1: String, _ s2: String) -&gt; Bool {       return s1 &gt; s2   }   var reversedNames = names.sorted(by: backward)   // reversedNames = [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"]  만약 첫번째 문자열(s1)이 두번째 문자열(s2)보다 크다면, backward function은 true를 리턴합니다. 이것은 정렬된 배열에서 s1이 s2전에 나타나야 한다는 것을 나타냅니다. 알파벳에서는 뒤로 갈수록 큰 값이기 때문에 알파벳의 역순으로 정렬됩니다.   위의 방법은 꼭 필요한 single expression function (a &gt; b)를 작성한 긴 버전의 방법이었습니다.   The sorting closure: 방식2   Closure Expression Syntax를 이용해서 inline 방식으로 sorting closure를 작성하는 것이 더 나은 방식이 될 것입니다.   Closure Expression Syntax의 일반적인 형태:     { ( parameters ) -&gt; return type in       statements   }   Closure expression syntax의 패러미터는 in-out 패러미터 둘 다 될 수 있습니다. 하지만 default 값은 가질 수 없습니다. 아래의 예시는 closure expression 버전의 backward function입니다.     reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in         return s1 &gt; s2   })   위의 inline closure의 패러미터와 리턴 타입을 정의한 방식은 backward function의 정의한 방식과 똑같습니다. 둘다 (s1: String, s2: String) -&gt; Bool 이라고 쓰였습니다. 하지만 inline closure expression에서는 { } 밖이 아니라 안에 작성되었다는 차이점이 있습니다. 그리고 바디 부분의 시작을 in 키워드로 알렸습니다. in 키워드는 클로저의 패러미터와 리턴 타입의 정의가 끝났다는 것을 알려주고 바디 부분이 시작된다는 것을 나타냅니다.   Inferring Type From Context   위의 sorting closure가 sorted(by:) 메서드의 argument로 통과되기 때문에 Swift는 sorting closure의 패러미터의 타입과 리턴 값의 타입을 추측할 수 있습니다. 그렇기 때문에 패러미터와 리턴 값의 타입은 작성될 필요가 없어집니다. 모든 타입들이 추측 가능해짐으로 return arrow(-&gt;)와 패러미터를 감싸는 괄호 또한 생략 가능해집니다.     reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )  Function이나 method에 closure를 통과시킬때는 언제나 패러미터 타입과 리턴 값의 타입을 추측하는 것이 가능합니다. 그렇기 때문에 function이나 method의 인자로써 inline closure을 사용할 때는 완전한 형태로 작성할 필요가 없어집니다.   그럼에도 불구하고, 원한다면 자료형을 명시할 수 있습니다. 만약 코드를 읽어야하는 사람들을 위해 모호한 부분을 피하고 싶다면 자료형을 명시하는 것은 좋은 방법이 될 것입니다.   Implicit Returns from Single-Expression closures   Single-expression closures는 return 키워드를 생략하고 single expression의 결과를 리턴할 수 있습니다.     reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )   Shorthand Argument Names   Swift는 inline closures의 argument 이름을 간단하게 전달하는 방법을 제공합니다. $0, $1, $2 등으로 클로저의 인자값을 나타낼 때 사용됩니다.   만약 closure expression에서 이 shorthand argument names를 사용한다면, 클로저의 argument list를 생략할 수 있습니다. shorthand argument names의 자료형은 사용되길 예상되는 function의 자료형으로부터 추측 가능하고, 가장 높은 수의 shorthand argument는 해당 클로저가 사용할 argument의 개수를 결정합니다. 이 closure expression의 전체가 바디부분으로 이루어져 있음으로 in 키워드도 생략이 가능합니다.     reversedNames = names.sorted(by: { $0 &gt; $1 } )   위의 예시에서, $0은 첫번째 String argument를 $1 은 두번째 String argument를 나타냅니다. $1이 가장 높은 숫자의 shorthand argument라는 것은 해당 클로저가 두개의 arguments를 사용하는 것을 나타냅니다.   Operator Methods   심지어 더 짧은 방식으로 closure expression을 작성할 수 있습니다. Swift의 String type은 greater-than operator(&gt;)의 특정 이행 메서드를 가지고 있습니다. 이 메서드의 패러미터 타입과 리턴 타입이 sorted(by:)메서드에게 필요한 패러미터 타입, 그리고 리턴 타입과 정확히 일치하기 때문에 단순히 &gt; 하나만 통과시키더라도 Swift는 String 타입의 string-specific implementation을 사용하길 원한다는 것을 추론할 수 있을 것입니다.     reversedNames = names.sorted(by: &gt; )   Trailing closures   Closure expression을 어떤 function의 마지막 argument로 통과시켜야 하고 그 closure expression이 길다면, 해당 closure expression을 trailing closure로 작성하는 것이 유용한 방법이 될 수 있습니다. 사용하는 trailing closure가 function의 argument이더라도  function call의 () 뒤에 trailing closure을 작성합니다. 이 trailing closure syntax를 사용할때는 function을 호출할 때 첫번째 closure의 argument label (closure: // 같은)은 작성하지 않습니다. 아래의 예제는 single trailing closure를 사용하고 있지만 하나의 function call이 여러개의 trailing closures를 포함할 수 잇습니다.     func someFunctionThatTakesAClosure(closure: () -&gt; Void) {       // funtion body 부분   }    // trailing closure를 사용하지 않고 위의 function을 호출하는 방법   someFunctionThatTakesAClosure(closure: {       // closure의 바디 부분     })    // trailing closure 사용   someFunctionThatTakesAClosure() {       // trailing closure의 바디 부분   }     위에서 작성해보았던 string-sorting closure도 sorted(by:)메서드의 괄호 밖에서 trailing closure로 작성될 수 있습니다.     reversedNames = names.sorted() { $0 &gt; $1 }   만약 closure expression이 function이나 method의 유일한 argument이고 trailing closure로 작성한다면 ()를 생략할 수 있습니다.     reversedNames = names.sorted { $0 &gt; $1 }   Trailing closures는 어떤 closure가 한 줄 위에 inline 형식으로 작성이 어려울 정도로 길이가 길 때 가장 유용하게 사용됩니다. 예를 들어, Swift의 Array type은 map(_:) 메서드를 가지고 있습니다. 이 메서드는 하나의 closure expression을 argument로 가집니다. 해당 클로저는 배열의 각 아이템마다 한번씩 호출됩니다. 그리고 해당 item을 다르게 mapped된 value를 리턴합니다. (다른 타입일 수 있습니다.) map(_:) 메서드에 통과시킬 클로저 안에 코드를 작성함으로써 mapping의 종류와 리턴 값의 타입을 특정 짓습니다.   주어진 클로저를 배열의 각 요소마다 적용한 뒤에, map(_:) 메서드는 새로 mapped된 값을 원래의 연결된 배열의 값과 같은 순서로 담고 있는 새 배열을 리턴합니다.   아래 예시는 map(_:)메서드와 trailing closure를 사용하여 Int 타입의 값을 가지고 있는 배열을 String 타입의 값을 가진 배열로 변환하는 방법을 설명합니다. 배열 [16, 58, 510]은 새로운 배열인 [“OneSix”, “FiveEight”, “FiveOneZero”]를 생성하기 위해 사용되었습니다.     let digitNames = [       0: \"Zero\", 1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\",       5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"   ]   let numbers = [16, 58, 510]  위의 코드는 숫자와 영어 버전의 숫자 이름을 맵핑한 dictionary를 생성합니다. 문자열 배열로 변환될 numbers 배열도 정의합니다.   Array 타입의 map(_:)메서드에 trailing clousre로 closure expression을 통과시켜 numbers 배열을 문자열 배열로 만들어 봅니다.     let string = numbers.map { (number) -&gt; String in       var number = number       var output = \"\"       repeat {           output = digitNames[number % 10]! + output           number /= 10       } while number &gt; 0       return output   }   // strings 상수의 타입은 [String]으로 추론됩니다.   // 값은 [\"OneSix\", \"FiveEight\", \"FiveOneZero\"] 입니다.  map(_:) 메서드는 numbers 배열안의 각 item마다 closure expression을 호출합니다. 맵핑될 배열의 값으로부터 타입을 추론할 수 있기 때문에 클로저의 인풋 패러미터인 number의 타입을 특정지을 필요가 없습니다.   위의 예시에서 var number는 초기값으로 closure의 패러미터인 number를 가집니다. 이렇게 함으로써 클로저의 바디안에서 그 값이 변경될 수 있게 됩니다. (function 또는 closures의 패러미터는 언제나 constants 이기 때문에) 이 closure expression은 또한 mapped output 배열안의 담길 값의 타입을 나타내기위해 리턴 타입을 String으로 특정 지었습니다.   위의 closure expression은 호출될 때마다 ouput이라는 이름의 문자열을 만듭니다. 이것은 remainder operator (number % 10)을 사용하여 number의 마지막 수를 찾아내고 이렇게 찾아낸 숫자를 digitNames dictionary에서 키 값으로 가지는 값을 찾기 위해 사용합니다. 그리고 찾은 문자열 값을 현재 output 문자열과 합칩니다. 이 클로저는 0보다 큰 어떤 숫자를 문자 형식으로 나타내기 위해 사용될 수 있습니다. 클로저가 output 값으로 만들어진 새로운 배열이 map(_:) 메서드로부터 만들어집니다.   위의 예시에서의 trailing closure의 사용은 클로저가 사용된 function 바로 뒤에 클로저의 기능을 바로 요약해서 나타내줍니다. map(_:)의 괄호로 감쌀 필요가 없습니다.   만약 어떤 function이 여러개의 closures를 취한다면, 첫번째 trailing closure의 argument label은 생략하고 나머지 trailing closures의 argument label은 적어줍니다. 아래의 function은 photo gallery를 위해 사진을 가져옵니다.     func loadPicture(from server: Server, completion: (Picture) -&gt; Void, onFailure: () -&gt; Void) {       if let picture = download(\"photo.jpg\", from: server) {           completion(picture)       } else {           onFailure()       }   }  사진을 가져오기 위해 위의 function을 호출하면, 두개의 closures를 사용할 수 있다. 첫번째 클로저는 completion handler다. 이 클로저는 성공적인 사진 다운로드 후에 사진을 보여준다. 두번째 클로저는 error handler이다. 이 클로저는 사용자에게 에러를 보여준다.     loadPicture(from: someServer) { picture in       someView.currentPicture = picture   } onFailure: {       print(\"Couldn't download the next picture.\")   }        위의 예제에서 loadPicture(from:completion:onFailure:) function은 network task를 백그라운드로 보내고 그 network task가 완료되었을 때 두개의 completion handlers 중 하나를 호출합니다. 이런 방식으로 function을 작성하는 것은 성공적으로 다운로드 후 UI를 업데이트 하는 코드를 network failure를 다루는 코드로부터 분리시킵니다.   Capturing Values   클로저는 constants나 variables가 정의된 곳 안에서 constants나 variables를 capture할 수 있습니다. 그리고나서 해당 클로저의 바디 안에서 캡쳐한 해당 값을 조회하거나 수정할 수 있습니다. 심지어 해당 constants나 variables가 더이상 원래의 범위안에 존재하지 않더라도 클로저는 해당 값을 조회, 수정할 수 있습니다.   Swift에서 값을 capture할 수 있는 가장 간단한 형태의 클로저는 바로 다른 function의 바디부분에 작성된 ested function 입니다. nested function은 바깥쪽 function의 argument를 capture할 수 있고 바깥쪽 function 안에 정의된 constants나 variables를 capture할 수 있습니다.   아래 예제는 makeIncrementer이라는 function입니다. incrementer이라는 nested function을 담고 있습니다. 이 nested function인 incrementer()는 자신을 둘러싸고 있는 코드의 전후 관계로부터 runningTotal과 amount라는 두개의 값을 capture합니다. 이 두개의 값을 capturing 한 후, incrementer는 makeIncrementer로부터 클로저로 리턴됩니다. incrementer 클로저는 호출 될 때마다 runningTotal를 amount의 수만큼 증가시킵니다.     func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int {     var runningTotal = 0     func incrementer() -&gt; Int {         runningTotal += amount         return runningTotal     }     return incrementer   }  makeIncrementer function의 리턴 타입은 () -&gt; Int 입니다. 이것은 makeIncrementer function이 단순한 값이 아니라 function을 리턴한다는 것을 의미합니다. 이 예제에서는 리턴되는 function이 패러미터를 가지고 있지 않고 호출될 때마다 Int 타입의 값을 리턴합니다.      makeIncrementer(forIncrement:)는 runningTotal이라는 integer variable을 정의합니다. 이것은 리턴될 incrementer의 현재 runningTotal을 담을 것입니다. 초기값은 0입니다. makeIncrementer(forIncrement:) function은 하나의 Int 패러미터를 가지고 있습니다. 이 패러터는 forIncrement라는 argument lable을 가지고 있죠. amount는 패러미터의 이름입니다. 이 패러미터로 통과된 argument의 값은 리턴된 incrementer function이 호출될 때마다 runningTotal이 얼만큼 증가 될지를 조건으로 지정합니다. makeIncrementer function은 incrementer이라는 이름의 nested function을 정의합니다. 이 function이 실제로 수의 증가를 실행합니다. 이 function은 단순히 amount를 runningTotal에 더하고 그 결과를 리턴합니다.   이 nested function을 따로 떼어놓고 본다면, 이것은 조금 특이해 보일 수 있습니다.     func incrementer() -&gt; Int {     runningTotal += amount     retrun runningTotal   }   이 incrementer() function은 패러미터를 가지고 있지 않습니다. 그리고 runningTotal과 amount를 function의 바디부분 안에서 참조하고 있습니다. 이것은 감싸고 있는 function으로부터  runningTotal과 amount의 reference를 capturing 하고 그것을 function의 바디부분에서 사용는 방식으로 이용됩니다. Reference를 capturing하는 것은 makeIncrementer에 대한 호출이 끝났을 때도 runningTotal과 amount가 사라지지 않는 것을 보증합니다. 그리고 또 runningTotal이 incrementer function이 다음에 또 호출될 때도 이용 가능하도록 합니다.      아래는 function makeIncrementer의 사용 예시입니다.    let incrementByTen = makeIncrementer(forIncrement: 10)   이 예시는 incrementByTen이라는 constant를 설정하고 incrementer fuction을 참조합니다. 이 function은 호출될 때마다 10을 runningTotal에 더합니다. 아래는 여러번 이 function을 리턴했을 때의 코드입니다.     incrementByTen()   // 값 10을 리턴   incrementByTen()   // 값 20을 리턴   incrementByTen()   // 값 30을 리턴   두번째 incrementer을 생성한다면, 그것은 그것만의 분리된 새로운 runningTotal 변수의 reference를 가지게 됩니다.     let incrementBySeven = makeIncrementer(forIncrement: 7)   incrementBySeven()   // 값 7을 리턴   원래의 incrementer인 incrementByTen을 다시 호출하는 것은 계속해서 그것이 참조한 runningTotal의 값을 증가시킵니다. 그리고 incrementBySeven으로부터 capture된 값에는 영향을 미치지 않습니다.     incrementByTen()   // 값 40을 리턴   Closures Are Reference Types   위의 예시에서, incrementByTen과 incrementBySeven은 constants입니다. 하지만 이 constants가 나타내는 클로저는 여전히 캡쳐한 runningTotal 변수를 증가 시킬 수 있습니다. 이것이 functions와 closures가 reference type인 이유입니다.   function이나 closure를 constant나 variable에 할당할 때마다 실제로는 해당 constant와 variable을 function이나 closure의 reference가 되도록 설정하는 것입니다.      두개의 다른 contents나 variables에 하나의 클로저를 할당한다면, 두개 모두 똑같은 클로저를 나타내게 됩니다.     let alsoIncrementByTen = incrementByTen   alsoIncrementByTen()   // 50을 리턴    incrementByTen()   // 60을 리턴   위의 예시는 alsoIncrementByTen를 호출하는 것은 incrementByTen을 호출하는 것과 같다는 것을 보여줍니다. 두 개가 같은 클로저를 참조하고 있기 때문에 둘 다 같은 runningTotal을 증가시키고 리턴합니다.   Escaping Closures     var completionHandlers: [() -&gt; Void] = []   func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) {     completionHandlers.append(completionHandler)   }   someFunctionWithEscapingClosure(_:) function은 argument로 closure를 가집니다.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","Closures"],
        "url": "/til/closures/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Subscripts",
        "excerpt":"👩‍🌾 ..   Classes, structures, 그리고 enumerations는 subscripts를 정의할 수 있습니다. Subscripts는 collection이나 list 또는 sequence의 멤버 요소에 접근하는 쉬운 방법들입니다. 값을 설정하고 가져오기 위한 메서드 없이 subscripts를 사용하여 인덱스로 값을 설정하거나, 값을 가져옵니다. 예를 들어, someArray[index]로 Array instance의 요소에 접근할 수 있습니다. Dictionary instance의 요소에 접근하기 위해서는 someDictionary[key]를 이용합니다.   하나의 타입에 여러개의 subscripts를 정의할 수 있습니다. Subscript에 통과된 인덱스 값의 타입을 기준으로 그 중 적합한 subscript가 선택됩니다. Subscript는 1차원에 제약되지 않습니다. 커스텀 타입이 필요로 하는 여러개의 input 패러미터를 이용하여 subscript를 정의할 수 있습니다.   Subscript Syntax   Subscript는 하나 또는 여러개의 값을 instance의 이름 뒤 [] 안에 작성함으로써 인스턴스에 대한 정보를 가져오는 것을 가능하게 합니다. Subscript syntax는 instance method syntax 그리고 commputed property syntax와 비슷합니다. subscript keyword를 사용하고 하나 또는 여러개의 인풋 패러미터와 리턴 타입을 특정 지어 줍니다. (instance method와 같은 방법으로)    Instance method와는 다르게, subscript는 read-write 또는 read-only가 될 수 있습니다. Computed property에서와 마찬가지로 getter 그리고 setter에 의해 실행됩니다.     subscript(index: Int) -&gt; Int {     get {         // 적합한 subscript 값을 리턴     }     set(newValue) {         // 적합한 setting action 수행     }   }   newValue의 타입은 subscript의 리턴타입과 같습니다. Computed property에서처럼, setter의 (newValue)패러미터를 특정짓지 않을 수 있습니다. 만약 이렇게 특정짓지 않는다면 newValue라는 이름의 디폴트 패러미터가 제공됩니다.   read-only computed property처럼, get 키워드와 { } 를 제거하여 read-only subscript를 단순한 형태로 정의할 수 있습니다.     subscript(index: Int) -&gt; Int {         // 적합한 subscript 값을 리턴   }   아래는 read-only subscript의 구현 예시입니다. TimesTable stucture는 한 정수의 n-times-table을 나타냅니다.     struct TimesTable {       let multiplier: Int       subscript(index: Int) -&gt; Int {           return multiplier * index       }   }   let threeTimesTable = TimesTable(multiplier: 3)   print(\"six times three is \\(threeTimesTable[6])\")   // Prints \"six times three is 18\"   위의 예에서, TimesTable의 새 instance는 three-times-table을 나타내기 위해 생성되었습니다. 이것은 TimesTable structure의 생성자 multiplier패러미터에 값 3을 통과시킴으로써 이루어집니다.   threeTimesTable의 subscript를 호출함으로써 정보를 가져올 수 있습니다. (threeTimesTable[6])   Subscript Usage   “subscript”의 정확한 의미는 이것이 사용된 곳의 전후 관계에 달려있습니다. Subscripts는 보통 collection, list 또는 sequence의 요소에 접근하는 지름길(쉬운 방법)으로 사용됩니다.   예를 들어, Swift의 Dictionary type은 어떤 Dictionary instance에 저장된 값을 가져오거나, 값을 설정하기 위해 subscript를 사용합니다. 딕셔너리의 키 타입에 맞는 키를 subscript brackets안에 제공하고 딕셔너리의 값 자료형과 일치하는 값을 할당해줌으로써 키와 값을 설정할 수 있습니다.     var numberOfLegs = [\"Spider\": 8, \"ant\": 6, \"cat\": 4]   numberOfLegs[\"bird\"] = 2    ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","Subscripts"],
        "url": "/til/subscripts/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Functions",
        "excerpt":"⚙️  Functions는 특정 기능을 수행하는 완전한 코드 덩어리입니다. Functions는 이름을 가집니다. 보통은 어떤 일을 하는지 알 수 있는 이름을 지어줍니다. 그리고 필요할 때 그 이름을 사용해서 function을 호출하여 특정 기능을 수행할 수 있도록 합니다.   패러미터는 function의 호출을 단순화하기 위해서 기본값을 제공할 수 있습니다. 그리고 in-out 패러미터로써 인자를 통과시킬 수 있습니다.   스위프트의 모든 function은 type을 가지고 있습니다. function의 패러미터의 types와 리턴 type으로 이루어져 있습니다.     func greet(person: String) -&gt; String {     let greeting = \"Hello\" + person + \"!\"     return greeting   }     -(a hyphen)   &gt;(a right angle bracket)   을 이용해서 -&gt; 리턴 타입을 나타냅니다.     func greetAgain(person: String) -&gt; String {     return \"Hello again,\" + person + \"!\"   }  return 뒤에 바로 문자열을 주면 코드를 더 짧게 작성할 수 있습니다.   Function with Multiple Return Values   여러개의 값을 리턴하는 function을 위해 하나로 합쳐진 리턴 값으로써 tuple을 리턴 타입으로 사용할 수 있습니다.   아래의 예시는 minMax(array:)라는 function을 정의합니다. Int값을 가진 배열에서 가장 작은 수와 가장 큰 수를 찾아내는 function 입니다.     func minMax(array: [Int] -&gt; (min: Int, max: Int) {     var currentMin = array[0]     var currentMax = array[0]     for value in array[1..&lt;array.count] {       if value &lt; currentMin {           currentMin = value       } else if value &gt; currentMax {           currentMax = value       }     }     return (currentMin, currentMax)   }   위의 minMax(array:) function은 두개의 Int 값을 가지고 있는 tuple을 리턴합니다. 이 값들은 min, max라는 이름으로 labeled 되었고, 그렇기 때문에 function의 리턴 값에 접근이 필요할 때 이름으로 접근할 수 있습니다.   minMax(array:)의 바디는 두개의 변수 currentMin과 currentMax를 설정하는 것으로 시작합니다. 이것들은 배열의 첫번째 값을 초기값으로 가지고 있습니다. 그리고 function은 배열의 남은 요소들에 대해 반복해서 코드를 실행하며 각 요소가 currentMin보다 작은지, currentMax보다 큰지를 확인합니다. 그리고나서 가장 작은 수와 가장 큰 수를 가지고 있는 튜플을 리턴합니다.   튜플의 멤버 값이 이름을 가지고 있기 때문에 dot syntax를 사용하여 값에 접근하고 가장 작은 수와 큰 수를 가져올 수 있습니다.     let bounds = minMax(array: [8, -6, 2, 109, 3, 71])   print(\"min is \\(bounds.min) and max is \\(bounds.max)\")    // Prints \"min is -6 and max is 109\"   리턴되는 튜플 멤버의 이름은 function의 정의 과정에서 리턴 타입의 이름으로 이미 주었기 때문에 튜플이 function으로부터 리턴될 때는 이름을 줄 필요가 없습니다.   Funtion Argument Labels and Parameter Names   각각의 function 패러미터는 argument label과 parameter name을 가집니다. Argument label은 function을 호출할 때 사용됩니다. 각각의 argument는 function call의 코드 속에 argument label 뒤에 작성됩니다. 패러미터의 이름은 function을 구현할 때 사용됩니다. 기본적으로, 패러미터는 parameter name을 argument name으로 사용합니다.     func someFunction(firstParameterName: Int, secondParameterName: Int) {     // function의 바디부분에서 firstParameterName과 secondParameterName은 argument의 값을 나타냅니다.   }   someFunction(firstParameterName: 1, secondParameterName: 2)   Specifying Argument Labels   Argument name은 patameter name 앞에 작성합니다. (space로 띄어서 구분해 줍니다.)     func someFunction(argumentLabel parameter name: Int) {     // function의 바디부분에서 parameterName은 해당 패러미터에 통과되는 argument 값을 참조합니다.   }   아래의 예시는 greet(person:) function의 변형된 버전입니다. 사람의 이름과 고향을 패러미터로 통과시키고 인사말을 리턴합니다.     func greet(person: String, from hometown: String) -&gt; String {     return \"Hello \\(person)! Glad you visit from \\(hometown).\"   }   print(greet(person: \"Bill\", from: \"Cupertino\"))   // Prints \"Hello Bill! Glad you visit from Cupertino.\"   Omitting Argument Lables   만약, 패러미터에 argument label을 사용하고 싶지 않다면, underscore(_)를 argument name 대신 작성해줍니다.     func someFunction(_ firstParameterName: Int, secondParameterName: Int) {    }   someFunction(1, secondParameterName: 2)   Default Parameter Values   Function의 패러미터 타입 뒤에 값을 할당해줌으로써 패러미터의 기본값을  줄수 있습니다. 기본값이 주어진 패러미터는 function을 호출할 때 생략할 수 있습니다.     func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) {     // 이 function을 호출할 때 두번째 argument를 생략하면, 기본값인 12가 function의 바디에서 사용됩니다.   }   someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6)   // 위에서 parameterWithDefault 는 6   someFunction(parameterWithoutDefault: 4)   // 위에서 parameterWithDefault 는 12   기본값을 가지지 않은 패러미터를 가장 먼저 써줍니다. 주로 기본값이 없는 패러미터가 function의 의미에 더 중요한 역할을 하기 때문입니다. 기본값을 가지지 않은 패러미터를 먼저 첫번째로 둠으로써 같은 function이 호출되었을 때 생략된 패러미와 관계없이 function을 구별하기 쉽게 만들어 줍니다.   Variadic Parameters   Variadic parameter는 특정 타입의 0개 또는 더 많은 수의 값을 받습니다. Function이 호출될 때해당 패러미터를 가진 인풋값의 a varying number을 통과시킬 수 있다는 것을 나타내기 위해서 variadic parameter를 사용합니다. 패러미터의 타입 이름 뒤에 …(세개의 .)을 추가해줍니다.   Variadic parameter를 통해 들어온 값들은 function의 바디부분에서 배열로 사용가능합니다.    예를 들어, 아래 코드의 numbers라는 Double… 타입의 패러미터는 function의 바디부분에서 numbers라는 이름을 가진 [Double] 타입의 constant 배열로 사용되었습니다.   아래의 function arithmeticMean은 수의 평균을 구합니다. (수의 길이 상관 없음)     func arithmeticMean(_ numbers: Double...) -&gt; {       var total: Double = 0       for number in numbers {         total += number       }       return total / Double(numbers.count)   }   arithmeticMean(1, 2, 3, 4, 5)   // 3.0을 리턴합니다.   arithmeticMean(3, 8.25, 18.75)   // 10.0을 리턴합니다.   하나의 function은 여러개의 variadic parameters를 가질 수 있습니다. Variadic parameter 다음에 처음으로 오는 패러미터는 필수적으로 argument lable을 가져야합니다. Argument Lable은 어떤 arguments가 variadic 패러미터에 통과되었는지, 어떤 arguments가 variadic 패러미터 다음에 오는 패러미터에 통과되었는지를 명확히 구별할 수 있게 돕습니다.   In-Out Parameters   Function parameters는 기본적으로 constants입니다. Function 패러미터의 값을 function의 바디부분에서 변경하려고 시도하는 것은 컴파일 에러를 발생시킵니다. 이것은 패러미터의 값을 실수로 변경할 수 없다는 것을 의미합니다. 만약 function이 패러미터의 값을 수정하길 원한다면, 그리고 function의 호출이 끝난 이후에도 그 변경사항이 계속해서 유지되길 원한다면 해당 패러미터를 in-out 패러미터로 정의해야 합니다.   패러미터의 타입 앞에 inout 키워드를 추가해줌으로써 in-out 패러미터를 작성할 수 있습니다. In-out 패러미터는 function으로 통과되어 들어오고(passed in to the function), function으로부터 수정되고, 원래의 값을 교체하기 위해 밖으로 통과되어 나가는(back out of the function) 값을 가집니다.   In-out 패러미터의 argument로는 오직 variable만 통과시킬 수 있습니다. constants나 literal 값은 수정될 수 없기 때문에 argument로 통과시킬 수 없습니다. &amp;(ampersand)를 variable의 이름 앞에 적음으로써 in-out 패러미의 argument로 통과시킨다는 것을 알려줍니다.         N O T E       In-out 패러미터는 기본값을 가질 수 없습니다. 그리고 variadic 패러미터는 inout 키워드를 사용할 수 없습니다.            아래의 function swapTwoInts는 a와 b라는 in-out integer 패러미터를 가지고 있습니다.     func swapTwoInts(_ a: inout Int, _ b: inout Int) {       let temporaryA = a       a = b       b = temporaryA   }   swapTwoInts function은 단순히 b의 값을 a로 바꾸고, a의 값을 b로 바꿉니다. 이 function은 두 수의 교체를 temporaryA라는 temporary constant를 이용해서 수행합니다. a의 값을 temporaryA에 먼저 할당하고 - a에 b를 할당 - b에 a를 할당합니다.   두개의 Int 타입 variables의 값을 바꾸기 위해 swapTwoInts function을 호출할 수 있습니다. &amp;을 someInt와 anotherInt 앞에 붙여주었습니다.     var someInt = 3   var anotherInt = 107   swapTwoInts(&amp;someInt, &amp;anotherInt)   print(\"someInt is now \\(someInt), and anotherInt is now \\(anotherInt)\")   // \"someInt is now 107, and anotherInt is 3\"을 출력합니다.   위의 예시에서 두 variables someInt와 anotherInt는 function swapTwoInts의 바깥에서 정의되었음에도 function을 통해 원래의 값이 서로 교체되었습니다.         N O T E       In-out 패러미터는 function으로 부터 값을 리턴하는 것과는 다릅니다. 위의 swapTwoInts예시는 리턴 타입을 정의하지 않았고, 값을 리턴하지 않습니다. 하지만 여전히 someInt와 anotherInt의 값을 변경시킵니다. In-out 패러미터는 function의 바디 부분의 범위를 넘어서서 영향을 미칠 수 있는 또 다른 방법입니다.            Function Types   모든 function은 패러미터의 타입 + 리턴 타입으로 이루어진 특정한 function type을 가지고 있습니다.   예를 들면:    func addTwoInts(_ a: Int, _ b: Int) -&gt; Int {       return a + b   }   func multiplyTwoInts(_ a: Int, _ b: Int) -&gt; Int {       return a * b   }   위의 예는 두개의 단순한 계산을 수행하는 addTwoInts와 multiplyTwoInts라는 functions를 정의합니다. 이 functions는 각각 두개의 Int 값을 이용하여 계산 후 하나의 Int 값을 리턴합니다.   위 두 functions의 타입은 (Int, Int) -&gt; Int 입니다.     func printHelloWorld() {       print(\"hello, world\")   }   위 function은 타입은 () -&gt; Void이고, “패러미터를 가지고 있지 않고 Void를 리턴하는 function”이라고 합니다.   Using Function Types   Swift의 다른 타입처럼 function 타입을 사용합니다. 예를 들어, constant나 variable을 정의하고 function 타입을 지정한 뒤 적절한 function을 할당할 수 있습니다.     var mathFunction: (Int, Int) -&gt; Int = addTwoInts   addTwoInts function이 mathFunction과 같은 타입을 가지고 있기 때문에 Swift의 type-checker가 이 assignment를 수락합니다.     print(\"Result: \\(mathFunction(2, 3))\")   // \"Result: 5\" 를 출력합니다.   다른 타입들처럼, function을 constant나 variable에 할당할 때, Swift가 function type을 추측하도록 할 수 있습니다.     let anotherMathFunction = addTwonInts   Function Types as Parameter Types   (Int, Int) -&gt; Int와 같은 function type을 다른 function의 패러미터 타입으로 사용할 수 있습니다.   위에서 생성한 math functions의 결과를 출력하기 위한 예제입니다.     func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a; Int, _ b: Int) {        print(\"Result: \\(mathFunction(a, b))\")     }   printMathResult(addTwoInts, 3, 5)   // \"Result: 8\"을 출력합니다.   위의 예시는 printMathResult(_:_:_:)를 정의합니다. 세개의 패러미터를 가지고 있습니다. 첫번째 패러미터의 이름은 mathFunction이고 타입은 (Int, Int) -&gt; Int 입니다. 두번째 그리고 세번째 패러미터는 a와 b이고 Int 타입입니다. 이 둘은 주어진 math function의 input 값으로 사용됩니다.    ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","Functions"],
        "url": "/til/functions/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Enumerations",
        "excerpt":"enum  Enumeration은 연관된 값의 그룹을 위한 일반적인 type을 정의합니다. 그리고 그 값들을 코드안에서 type-safe한 방식으로 이용할 수 있도록 합니다.   Enumeration Syntax   enum 키워드로 enumeration의 작성을 시작합니다. 그리고 전체 definition을 { } 안에 작성합니다.     enum someEnumeration {     // enumeration의 definition   }   아래는 나침반의 네개의 점을 표현한 enumeration의 예입니다.     enum CompassPoint {       case north       case south       case east       case west   }   north, south, east, west와 같이 enumeration 안에 정의된 값들을 enumeration cases 라고 합니다. 새 enumeration cases를 작성할 때는 case 키워드로 시작합니다.   여러개의 cases는 한줄에 ,라고 분리해 작성할 수 있습니다.     enum Planet {     case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune   }   각각의 enumeration definition은 새로운 type을 정의합니다. Swift의 다른 type들처럼, 이름(CompassPoint, Planet과 같이)은 대문자로 시작합니다. 복수형보다는 단수형의 이름을 지어주어 명확히 읽히도록 합니다.     var directionToHead = CompassPoint.west   directionToHead의 타입은 CompassPoint의 값 중 하나와 함께 초기화될 때 추론됩니다. 일단 한번 directionToHead가 CompassPoint로써 선언되면 더 짧은 dot syntax로 다른 값을 설정할 수 있습니다. 이것은 코드를 더욱 더 잘 읽히도록 합니다.     directionToHead = .east   Matching Enumeration Values with a Switch statement     directionToHead = .south   switch directionToHead {   case .north:       print(\"Lots of planets have a north\")   case .south:       print(\"Watch out for penguins\")   case .east:       print(\"Where the sun rises\")   case .west:       print(\"Where the skies are blue\")   }   // Prints \"Watch out for penguins\"   위의 코드는 directionToHead의 값이 .north와 같을 경우, “Lots of planets have a north”를 출력, .south와 같을 경우 “Watch out for penguins”를..(나머지도 같 ) 출력하라는 것을 나타냅니다.   Switch statement가 enumeration의 cases를 다룰때는 빠지는 case가 없도록 해야 합니다. 만약 .west case가 생략되면 이 코드는 컴파일 되지 않을 것입니다.   모든 enumeration cases에 대해 case를 제공하는 것이 적합하지 않을 때는 명시되지 않은 cases를 커버하기 위해 default case를 사용할 수 있습니다.     let somePlanet = Planet.earth   switch somePlanet {   case .earth:       print(\"Mostly harmless\")   default:       print(\"Not a safe place for humans\")   }   // \"Mostly harmless\"를 출력합니다.   Iterating over Enumeration Cases   어떤 enumerations를 위해서는, 모든 cases의 collention을 가지는 것이 유용하게 사용됩니다. Enumeration의 이름 뒤에 : CaseIterable를 작성함으로써 이것이 가능해집니다. Swift는 enumeration type의 allCases property를 이용하여 모든 cases의 collention을 보여줍니다.     enum Beverage: CaseIterable {       case coffee, tea, juice   }   let numberOfChoices = Beverage.allCases.count   print(\"\\(numberOfChoices) beverages available\")   // \"3 beverages available\"을 출력   위의 예시에서는, Beverage enumeration의 모든 cases를 담고있는 collection에 접근하기 위해 Beverage.allCases라고 작성하였습니다. 다른 종류의 collection처럼 allCases를 사용할 수 있습니다. 이때 collection의 요소는 enumeration type의 인스턴스입니다. 이 경우에는 Beverage values이죠. 위의 예시에서는 몇개의 cases가 있는지 수를 세고, 아래의 예시에는 모든 cases에 대해 for-in loop를 반복적으로 실행합니다.     for beverage in Beverage.allCases {       print(beverage)   }   // coffee   // tea   // juice   위의 예시에서 사용된 syntax는 모두 enumeration이 CaseIterable protocol을 따르고 있는지 확인합니다.   Associated Values   위의 예시들은 enumeration의 cases가 어떻게 스스로의 권리를 가지고 있는 정의된 값인지를 보여주었습니다. Planet.earth에 constant나 variable을 설정할 수 있고, 이 값을 나중에 확인할 수 있습니다. 가끔씩 다른 타입의 값을 이 cases 값의 옆에 담을 수 있는 것이 유용할 수 있습니다. 이 추가적인 정보를 associated value라고 합니다. 이것은 case를 사용할 때마다 달라집니다.   주어진 타입의 associated values를 담기 위해 Swift의 enumeration을 정의할 수 있습니다. 필요하다면 각각의 case마다 다른 타입의 값을 줄 수 있습니다.   예를 들어, 재고 관리 시스템이 두 종류의 바코드를 이용해서 상품을 기록한다고 상상해 봅시다. 어떤 상품들에는 0부터 9까지의 수를 이용하는 UPC 포맷의 1D 바코드가 붙어있습니다. 다른 상품들에는 ISO 8859-1문자를 사용하고 길이가 2,953만큼 긴 문자를 암호화 할 수 있는 OR 코드 포맷의 2D 바코드가 붙어있습니다.   UPC 바코드를 사용하는 재고 관리 시스템은 4개의 정수를 가지고 있는 tuple을 사용하는 것이 편리하고, QR 코드 바코드는 모든 길이의 문자열이 편리할 것 입니다.   Swift에서 위의 바코드를 표현한 enumeration은 아래처럼 작성될 것입니다.     enum Barcode {       case upc(Int, Int, Int, Int)       case qrCode(String)   }   위의 definition은 어떤 Int나 String값도 실제로 제공하지 않습니다. 단지 Barcode constant 또는 variable이 담을 수 있는 associated values의 타입을 제공할 뿐입니다.     var productBarcode = Barcode.upc(8, 85909, 51226, 3)   둘 중 하나의 type을 이용해서 새 바코드를 생성할 수 있습니다. 위의 예시에서는 productBarcode라는 새 variable이 생성 후 Barcode.upc의 값을 (8, 85909, 51226, 3)이라는 associated tuple value와 함께 할당했습니다.     productBarcode = .qrCode(\"ABCDEFGHIJKLMNOP\")  같은 상품에 다른 타입의 바코드를 할당할 수 있습니다. 이때, 원래의 Barcode.upc 와 integer 값은 새로운 Barcode.qrCode와 string 값으로 교체됩니다.     switch productBarcode {   case .upc(let numberSystem, let manufacturer, let product, let check):       print(\"UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check).\")   case .qrCode(let productCode):       print(\"QR code: \\(productCode).\")   }   // \"QR code: ABCDEFGHIJKLMNOP\"를 출력   만약 모든 associated values가 constant 또는 variables로 똑같이 받아지는 경우에는 하나의 var 또는 let annotation을 case 이름 전에 작성할 수 있습니다.     switch productBarcode {   case let .upc(numberSystem, manufacturer, product, check):   //...   }   Raw Values   Associated values의 대안으로, raw values라는 default 값으로 enumeration의 cases를 미리 채울 수 있습니다. (모두 같은 타입)   raw ASCII 값을 가지고 있는 enumeration cases:    enum ASCIIControlCharacter: Character {       case tab = \"\\t\"       case lineFeed = \"\\n\"       case carriageReturn = \"\\r\"   }  위의 ASCIIControlCharacter enumeration의 raw values의 타입은 Character로 정의 되었습니다.   Raw values는 strings, characters, 또는 integer, floating-point number 타입을 가질 수 있습니다. 각 raw value는 유일한 값을 가져야 합니다.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","Enumerations"],
        "url": "/til/enumerations/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Generics",
        "excerpt":"📂 Language Guide / Generics  아래 모든 정보의 출처는 apple developer 공식 페이지이며 개인의 학습 용도로만 사용되었음을 밝힙니다.   ☑️   Generic code는 다루기 쉽고 재사용 가능한 functions와 types를 작성할 수 있도록 합니다. 명확하고 추상화된 방식으로 의도를 분명히하는 코드를 작성할 수 있습니다.   Generics는 Swift의 가장 강력한 기능 중 하나입니다. 많은 Swift의 기본 라이브러리들이 generic code로 만들어졌습니다. Swift의 Array와 Dictionary types는 둘 다 generic collections입니다. Int 값을 담고 있는 배열을 생성할 수 있고, 또는 String 값을 담고 있는 배열을 생성할 수 있습니다. 또는 Swift에서 생성될 수 있는 모든 type으로 배열을 생성할 수 있습니다. Dictionary도 마찬가지입니다. 어떤 타입이 사용될 수 있을지에 대한 제한이 없습니다.   The Problem That Generics Solve   아래는 swapTwoInts(_:_:)라는 standard, nongeneric function입니다. 두개의 Int값을 서로 바꾸는 기능을 합니다.     func swapTwoInts(_ a: inout Int, _ b: inout Int) {       let temporaryA = a       a = b       b = temporaryA   }    var someInt = 3   var anotherInt = 107   swapTwoInts(&amp;someInt, &amp;anotherInt)   print(\"someInt is now \\(someInt), and anotherInt is now \\(anotherInt)\")   // \"someInt is now 107, and anotherInt is now 3\"를 출력   swapTwoInts(_:_:) function은 유용하게 사용될 수 있지만, Int 값만을 사용할 수 있습니다. 만약 두개의 문자열 값을 교환하고 싶다면, 또는 두개의 Double 값을 교환하고 싶다면 아래와 같은 functions를 더 작성해야 합니다.     func swapTwoStrings(_ a: inout String, _ b: inout String) {       let temporaryA = a       a = b       b = temporaryA   }    func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {       let temporaryA = a       a = b       b = temporaryA   }   function의 바디부분은 같습니다. 다른 점은 function이 받아들이는 값의 타입이 다르다는 것입니다.   두개의 값이 어떤 타입이든 교환할 수 있는 하나의 function을 작성하는 것이 훨씬 더 유용할 것 입니다. Generic code는 그런 종류의 function을 작성할 수 있도록 합니다.         N O T E       위 세개의 function 모두에서, 만약 a와 b의 타입이 다르다면 값을 교환할 수 없습니다. Swift는 type-safe 언어이기 때문에 다른 타입의 변수가 서로 값을 교환하는 것이 불가능합니다. 만약 이런 시도가 있다면 compile-time 에러를 발생시킵니다.       Generic Functions   Generic function은 어떤 타입과도 함께 작동될 수 있습니다. 아래는 generic function 버전의 swapTwoInts(_:_:) function 입니다. 이름은 swapTwoValues(_:_:)입니다.     func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) {       let temporaryA = a       a = b       b = temporaryA   }   swapTwoValues function의 바디 부분은 swapTwoInts function의 바디부분과 동일합니다. swapTwoValues function의 첫번째 줄이 조금 다릅니다.     func swapTwoInts(_ a: Int, _ b: Int)   func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T)   Generic 버전의 function은 placeholder type name (위의 예에서는 T)을 사용합니다. 이 placeholder type name은 T가 무엇이 되어야 하는지에 대해서는 알려주지 않습니다. 하지만 T가 어떤 타입이던 a와 b가 같은 타입이 되어야 한다는 것을 알려줍니다. 실제 사용되는 타입은 이 function이 호출될 때마다 정해집니다.   Generic function과 nongeneric function의 또 다른 차이점은 generic function의 이름뒤에는 placeholder type이 &lt;&gt;(angle brackets)사이에 온다는 것입니다. &lt;&gt;는 Swift에게 placeholder type name이 무엇인지 알려줍니다.   swapTwoInts를 호출했던 방식처럼 swapTwoValues를 호출할 수 있습니다. 하지만 어떤 타입의 값이든 통과시킬 수 있게 되었습니다. (두 개의 값이 서로 같은 타입을 가지고 있을 때) 통과된 값의 타입에 따라 T의 타입이 추측됩니다.   아래 두가지 예시에서 T는 각각 Int와 String타입으로 추측되었습니다.     var someInt = 3   var anotherInt = 107   swapTwoValues(&amp;someInt, &amp;anotherInt)   // someInt는 107, anotherInt는 3이 됩니다.    var someString = \"hello\"   var anotherString = \"world\"   swapTwoValues(&amp;someString, &amp;anotherString)   // someString은 \"world\", anotherString은 \"hello\"가 됩니다.         N O T E       지금까지 사용한 swapTwoValues function은 Swift의 standard library에 있는 swap이라는 generic function에서 아이디어를 얻어 만들어졌습니다. 만약 위와 같은 function을 사용하고 싶다면 swap(_:\\_:)를 사용할 수 있습니다.      Type Parameters   위의 예시에서 사용한 swapTwoValues(_:_:)의 placeholder type T는 type parameter의 한 예입니다. Type parameter는 placeholder type의 이름을 명시합니다. function의 이름 뒤에 바로 작성됩니다. &lt;&gt; brackets를 사용하여 작성합니다.   Type parameter를 명시하면, 그 이름을 function의 패러미터 타입 또는 리턴 타입으로 사용할 수 있고 function의 바디 부분에서 type annotation으로 사용할 수 있습니다. Function을 호출할 때 type parameter는 실제 사용되는 타입으로 교환됩니다.   &lt; &gt; 사이에 ,로 구분하여 여러개의 typ parameters name을 작성할 수 있습니다.   Naming Type Parameters   많은 경우에, type parameters의 이름은 function 또는 generic type과 type parameter의 관계에 근거하여 짓습니다. (Dictionary&lt;key, Value&gt;나 Array 처럼)     하지만 만약 특별한 관계를 가지고 있지 않다면 주로 T, U, V와 같은 알파벳 하나를 이름으로 사용합니다.         N O T E       Type parameters의 이름을 지을때는 T, MyTypeParameter와 같이 대문자 카멜케이스를 이용하여 해당 placeholder가 값이 아니라 type을 위한 것이라고 알려줍니다.      Generic Types   Swift에서는 우리만의 generic types를 정의할 수 있습니다. 이것은 Array, Dictionary와 비슷하게 어떤 타입과도 함께 작동될 수 있는 custom classes, structures, enumerations입니다.   이 섹션에서는 Stack이라는 generic collection type을 작성하는 방법에 대해 알아봅니다. Stack은 array와 비슷한, 순서가 있는 값의 집합입니다. 하지만 Swift의 Array type보다 좀 더 엄격한 작동 구조를 가지고 있습니다. Array는 배열 속 어디에서든 요소를 추가하거나 삭제할 수 있습니다. 하지만 stack에서는 collection의 가장 끝부분에서만 추가, 삭제할 수 있습니다.         N O T E       Stack이라는 컨셉은 UINavigationController 클래스로부터 사용됩니다. 클래스의 navigation hierarchy안에서 view controller를 모델링하기 위해 사용됩니다. 네이게이션 stack에 view controller를 추가하기 위해 UINavigationController 클래스와 pushViewControoler(_:animated:) 메서드를 호출합니다. 그리고 네비게이션 스택에서 view controller를 삭제하기 위해 popViewControllerAnimated(\\_:)를 호출합니다. 엄격한 last in, first out 접근으로 collection을 관리해야 한다면, stack은 유용한 collection model이 될 것입니다.       아래는 nongeneric 버전의 stack을 작성한 것입니다. 이 예에서는 Int 값의 stack을 작성했습니다.     struct IntStack {       var items: [Int] = []       mutating func push(_ item: Int) {           items.append(item)       }       mutating func pop() -&gt; Int {           return items.removeLast()       }   }   위의 structure는 items라는 Array property를 사용하여 스택안의 값을 저장합니다. Stack은 push와 pop이라는 두개의 메서드를 제공합니다. 이 메서드들은 structure의 items 배열을 변경하기 때문에 mutating이라고 표시되었습니다.   위의 IntStack 타입은 오직 Int 값과만 사용할 수 있기 때문에 어떤 타입의 값이던 사용할 수 있는 generic Stack structure을 정의한다면 훨씬 더 유용하게 사용할 수 있을 것입니다.   아래는 Generic version의 같은 코드 입니다.     struct Stack&lt;Element&gt; {       var itmes: [Element] = []       mutating func push(_ item: Element) {           items.append(item)       }       mutating func pop() -&gt; Element {           return items.removeLast()       }   }   위에서 작성한 Stack은 generic type이기 때문에 Array와 Dictionary처럼 Swift에서 사용 가능한 모든 type의 stack을 생성하기 위해 사용될 수 있습니다.   사용할 타입을 &lt; &gt; 사이에 작성해주어 Stack의 새 인스턴스를 생성할 수 있습니다.     var stackOfStrings = Stack&lt;String&gt;()   stackOfStrings.push(\"uno\")   stackOfStrings.push(\"dos\")   stackOfStrings.push(\"tres\")   stackOfStrings.push(\"cuatro\")   // stack은 4개의 strings를 가집니다.   값을 poping 하면 가장 위에 있는 값(마지막으로 추가된 값)을 stack에서 삭제하고 그 값을 리턴합니다.     var fromTheTop = stackOfStrings.pop()   // fromTheTop은 \"cuatro\"와 같습니다. 그리고 stackOfStrings는 3개의 strings를 갖게 됩니다.   Extending a Generic Type   Generic type을 확장할 때 type parameter의 목록을 extension의 정의 부분에 작성하지 않고 extension의 바디 부분에서 type parameters를 원래의 type parameter name으로 사용할 수 있습니다.   아래의 예시는 generic Stack type을 확장시킵니다. read-only property인 topItem을 추가하여 삭제하지 않고 맨 위에 있는 item을 리턴합니다.     extension Stack {       var topItem: Element? {         return items.isEmpty ? nil : items[items.count - 1]       }   }   topItem property는 Element 타입의 옵셔널 값을 리턴합니다. Stack이 비어있다면 nil 값을 리턴하고, 비어있지 않다면 items 배열의 맨 위에 있는 값을 리턴합니다.     if let topItem = stackOfStrings.topItem {       print(\"The top item on the stack is \\(topItem).\")   }   // \"The top item on the stack is tres\"를 출력합니다.   Type Constraints   Type Constraint Syntax   하나의 클래스 또는 프로토콜 constraint를 type parameter name의 뒤에 놓아주면 type constraint를 작성할 수 있습니다. ,으로 분리하고 type parameter list의 한 부분으로 작성합니다.     func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {       // 바디 부분   }   위의 작성한 가상의 function은 두개의 type parameters를 가지고 있습니다. 첫번째 type parameter인 T는 SomeClass의 subclass가 되어야하는 type constraint를 가지고 있습니다. 두번째 type parameter U는 SomeProtocol을 따라야 한다는 type constraint를 가집니다.   Type Constraint in Action   아래는 nongeneric function인 findIndex(ofString:in:)입니다. String 값과 String 값을 가지고 있는 배열이 주어집니다. findIndex(ofString:in:) function은 배열안에서 처음으로 일치하는 값의 index가 될 옵셔널 Int 값을 리턴합니다. 만약 일치하는 값이 없다면 nil을 리턴합니다.     func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? {       for (index, value) in array.enumerated() {         if value == valueToFind {             return index         }       }       return nil   }  findIndex(ofString:in:)는 String 타입의 배열에서 어떤 string 값을 찾을 때 사용될 수 있습니다.     let strings = [\"cat\", \"dog\", \"llama\", \"parakeet\", \"terrapin\"]   if let foundIndex = findIndex(ofString: \"llama\", in: strings) {       print(\"The index of llama is \\(foundIndex)\")   }   // \"The index of llama is 2\"를 출력합니다.   위에서 index값을 찾기 위해 사용된 원리는 String 타입외의 다른 타입들의 값의 index를 찾을 때도 유용하게 쓰일 수 있습니다. String 타입이 언급된 모든 부분을 T로 바꾸어 generic function을 작성할 수 있습니다.   아래는 예상되는 generic 버전의 findIndex(of:in:) function입니다. 하지만 아래의 function은 compile되지 않습니다.     func findIndex&lt;T&gt;(of valueToFind: T, in array: [T]) -&gt; Int? {       for (index, value) in array.enumerated() {         if value == valueToFind {             return index         }       }       return nil   }   위의 function이 컴파일되지 않는 이유는 “if value == valueToFind” 부분에 있습니다. 모든 Type의 값이 == 를 이용하여 비교될 수 없기 때문입니다. 만약 우리가 복잡한 데이터 모델을 위해 커스텀 class, structure을 생성했을 경우 Swift는 해당 class나 structure가 == 를 사용했을 때 결과를 추측하지 못하게 됩니다.   Swift의 standard library는 Equatable이라는 프로토콜을 가지고 있습니다. Equatable을 따르는 type은 ==(equal to operator)와 !=(not equal to)을 사용하여 해당 type의 두 값을 비교할 수 있게 됩니다. 모든 Swift standard type은 Equatable를 따릅니다.   Equatable한 타입은 안전하게 foundIndex(of:in:) function과 함께 사용될 수 있습니다.     func findIndex&lt;T: Equatable&gt;(of valueToFind: T, in array: [T]) -&gt; Int? {     for (index, value) in array.enumerated() {       if valueToFind == value {         return index       }     }     return nil   }  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","Generics"],
        "url": "/til/generics/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Develop in Swift Fundamentals",
        "excerpt":"📂 Develop in Swift Fundamentals  아래 모든 정보의 출처는 Develop in Swift Fundamentals이며 개인의 학습 용도로만 사용되었음을 밝힙니다.   Initializers   모든 structures는 적어도 하나의 initializer를 포함하고 있습니다. Initializer는 어떤 한 type의 새 인스턴스를 리턴하는 function과 유사합니다. 자주 사용되는 많은 types이 argument가 없는 initializer를 가지고 있습니다. 바로 init()입니다.   init() initializer로 생성된 인스턴스들은 기본값을 가집니다.     var string = String.init()  // 기본값 -&gt; \"\"   var int = Int.init()        // 기본값 -&gt; 0   var bool = Bool.init()      // 기본값 -&gt; false   위의 initializer를 아래와 같은 방법으로 더 간단히 작성할 수 있습니다.     var string = String()  // 기본값 -&gt; \"\"   var int = Int()        // 기본값 -&gt; 0   var bool = Bool()      // 기본값 -&gt; false   Default Values   새로운 인스턴스를 생성할 때, Swift는 해당 type의 모든 properties의 값을 요구합니다.   첫번째 방법으로는, Type을 정의할 때 기본값을 줄 수 있습니다. 인스턴스들이 생성될 때 이 값을 이용하게 됩니다. 이 방법은 일정한 기본 값을 가지는 object를 정의할 때 유용하게 사용됩니다.   모든 instance properties에 기본값을 설정해주면, Swift 컴파일러가 자동으로 기본 생성자를 생성합니다.   property의 기본값을 이용해서 커스텀 type의 모든 인스턴스에 공통된 기본적인 상태를 설정할 수 있습니다.     struct Odometer {     var count: Int = 0   }    let odometer = Odometer()   print(odometer.count)   // 기본값으로 주어진 0을 출력합니다.   // 기본 생성자로 생성한 Odometer type의 모든 인스턴스의 count는 기본값 0 가집니다.   Memberwise Initializer   만약 새로운 structure를 정의할 때 initializer를 선언하지 않으면, Swift는 memberwise initializer라는 특별한 initializer를 생성합니다. 이것을 이용하여 생성되는 인스턴스를 위해 property에 값을 설정할 수 있습니다.     let odometer = Odometer(count: 27000)   print(odometer.count)   // 27000 을 출력합니다.   생성되는 각 인스턴스에 기대하는 기본적인 상태가 없을 때 사용하기 좋은 방법입니다.     struct Person {     var name: String   }   위의 예시처럼 name이라는 속성을 가지고 있는 structure Person이 있다면, 특정 이름으로 기본값을 설정할 수 없겠지요.     struct BankAccount {     var accountNumner: Int     var balance: Double = 0   }    let newAccount = BankAccount(accountNumner: 123)   var tranfferredAccount = BankAccount(accountNumner: 456, balance: 1200)   위의 예시에서는, 어떤 속성은 기본값을 가지고 또 다른 어떤 속성은 기본값을 가지지 않습니다. 새 인스턴스를 생성시, 기본값이 없는 속성만 패러미터로 작성해줍니다.   Custom Initializers     struct Temperature {     var celsius: Double      // memberwise initializer     init(celsius: Double) {       self.celsius = celsius     }      // custom initializer     init(fahrenheit: Double) {       self.celsius = (fahrenheit - 32) / 1.8     }   }    let currentTemperature = Temperature(celsius: 18.5)   let boiling = Temperature(fahrenheit: 212.0)    print(currentTemperature.celsius) // 18.5 출력   print(boiling.celsius)            // 100.0 출력   위의 예시에서 custom initializer인 init(fahrenheit: Double)는 패러미터로 전달 받은 값으로 계산을 수행하고 결과값을 celsius property에 할당합니다.   Custom initializer를 생성시 Swift가 기본 생성자와 memberwise initializer를 자동으로 생성해주지 않기 때문에 위의 예시처럼 직접 작성해 주어야 합니다.   원한다면, 여러개의 Custom initializer를 작성할 수 있습니다.   Instance Methods   Instance Methods는 특정 타입의 인스턴스에 호출될 수 있는 functions입니다. Instance Methods는 structure의 속성에 접근하고 수정할 방법을 제공합니다. 그리고 해당 인스턴스의 목적과 관련된 기능을 추가합니다.   Type을 정의할 때 function을 추가해줌으로써 instance methods를 추가할 수 있습니다. 그 후 해당 타입의 인스턴스에 추가해주었던 function을 호출할 수 있습니다.     struct Size {     var width: Double     var height: Double      func area() -&gt; Double {       width * height     }   }    let someSize = Size(width: 10.0, height: 5.5) // 인스턴스 생성   let area = someSize.area() // 55.0 이라는 값이 area에 할당됨.   ‘Size’ structure를 정의할 때 function ‘area’를 작성해주고, Size의 인스턴스인 ‘someSize’를 생성 후 instance method인 area()를 호출해주었습니다.   someSize 인스턴스의 타입은 Size이고, width와 height는 속성(properties)입니다.    area()는 Size의 모든 인스턴스에서 호출될 수 있는 instance method입니다.   Mutating methods   때때로, 속성의 값을 변경하는 function을 작성해야할 수 있습니다. 이때는 mutating 키워드를 사용합니다.     struct Odometer {     var count:[Int] = 0        mutating func increment() {       count += 1     }      mutating func increment(by amount: Int) {       count += amount     }      mutating func reset() {       count = 0     }   }    var odometer = Odometer() // count가 기본값 0   odometer.increment()   odometer.increment(by: 15)   odometer.reset()   Self   self 는 타입의 현재 인스턴스를 나타냅니다. 인스턴스 메서드나 computed property 안에서 사용됩니다.     struct Car {     var color: Color      var description: String {       return \"This is a \\(self.color) car.\"     }   }   생성자가 속성의 이름과 같은 이름의 패러미터를 가지고 있을 때 self를 사용합니다.     struct Temperature {     var celsius: Double      init(celsius: Double) {       self.celsius = celsius     }   }   Inheritance   Structures와 Classes의 가장 큰 차이점은 classes가 계층적인 관계를 가질 수 있다는 것입니다. 모든 클래스는 parent 그리고 child 클래스를 가질 수 있습니다. Parent 클래스는 superclass, child 클래스는 subclass라고 합니다.   가족 관계에서처럼, subclasses는 superclasses로부터 속성(properties)과 메서드를 상속받습니다.   Defining a Base Class   Base classes는 parent 클래스를 가지지 않는 클래스입니다.     class Vehicle {       var currentSpeed = 0.0        var description: String {           \"traveling at \\(currentSpeed) miles per hour\"       }        func makeNoise() {           // do nothing       }   }    let someVehicle = Vehicle()   print(\"Vehicle: \\(someVehicle.description)\")   // Vehicle: traveling at \\(currentSpeed) miles per hour 을 출력   위의 Vehicle 클래스는 기본값 0.0을 가진 currentSpeed라는 속성과 description 이라는 computed variable, 그리고 makeNoise()라는 메서드를 가지고 있습니다. 이 메서드는 Vehicle 인스턴스에서는 아무것도 수행하지 않지만 subclass에서 커스터 마이징 후 사용될 것입니다.   Vehicle 클래스는 속성과 메서드와 같은 아주 일반적인 특성들을 가지고 있습니다. 이 클래스 자체로는 그다지 유용하게 쓰이지 못할 수 있지만 다른 더 특정한 type을 생성하는 것을 더 쉽게 만들어 줄 것입니다.   Create a SubClass   Subclassing은 기존의 존재하는 클래스를 기초로 새로운 클래스를 생성하는 것을 말합니다. Subclasses는 superclass로부터 속성과 메서드를 상속받고 그것들을 개선하거나 더 구체적으로 만들 수 있습니다. 새 속성과 메서드를 subclass에 추가하는 것도 가능합니다.   아래는 SomeSuperclass로부터 상속받는 새 type인 subclass SomeSubclass를 정의하는 방법입니다.     class SomeSubclass: SomeSuperclass {       // subclass 정의   }   아래는 superclass인 Vehicle을 기초로 생성된 subclass Bicycle 입니다.     class Bicycle: Vehicle {       var hasBasket = false   }   Bicycle 클래스는 Vehicle 클래스의 속성 currentSpeed와 description, makeNoise() 메서드를 상속 받습니다.   상속 받은 속성과 메서드 뿐 아니라 새로운 boolean property인 hasBasket을 정의합니다.   Bicycle의 인스턴스에 currentSpeed를 업데이트 할 수 있습니다.     let bicycle = Bicycle()   bicycle.currentSpeed = 15.0   print(\"Bicycle: \\(bicycle.description)\")   // Bicycle: traveling at 15.0 miles per hour를 출력   Subclass도 subclass를 가질 수 있습니다. 아래의 예시는 두명이 탑승할 수 있는 TandemBike를 표현하고 있습니다.     class Tandem: Bicycle {       var currentNumberOfPassenger = 0   }   Tandem은 Bicycle의 모든 속성과 메서드를 상속 받습니다. Tandem 서브 클래스는 또한 기본값 0을 가진 currentNumberOfPassenger라는 새로운 속성을 추가합니다.   Tandem의 인스턴스는 상속 받은 모든 속성과 메서드에 대한 접근 권한을 가집니다.     let tandem = Tandem()    tandem.hasBasket = true   tandem.currentSpeed = 22.0   tandem.currentNumberOfPassenger = 2    print(\"Tandem: \\(tandem.description)\")   // \"Tandem: traveling at 22.0 miles per hour\" 을 출력합니다.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","UIKit"],
        "url": "/til/fundamentals/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "LeetCode: Swift",
        "excerpt":"🗂 ..  LeetCode 문제를 풀어보며 사용되는 메서드나 풀이 방식을 정리합니다.   hasPrefix(_:)     let arr = [\"playground\", \"plum\", \"plow\"]    var prefix = arr[0]    for element in arr {       while !element.hasPrefix(prefix) {           prefix = String(prefix.dropLast())       }   }    print(prefix)   // \"pl\"을 출력함.  패러미터로 전달된 String 값이 포함되어 있다면 true를 반환, 포함되어 있지 않다면 false를 반환합니다.     element가 “plum”일때 길이가 더 긴 문자열 “playground”를 prefix로 통과시켜도 문제가 없음을 확인.   띄어쓰기 되어있지 않은 문자열에도 사용 가능.   removeLast()     var arr = [\"a\", \"b\"]    let resultValue = arr.removeLast()    print(resultValue)   // 마지막 요소인 b를 출력함   removeLast() 메서드는 제거한 마지막 값을 리턴합니다.     var s = \"abcde\"    if s.removeLast() == \"e\" {       print(s)       // \"abcd\"를 출력   }   위의 예시처럼 removeLast() 메서드가 조건문에서 사용되었기 때문에 조건문 밖에 있는 원래의 문자열에는 영향을 미치지 않을거라고 생각했는데, if statement의 조건 부분에서  removeLast()를 사용하면 원래의 문자열의 마지막 요소는 사라짐.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","LeetCode"],
        "url": "/til/leetcode/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "앱 출시 프로젝트 로그",
        "excerpt":"📲 앱 출시 스터디 진행 중.   ?      시간 데이터도 필요할까?   다크 모드에서 searchTextField안의 placeholder와 text가 안보이는 문제   search UITextField 옆에 cancel이나 x 버튼   Accessibility (VoiceOver 등,,) 사용할지   Add a Collection View Controller   View Controller를 storyboard에 추가   View Controller는 data models와 views 사이에서 다리와 같은 역할      View hierarchy를 관리   View에 컨텐트를 업데이트   UI에 일어나는 이벤트에 반응      Main 스토리보드에 View Controller Scene 삭제     - List를 화면에 보여줄 수 있는 view controller로 교체   라이브러리에서 Collection View Controller를 드래그하여 생성   데이터 모델      데이터 모델 생성     - 각 식재료 아이템이 가질 데이터의 샘플 작성     - 날짜 관련 데이터 다루기가 어려워 일단 list 형태를 먼저 만들어 보기로 함   Configure the Collection as a list   Compositional layout을 이용하여 콜렉션 뷰의 나타나는 모습을 설계    Compositional layout은 세가지의 컴포넌트를 이용함      - Section     - Group     - Item   Search text field 코드     //   //  ViewController.swift   //  cingcing   //   //  Created on 2022/05/06.   //    import UIKit    class ViewController: UIViewController, UITextFieldDelegate {         @IBOutlet weak var searchTextField: UITextField!         override func viewDidLoad() {           super.viewDidLoad()            // self = 현재 class           searchTextField.delegate = self       }        @IBAction func searchPressed(_ sender: UIButton) {           // return 후 키보드 사라지게 하기           searchTextField.endEditing(true)           print(searchTextField.text!)       }        func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool {           searchTextField.endEditing(true)           print(searchTextField.text!)           return true       }        func textFieldShouldEndEditing(_ textField: UITextField) -&gt; Bool {           if textField.text != \"\" {               return true           } else {               textField.placeholder = \"검색어를 입력하세요.\"               return false           }       }        func textFieldDidEndEditing(_ textField: UITextField) {           searchTextField.text = \"\"       }        // 여기까지 search text field 와 검색 버튼   }   UICollectionViewController      View Controller의 이름을 변경   Superclass를 UICollectionViewController로 변경   listLayout() function 작성   콜렉션 뷰 &gt; 콜렉션 레이아웃 &gt; 리스트 레이아웃   Configure the Data Source   Computational layout 이용해서 콜렉션 뷰 안에 리스트 섹션 생성 완료.   Collection view에 셀을 등록하고 content configuration을 사용하여 셀의  appearance를 정의 후 데이타 소스를 셀의 연결하기   UICollectionViewDiffableDataSource&lt;Int, String&gt; 타입을 이용하여 dataSource 생성   Apply a snapshot   스냅샷을 이용하여 데이터의 변경 사항을 관리      스냅샷을 생성   원하는 상태의 데이터를 스냅샷에 작성되도록 함   UI에 스냅샷을 적용   Diffable data source 이용 -&gt; snapshot을 apply -&gt; 변경된 데이터로 UI 업데이트   Displaying Cell Info   유통기한 날짜를 입력 받고, 그것을 이용해 D-day 카운트 다운 표시를 일(day) 수로 표시하는 방법을 찾아야 함.     if Locale.current.calendar.isDateInToday(self) {         } else {         }  해당 date 값이 오늘 날짜라면 휴지통 아이콘 나타나게 할 때 사용할 수 있을 것 같음     import Foundation    extension Date {       // computed property       var dayAndTimeText: String {           // formatted(date:time:) -&gt; date 값을 문자 형태로           let timeText = formatted(date: .omitted, time: .shortened)           if Locale.current.calendar.isDateInToday(self) {               // localize / comment -&gt; translator               let timeFormat = NSLocalizedString(\"Today at %@\", comment: \"Today at time format string\")               return String(format: timeFormat, timeText)           } else {               let dateText = formatted(.dateTime.month(.abbreviated).day())                           let dateAndTimeFormat = NSLocalizedString(\"%@ at %@\", comment: \"Date and time format string\")                           return String(format: dateAndTimeFormat, dateText, timeText)                       }                   }       var dayText: String {           if Locale.current.calendar.isDateInToday(self) {               return NSLocalizedString(\"Today\", comment: \"Today due date description\")            } else {               return formatted(.dateTime.month().day().weekday(.wide))           }       }   }   날짜 formatting 파트 (필요 없을 것 같음)   HeaderView      title(header)   설정 icon   searchbar and button   (검색 버튼 누르지 않고 입력하면 아래 아이템이 바뀌는 기능으로 구현하면 좋을 것 같음)   UICollectionReusableView   UICollectionReusableView를 사용하여 supplementary views를 생성합니다.    Supplementary views는 각 collection view cells와 분리되기 때문에 header나 footer를 생성하는데 사용되기 좋습니다.   HeaderView - Subviews - Constraints   Subviews     설정 버튼   타이틀   검색 textfield   Constraints 조정 완료    버튼, text field 기능 동작 확인   Organize View Controller   UIKit 앱에서 view controller는 여러개의 역할을 함. Item list view controller의 역할을 정리해봅니다. 연관된 동작과 관련된 데이터 소스를 분리된 파일로 추출.   Collection view 데이터 소스는 콜렉션 뷰의 데이터를 관리.    또, 콜렉션뷰가 리스트의 아이템을 화면에 보여주기 위해 사용하는 셀을 생성하고 배치.   View controller behavior와 data source behavior를 다른 파일로 나누어 줌.   View controller는 UIKit 앱에서 많은 역할을 하기 때문에 파일이 커질 수 있음.    분리된 파일과 extextions를 이용하여 재정리하는 것을 에러를 빨리 찾을 수 있도록 하고 새로운 기능을 추가하기 쉽도록 함.   중간 정리   UI     Header   UICollectionView - Supplementary View   UICollectionReusableView 상속   subviews (설정 버튼 / 페이지 타이틀 / 검색창)를 담을 수 있는 header view 구현을 목적   Resuable view를 사용하면 스크롤을 내릴 시에도 사라지지 않고 고정됨   UIButton과 UITextField는 동작하나 기능이 연결되어 있지는 않음   Storyboard 이용하지 않고 코드만 작성하여 UI를 그리니 storyboard에 미리보기가 나타나지 않는 문제있음   List Layout   UICollectionViewCompositionalLayout   현재 기본 타입 리스트라 커스텀에 제약이 있음 (커스텀 가능하게 변경 가능)   유통기한의 남은 기간을 UICellAccessory 로 표현   각 아이템의 title / notes 는 데이터 모델의 sample data에서 가져오도록 함   느낀점   Storyboard가 아니라 코딩만으로 UI를 짜는 새로운 경험을 해볼 수 있어서 좋았다.    지금은 구현이 먼저라 기능이 UI나 기능이 구현이 되면 넘어가고 있지만 시간이나면 정리를 하면서 코드가 어떤 과정을 거치는지 다시 한번 생각해 보면 좋을 것 같다.   Cell Info 추가   View controller는 init(coder:) 생성자를 필요로 합니다.   expDate를 리스트나 디테일 뷰에 나타나도록 해야할까?  -&gt; 나타나게 함     Wire a Target Action Pair   Target Action은 디자인 패턴.    객체가 필요한 정보를 보관 -&gt; 이벤트 발생 시 다른 객체에 전송   여기서는 사용자가 DoneButton을 탭할 때 touchUpInside 이벤트 발생.    didPressDoneButton: sender 메세지를 View controller에게 보냄     // Item 모델 이용 CustomViewConfiguration을 리턴   private func doneButtonConfiguration(for item: Item) -&gt; UICellAccessory.CustomViewConfiguration {       // true면 칠해진 휴지통 아이콘, false면 빈 휴지통 아이콘이 나타나도록 조건       let symbolName = item.isComplete ? \"xmark.bin.fill\" : \"xmark.bin\"       let symbolConfiguration = UIImage.SymbolConfiguration(textStyle: .title1)       let image = UIImage(systemName: symbolName, withConfiguration: symbolConfiguration)       // 커스텀 버튼 (ItemDoneButton 클래스)       let button = ItemDoneButton()       button.addTarget(self, action: #selector(didPressDoneButton(_:)), for: .touchUpInside)       button.id = item.id       button.setImage(image, for: .normal)       return UICellAccessory.CustomViewConfiguration(customView: button, placement: .leading(displayed: .always)) // 완료되면 휴지통으로 가도록 설정하기   }    button.addTarget(self, action: #selector(didPressDoneButton(_:)), for: .touchUpInside)  addTarget를 호출하여 버튼의 touchUpInside 이벤트를 didPressDoneButton 액션 메서드에 연결해줌.   Navigation controller   코드로 디테일 뷰를 메인 뷰위에 푸시해준 뒤 Main.Storyboard에 navigation controller를 추가해줌.    현재 스토리보드에는 미리보기가 보이지 않는 상황이라 코드로 UI 작성하면 스토리보드는 상관이 없다고 생각했는데 스토리 보드에 추가해 준 navigation view가 스택처럼 작동한다고 함.   IndexPath 와 Item.ID   공부하기   Edit view 만드는 중      willSet / didSet   willSet은 property가 변경되기 바로 전에 코드를 실행     didSet은 property가 변경된 직후에 코드를 실행      var configuration: UIContentConfiguration {         //configuration property에 configure(configuration:)을 호출하는 cdidSet observer         didSet {             configure(configuration: configuration)         }     }      func configure(configuration: UIContentConfiguration) {         guard let configuration = configuration as? Configuration else { return }         textField.text = configuration.text     }   Downcasting   어떤 클래스 타입의 변수나 상수는 서브클래스의 인스턴스를 참조할 수 있다.   as? 또는 as! 라는 type cast operator를 사용하여 downcasting을 시도할 수 있다.     Downcasting이 실패할 수 있기 때문에 type cast operator는 두가지의 형태로 나뉜다.    Downcasting을 시도하고 있는 타입의 optional 값을 리턴하는 as?(conditional form)과 downcasting과 force-unwrapping을 함께 시도하는 as!(forced form)이다.   Downcasting이 성공할지 확신할 수 없을 때 as? type cast operator를 사용한다.    이 형태의 operator는 항상 optional type의 값을 리턴하고, downcasting이 불가능할때는 nil값을 리턴한다.    Downcasting의 성공을 확신할 수 있을 때는 as! type cast operator를 사용한다.    가능하지 않은 class type으로 downcasting을 시도하면 runtime 에러가 발생한다.     for item in library {       if let movie = item as? Movie {           print(\"Movie: \\(movie.name), dir. \\(movie.director)\")       } else if let song = item as? Song {           print(\"Song: \\(song.name), by \\(song.artist)\")       }   }    // Movie: Casablanca, dir. Michael Curtiz   // Song: Blue Suede Shoes, by Elvis Presley   // Movie: Citizen Kane, dir. Orson Welles   // Song: The One And Only, by Chesney Hawkes   // Song: Never Gonna Give You Up, by Rick Astley   위 예제는 current item을 Movie로 downcasting을 시도하며 시작된다.   Optional binding인 if let movie = item as? Movie는 아래처럼 해석된다.     \"item에 Movie로 접근이 성공하면, movie 상수를 optional Movie 형태의 값으로 설정하라.\"        //   //  TextViewContentView.swift   //  cingcing   //   //  Created by Mirae on 2022/05/15.   //    import UIKit    // UIView의 subview, UIContentView 프로토콜 따름   // 여러 줄의 텍스트를 보여줄 때 text view를 사용   // 왜 inner structure를 사용할까?   class TextViewContentView: UIView, UIContentView {       struct Configutation: UIContentConfiguration {           var text: String = \"\"            func makeContentView() -&gt; UIView &amp; UIContentView {               return TextViewContentView(self)           }       }        // 1. add text text view and configuration property       // didSet 코드 블럭 안에 configuration이 var configuration 속성이라면 왜 self를 사용하지 않을까?       let textView = UITextView()       var configuration: UIContentConfiguration {           didSet {               configure(configuration: configuration)           }       }    //    override var intrinsicContentSize: CGSize {   //        CGSize(width: 0, height: 44)   //   //    }        // 2. add an initializer that sets the configuration property       init(_ configuration: UIContentConfiguration) {           self.configuration = configuration           super.init(frame: .zero)   //        addPinnedSubview(textView, insets: UIEdgeInsets(top: 0, left: 16, bottom: 0, right: 16))           // x 버튼은 textField에서만 사용 가능 하다고 함       }        required init?(coder: NSCoder) {           fatalError(\"init(coder:) has not been implemented\")       }        // 3. function that sets the text view's text property       // textView에 원래 있는 속성 text에 configuration의 text를 설정       func configure(configuration: UIContentConfiguration) {           guard let configuration = configuration as? Configutation else { return }           textView.text = configuration.text       }   }    extension UICollectionViewListCell {       func textViewConfiguration() -&gt; TextViewContentView.Configutation {           TextViewContentView.Configutation()       }   }   위 코드의 configure(configuration:) function에서 downcasting을 실행함.    confiuguration property는 TextViewContentView 클래스의 속성임.    configuration 속성이 inner structure인 Configuration의 text 속성을 이용하기 위해 downcasting을 시도하는 것 같음.   Text view   편집창의 notes는 text view를 사용합니다. Text view는 스크롤 뷰이기 때문에 자동으로 스크롤링과 스크롤 인디케이터를 제공합니다.      ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","프로젝트 기록"],
        "url": "/til/teamProject/",
        "teaser": "/assets/images/teaser.jpg"
      }]
