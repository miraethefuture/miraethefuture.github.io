var store = [{
        "title": "영단어 정리",
        "excerpt":"  🗂  A      access   to find information, especially on a computer    (주로 컴퓨터에서)정보를 찾는 것      Users can access their voice mail remotely.   whatever thing is accessed by the URL you supply        allow   to make something happen, especially something helpful or useful.    어떤일이 일어나는 것을 가능하게 만들다.        append   to add something to a piece of writing.    글에 어떤 내용을 덧붙이다.      덧붙이다   첨부하다        assign   to give a particular time, value, place etc to something.    특정 시간, 값, 장소등을 어떤 것에게 배정하다. (할당 / 대입하다.)      How much time have you assigned for the meeting?   첨부하다        automate   to start using computers or machines to do a job, rather than people    어떤 일을 하기 위해 사람 대신 컴퓨터나 기계를 사용하다.      Cash machines automates two basic function of a back - deposits and withdrawals.   Build tools are programs that automate the creation of executable applications from source cord.     🗂️  B      bypass   to avoid obeying a rule, system, or someone in an official position.    규칙, 시스템, 공식적인 자리에 있는 사람에게 복종하는 것을 피하는 것      Francis bypassed his manager and wrote straight to the director.   You can bypass basic setup steps that are already familiar to you.     🗂️  C      compatible   if two pieces of computer equipment of software are compatible, they can be used together, especially when they are made by different companies.     소프트웨어에서 사용되는 도구 두가지가 compatible 하다면, 그것은 두가지가 함께 사용될 수 있다는 것을 의미합니다. (특히, 다른 회사에서 만들어진 두가지 도구 일 때 말이죠.)      Will the software on my PC be compatible with a Mac?          configure   to arrange something, especially computer equipment, so that it works with other equipment.    어떤 것을 미리 준비해두다. 특히 다른 도구들과 함께 작동될 수 있도록 컴퓨터 도구들 준비해두다.      This project is configured to fit the exaples in this tutorial.        conform    to obey a law, rule etc 규칙에 순응하다.       An app that uses SwiftUI app life cycle has a structure that conforms to the APP protocol    SwiftUI 앱 라이프 사이클을 사용하는 앱은 그 앱의 프로토콜에 순응하는 구조를 가지고 있다.         consecutive   consecutive numbers or periods of time follow one after the other without any interruptions.    consecutive nunmbers 이나 consecutive peridos of time은 중간에 끊어짐 없이 계속해서 하나의 수가 다른 하나의 수를 따르는 것을 말합니다.      Can they win the title for the third consecutive season?     걔네 삼년 연속으로 우승할 수 있을까?     🗂️  D      define   to describe something correctly and thoroughly, and to say what standards limits qualities etc it has that make it different from other things     어떤 것을 명확히 묘사하는 것, 그리고 그것이 다른 것들과는 다른 어떤 기준, 한계 등을 가지고 있는지 말하는 것.      the ability to define clients' needs     🗂️  E      executable   a computer file that can be run as a program    프로그램으로 실행 될 수 있는 파일.   (명사 / 형용사 둘 다 executable)    🗂️  G      goes a long way towards(to)   If you say that something goes a long way towards doing a particular thing, you mean that it is an important factor in achieving that thing.    something 은 a particular thing 을 달성하기 위한 중요한 요소이다.      Implementing the trends will go a long way to building a functional site.   :: 그 트렌드를 구현하는 것은 잘 작동하는 사이트를 만들기 위한 중요한 요소가 될 것이다.    Although not a cure, it goes a long way towards making the patient's life tolerable.   :: 치료법은 아니지만, 그것은 환자의 삶을 견딜 수 있게 만드는데 큰 도움이 된다.      🗣️ goes a long way towards 발음 들어보기   🗂️  I      invoke   to operate a computer program    컴퓨터 프로그램을 작동시키다.      In small projects, developers often manually invoke the build process          instruction   a command given to a computer to carry out a particular operation.    특정한 일을 수행하기 위해 컴퓨터에게 주어진 명령어.      to put a set of instructions into a computer in a form that it can understand and use.     🗂️  M      manually   operated or done by hand or without the help of electricity, computers etc    기계나 전기의 도움 없이 사람으로부터 수행됨.      It would take too long to do a manual search of all the data.   In small projects, developers often manually invoke the build process        metadata   information that describes what is contained in large computer databases, for example who wrote the information, what it is for, and in what form it is stored    큰 컴퓨터 데이타베이스에 무엇이 저장되어 있는지 알려주는 정보이다. 예를 들면 누가 이 정보를 작성했고, 무엇을 위한 것이고, 어떤 형식으로 저장되었는지에 관한 정보를 알려준다.      Spring Boot Annotations is a form of metadata that provides data about a program.        map onto   to match something or have direct relationship with something    어떤 것을 연결하거나 직접적인 관계를 가지는 것.      Spring Boot Annotations is a form of metadata that provides data about a program.     🗂️  P     protocol   an established method for conneting computers so that they can exchange information    컴퓨터들이 서로 정보를 교환할 수 있는 방법        phase   one of the stages of a process of development or change    개발 또는 변화 중인 절차의 한 단계      a new drug that is in the experimental phase   the first phase of renovation should be done by January     🗂️  R      retrieve   to get back information that has been stored in the memory of a computer    큰 컴퓨터 데이타베이스에 무엇이 저장되어 있는지 알려주는 정보이다. 예를 들면 누가 이 정보를 작성했고, 무엇을 위한 것이고, 어떤 형식으로 저장되었는지에 관한 정보를 알려준다.      Spring Boot Annotations is a form of metadata that provides data about a program.     🗂️  T      transfer   to copy recorded information from one system to another   시스템에 기록된 정보를 다른 시스템에 복사하는 것.      Spring Boot Annotations is a form of metadata that provides data about a program.     🗂️ U     underlying cause/principle/problem etc   the cause, idea etc that is the most important, although it is easily not noticed    알아차리기 힘들지만 가장 중요한 원인이나 아이디어.      the underlying causes of her depression      ","categories": ["vocabularies"],
        "tags": ["studying","learning","vocabularies"],
        "url": "/vocab/verb/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "JDBC로 오라클 클라우드 DB와 연결하여 이클립스 콘솔 창에 데이터 불러오기",
        "excerpt":"  💭 ..     맥북 유저에게 국비 수업이란...?    처음 국비 수업을 듣기로 결심했을 때 가장 걱정이 되었던 것은 나에겐 Windows 운영체제를 사용하는 랩탑이 없다는 것이었다. 국비 수업은 Windows를 기준으로 진행되기 때문에 macOS로 수업을 듣다가 문제가 생기면 강사님의 도움을 받기가 쉽지 않다. 수업 전 진행된 오티에서 강사님도 되도록이면 Windows를 사용할 것을 권했다. 나는 macOS를 사용한 지 오래되었고, 국비 수업을 듣기 전 독학하며 구글링 실력을 꽤 키웠다고 생각했기 때문에 굳이 Windows 운영체제의 랩탑을 구하려고 하지 않았다. 내가 혼자 해결할 수 있을 거라는 원인 모를(ㅎㅎ) 자신감이 있었다.  이클립스 IDE나 Java는 이미 설치해서 사용하고 있었기 때문에 수업 중 설치하는 시간에 문제가 없었다. 그 후로 쭉 문제없이 수업을 잘 들었다. 작은 에러들은 구글링으로 해결할 수 있었다. 그러던 중 데이터베이스에 대해 배우는 주가 시작되었다. 국비 수업이 시작되기 전, 수업에 대한 정보들을 검색해 보던 중 m1 칩 맥북은 오라클을 사용할 수 없다는 것을 알게 되었고 아래 도움이 된 글 목록 중 첫 번째에 있는 블로그의 글을 보고 미리 오라클 클라우드에 가입 후 DB를 생성하고 SQL Developer와 연동은 해둔 상태였다. 하지만 당시에는 DB와 Java로 작성된 프로그램을 연결하려면 JDBC를 이용해야 한다는 것을 몰랐다. DB와 Java를 연결하는 수업이 시작되었고 많은 분들이 JDBC driver를 다운로드하고 연결하는 과정에 어려움을 겪었다. 나도 다르지 않았다.  아무것도 모르던 4개월 전, 깃헙 페이지로 개발 블로그를 만들려고 구글링을 하며 오랜 시간을 삽질했던 때가 있었다. 그때는 한 가지 문제를 해결하려고 3일, 4일을 구글링하고도 원하는 답을 찾지 못할 때도 있었다. 그때의 기억이 떠올라서 식은땀이 쫙 났다.      'DB와 자바를 연결하지 못하면 수업을 듣기 힘들 텐데 어쩌나.. 밤을 새워서라도 해야겠다.'  라고 생각하고 있었는데 다행히 벌써 많은 분들이 애플 실리콘칩 맥북 + 오라클 클라우드 DB를 연동하는 방법에 대한 블로그 글을 올려주셨고 덕분에 생각보다 빠르게 해결할 수 있었다. 수업이 끝나기 전에 연결이 잘 되어서 엄청 기쁘고 다행이라는 생각이 들었다.     다음에 또 필요할 때를 대비해 기록을 남겨둔다. 국비 수업을 들으려는 다른 macOS 유저들에게도 조금이나마 도움이 되길 바란다.    🔦 도움이 된 글  1. Apple Silicon m1 맥북에서 Oracle Database 사용하기  2. Apple Silicon) M1 으로 oracle&amp;eclipse 연동하기 (3)  3. okky 쿠잉님 댓글   1. JDBC의 역할   JDBC는 DB와 Java를 연결해 주는 API입니다. 자바 언어로 작성한 프로그램에서 데이터 베이스에 접근하고 여러 가지 데이터와 관련된 작업을 수행할 수 있게 되죠. 예를 들면, 이클립스에서 몇 가지 자바 클래스와 메서드 그리고 SQL 문을 사용하여 직접 DB에 접근해 데이터를 검색, 추가, 삭제, 수정할 수 있게 되는 것입니다.   2. SQL Developer를 이용해 테이블 만들기   먼저 저는 SQL Developer를 이용하여 오라클 클라우드 DB에 간단한 테이블을 하나 만들어 주었습니다. 테이블 이름은 stardew_valley 입니다.                          VNAME       ADDRESS       AGE                       1       Gus       The Stardrop Saloon       48                 2       Abigail       Pierres General Store       24                 3       Sebastian       24 Mountain Road       26              3. Java 프로그램 내에서 연결된 DB의 데이터에 접근하기   먼저 작업하고 있는 Java project에 ojdbc8.jar를 추가합니다. 위 도움을 받은 글 목록 중 두번째 블로그 글을 보면 꼭 ojdbc8.jar을 받아야 한다고 하셨는데요. 저도 처음에 다른 버전으로 받았다가 제대로 실행되지 않는 문제를 겪었습니다.   import java.sql.*;  public class Jdbc_test {   public static void main(String[] args) {      String url = \"jdbc:oracle:thin:@데이터 베이스 이름_high?TNS_ADMIN=전자지갑 압출 풀어준 폴더의 경로\";     String userid= \"데이터베이스 userid\"; // 변경하지 않았다면 admin     String pwd = \"데이터베이스 접속 비밀번호\"; // DB 생성 시 지정했던 비밀번호       try{        // 오라클 드라이버 로딩       Class.forName(\"oracle.jdbc.OracleDriver\");        // DB에 연결       Connection con = DriverManager.getConnection(url, userid, pwd);        // sql문 작성 - DB에 저장되어있는 테이블에서 모든 레코드 정보 가져오기       String sql = \"select * from stardew_valley\"; // \"\"; 안에 sql문 작성 후 sql 변수에 할당        // 작성한 sql문을 DB로 전달하기 위해 연결       PreparedStatement ps = con.prepareStatement(sql);        // 실행 후 결과값을 ResultSet 타입의 변수에 할당       ResultSet rs = ps.executeQuery();        // 반복문 이용 결과값 출력       while(rs.next()) { // next() 메서드는 값이 있으면 true 반환 -&gt; 값이 없을 때가지 반복         String vname = rs.getString(\"vname\");         String address = rs.getString(\"address\");         int age = rs.getInt(\"age\");          // 임시 header 출력         System.out.println(vname + \"\\t\" + address + \"\\t\" + age);        }        // 연결되어있던 객체들 닫아주기       ps.close(); con.close(); rs.close();      } catch(Exception e) {       e.printStackTrace();     }   } }  실행하면 작성해 준 임시 header 아래로 위 표와 같은 모든 데이터를 console 창에 출력합니다.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Java","Oracle Cloud","Database"],
        "url": "/til/jdbc/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "A Swift Tour : 디지털 시계 앱을 만들며 스위프트 배워보기",
        "excerpt":"💭 ..     Swift는 어떤 언어일까?    디지털시계 앱을 만들며 Swift의 기초적인 것들을 알아봅니다.         1. ContentView와 ContentView_Previews  Intro to SwiftUI: Digital Clock &lt;- 블로그의 글을 보며 공부합니다.   //  ContentView.swift //  Your Digital Clock  import SwiftUI  struct ContentView: View {     @State var date = Date()     var body: some View {          ZStack {             Image(\"unsplash-photo\")             .resizable()             .scaledToFill()             .ignoresSafeArea()          VStack {              Text(\"\\(timeString(date: date))\")                  .font(.system(size: 160))                  .fontWeight(.bold)                  .foregroundColor(Color.white)                  .onAppear(perform: {let _ = self.updateTimer})                 // 여기 이해 안됨. date: date               Text(\"\\(greeting())\")                  .font(.system(size: 75))                  .foregroundColor(Color.white)               Text(\"\\(dateString(date: date))\")                  .font(.system(size: 20))                  .foregroundColor(Color.white)                  .onAppear(perform: {let _ = self.updateTimer})                  .offset(y: 100)                } // VStack            } // ZStack        } // body       // ContentView structure     var timeFormat: DateFormatter {         let formatter = DateFormatter()         formatter.dateFormat = \"hh:mm:ss a\"         return formatter     } // 시간 부분 Formatter      var dateFormat: DateFormatter {         let formatter = DateFormatter()         formatter.dateFormat = \"yyyy/MM/dd EEEE\"         return formatter     }      func timeString(date: Date) -&gt; String {         let time = timeFormat.string(from: date)         return time     }      func dateString(date: Date) -&gt; String {         let time = dateFormat.string(from: date)         return time     }       var updateTimer: Timer {         Timer.scheduledTimer(withTimeInterval: 1, repeats: true, block: { _ in             self.date = Date()         })     } // timeInterval 마다 블락 안의 코드가 실행됨      func greeting() -&gt; String {         var greet = \"\"          let midNight0 = Calendar.current.date(bySettingHour: 0, minute: 00, second:00, of: date)!         let nightEnd = Calendar.current.date(bySettingHour: 3, minute: 59, second: 59, of: date)!          let morningStart = Calendar.current.date(bySettingHour: 4, minute: 00, second: 0, of: date)!         let morningEnd = Calendar.current.date(bySettingHour: 11, minute: 59, second: 59, of: date)!          let noonStart = Calendar.current.date(bySettingHour: 12, minute: 00, second: 00, of: date)!         let noonEnd = Calendar.current.date(bySettingHour: 16, minute: 59, second: 59, of: date)!          let eveStart = Calendar.current.date(bySettingHour: 17, minute: 00, second: 00, of: date)!         let eveEnd = Calendar.current.date(bySettingHour: 20, minute: 59, second: 59, of: date)!          let nightStart = Calendar.current.date(bySettingHour: 21, minute: 00, second: 00, of: date)!         let midNight24 = Calendar.current.date(bySettingHour: 23, minute: 59, second: 59, of: date)!          if ((date &gt;= midNight0) &amp;&amp; (date &lt;= nightEnd)) {             greet = \"Good Night\"         } else if (date &gt;= morningStart) &amp;&amp; (date &lt;= morningEnd) {             greet = \"Good Morning\"         } else if ((date &gt;= noonStart) &amp;&amp; (noonEnd &gt;= date)) {             greet = \"Good Afternoon\"         } else if ((date &gt;= eveStart) &amp;&amp; (eveEnd &gt;= date)) {             greet = \"Good Evening\"         } else if ((date &gt;= nightStart) &amp;&amp; (midNight24 &gt;= date)) {             greet = \"Good Night\"         }          return greet      } // func greeting  } // ContentView 끝   struct ContentView_Previews: PreviewProvider {     static var previews: some View {         ContentView()         .previewInterfaceOrientation(.landscapeLeft)     } }  Xcode에서 처음 프로젝트를 열면 ContentView 그리고 ContentView_Previews라는 이름을 가진 두개의 structure가 기본적으로 생성되어 있습니다. 이 글에서는 이 두가지의 structure를 이용하여 간단한 디지털 시계앱을 만들어보며 시간/날짜 정보를 불러오는 방법에 대해 알아보겠습니다.   ContentView: View와 var body: some View에서 View는 이 structure가 View protocol을 따를 것이라는 의미입니다. Protocol은 요구사항을 가지고 있습니다. View 프로토콜의 가장 주요한 요구사항은 body property가 있어야 한다는 것입니다.   body property 부분에는 스크린에 나타날 view들이 작성됩니다. 이때의 view는 프로토콜 view가 아닌 Text view, Image view, Button view와 같은 SwiftUI의 built-in view 또는 외부 프레임의 view들을 말합니다. 위 코드에서는 ZStack의 하위에 Image view와 VStack이, 그리고 VStack 하위에는 Text view가 body property 안에 작성되었습니다.   2. 현재 날짜와 시간 정보 가져오기   struct ContentView: View {   @State var date = Date() }           ‘@State’ property wrapper는 해당 변수가 모니터링 되고 있다는 것을 의미합니다.            ‘Date()’는 사용자가 있는 지역의 날짜와 시간 정보를 가져옵니다.       import SwiftUI  struct ContentView: View {     @State var date = Date()     var body: some View {         VStack {           Text(\"\\(date)\")         }     } }  struct ContentView_Previews: PreviewProvider {     static var previews: some View {         ContentView()     } }   시간 정보는 초마다 계속해서 바뀌므로 property wrapper인 @State 를 사용해서 바뀐 시간을 계속해서 업데이트, 반영해 주고 문자열 date에 escape character \\ 를 추가해서 Date()를 담고 있는 date 변수의 할당되어 있는 정보를 문자열로 가져옵니다.   3. DateFormatter  import SwiftUI  struct dateString: View {     @State var date = Date()     var body: some View {         Text(\"\\(date)\")     } }  struct dateString_Previews: PreviewProvider {     static var previews: some View {         dateString()     } }   위 코드로 가져온 날짜/시간 데이터를 화면에 출력해봅니다. 아직 형식을 지정해주지 않았기 때문에 아래 사진처럼 보여집니다. 날짜, 시간, 분이라는 정보가 포함되어 있지 않고 나열된 문자열로써 나타납니다.      시간 부분의 형식을 먼저 지정해보겠습니다.   var timeFormat: DateFormatter {   let formatter = DateFormatter()   formatter.dateFormat = \"hh:mm:ss a\"   return formatter }   DateFormatter는 시간/날짜 데이터를 문자열 형식으로 보여지게 하는 Class입니다. dateFormat은 DateFormatter Class의 instance property입니다. 데이터를 받은 사람이 사용할 수 있는 날짜/시간 데이터의 형식 중 하나입니다.     hh - 12시간 표기법 시간   mm -  분   ss -  초   a - am/pm   그 다음으로는 가져온 시간 데이터를 문자열로 바꿔주는 function을 작성해봅니다.  func timeString(date: Date) -&gt; String {   let time = timeFormat.string(from: date)   return time }   여기까지 수정 👷   4. Live Time   SwiftUI가 State variable에 일어난 변화들을 감시합니다. @State는 스스로 변화를 만들지는 않습니다.  Date() initializer는 시간의 한 지점을 가져옵니다. 우리가 방금 만든 디지털 시계가 자동으로 흘러가지 않는 이유이죠.   우리가 보는 시계들처럼 초가 흘러가고 60초가 지나면 1분이 늘어나게 만드려면 매초마다 date variable을 새로 고침해주어야 합니다.  그러려면 Timer 객체를 사용하면 됩니다. Timer는 일정 시간이 지나면 특정 메세지를 타겟 객체에 보냅니다. Timer을 설정해주면 SwiftUI가 @State의 변화를 인식하고 그것에 따라 우리의 시계를 업데이트 해줄 것입니다.   Timer 객체를 생성하는 코드를 작성해봅니다.   var updateTimer: Timer {   Timer.scheduledTimer(withTimeInterval; 1, repeats: true,     block: {       self.date = Date()       })   }   scheduledTimer() 메서드를 이용합니다. 첫번째 인자는 withTimeInterval이고 시간의 간격을 입력해줍니다.  두번째는 repeat 입니다. 반복할 것인지 아닌지 bool 타입으로 입력해줍니다.  세번째는 block 입니다. Timer가 반복될 때마다 작동될 코드를 작성해줍니다.   아직은 초마다 시계가 움직이지 않죠? 한 단계가 더 남아있습니다. Text View 아래에 .onAppear modifier을 사용하여 Timer가 스크린에 나타나도록 해줍니다.   Text(\"\\(timeString(date: date))\")   .onAppear(perform: {let _ = self.updateTimer})   .onAppear(perform: action) 은 function modifier 입니다. View가 나타나면 action을 수행합니다. self.updateTimer function은 저장할 필요가 없는 값을 반환하기 때문에 ‘let _‘을 사용했습니다. underscore 는 아무것도 할당하고 싶지 않다는 것을 나타냅니다. 이 스텝까지 잘 마치셨다면 디지털 시계가 초마다 움직이는 것을 볼 수 있을 것입니다!   5. Time of Day Greeting   시간에 따라 달라지는 인사말을 추가해볼 것입니다.     4:00:00am to 11:59:59am -&gt; Morning   12:00:00pm to 4:59:59pm -&gt; Afternoon   5:00:00pm to 8:59:59pm -&gt; Evening   8:00:00pm to 3:59:59am -&gt; Night  위의 기준으로 시간을 나누고 각 시간대의 인사말이 시계 아래에 나타나도록 해봅시다.   func greeting() -&gt; String {         var greet = \"\"          let midNight0 = Calendar.current.date(bySettingHour: 0, minute: 00, second:00, of: date)!         let nightEnd = Calendar.current.date(bySettingHour: 3, minute: 59, second: 59, of: date)!          let morningStart = Calendar.current.date(bySettingHour: 4, minute: 00, second: 0, of: date)!         let morningEnd = Calendar.current.date(bySettingHour: 11, minute: 59, second: 59, of: date)!          let noonStart = Calendar.current.date(bySettingHour: 12, minute: 00, second: 00, of: date)!         let noonEnd = Calendar.current.date(bySettingHour: 16, minute: 59, second: 59, of: date)!          let eveStart = Calendar.current.date(bySettingHour: 17, minute: 00, second: 00, of: date)!         let eveEnd = Calendar.current.date(bySettingHour: 20, minute: 59, second: 59, of: date)!          let nightStart = Calendar.current.date(bySettingHour: 21, minute: 00, second: 00, of: date)!         let midNight24 = Calendar.current.date(bySettingHour: 23, minute: 59, second: 59, of: date)!          if ((date &gt;= midNight0) &amp;&amp; (date &lt;= nightEnd)) {             greet = \"Good Night.\"         } else if (date &gt;= morningStart) &amp;&amp; (date &lt;= morningEnd) {             greet = \"Good Morning\"         } else if ((date &gt;= noonStart) &amp;&amp; (noonEnd &gt;= date)) {             greet = \"Good Afternoon.\"         } else if ((date &gt;= eveStart) &amp;&amp; (eveEnd &gt;= date)) {             greet = \"Good Evening.\"         } else if ((date &gt;= nightStart) &amp;&amp; (midNight24 &gt;= date)) {             greet = \"Good night.\"         }          return greet      }   Calendar.current.date(bySettingHour…) 메서드는 주어진 date 데이터에 특정한 시간을 나타내는 variable을 만듭니다. 여기서는 우리가 위에서 만든 @State date가 주어진 날짜 데이터입니다.   아래 부분은 나누어 놓은 시간대와 현재 시간을 비교하는 부분입니다. 현재 시간과 비교해서 해당되는 인사말을 greet 변수에 담고 반환합니다. 여기까지 하면 시간을 스크린에 띄우는 것은 완성!   … 디지털시계 만들기는 계속 됩니다.      ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift"],
        "url": "/til/basicSwift2/",
        "teaser": "/assets/images/yourDigitalClock.png"
      },{
        "title": "SwiftUI Tutorial: 여러 개의 View를 만들고 결합하기",
        "excerpt":"SwiftUI Tutorial을 따라가며 아래 Landmark앱을 만들어 보겠습니다. 튜토리얼의 출처는 SwiftUI Essentials: Creating and Combining Views 입니다.      ☑️ What I Learned From This Tutorial:      SwiftUI 프레임워크와 다른 프레임워크를 함께 사용하는 방식   여러개의 파일을 하나의 View로 합치기   Stack의 사용법   지도와 관련된 Structures   alignment: .leading   Divider()   Spacer()              1. Stacks을 이용해 텍스트 배치하기: ContentView.swift   // ContentView.swift // Landmarks  import SwiftUI  struct ContentView: View {   var body: some View {      VStack(alignment: .leading) {          Text(\"경복궁\")             .font(.title)             .foregroundColor(.black)          HStack {              Text(\"Gyeongbokgung Palace\")                 .font(.subheadline)             Text(\"Korea\")                 .font(.subheadline)         } // HStack 끝         .font(.subheadline)         .foregroundColor(.secondary)          Divider()         Text(\"About Gyeongbokgung\")             .font(.title2)         Text(\"Gyeongbokgung, also known as Gyeongbokgung Palace or Gyeongbok Palace,         was the main royal palace of the Joseon dynasty.         Built in 1395, it is located in northern Seoul, South Korea.\")             .font(.body)      } // VStack     .padding()   } }  struct ContentView_Previews: PreviewProvider {   static var previews: some View {       ContentView()     } }   이 부분에서는 Stack과 Spacer()를 이용해서 Text view를 배치하는 것에 대해 알아보았습니다. .foregroundColor(.secondary)는 옅은 회색을 화면에 보여줍니다. alignment가 기본적으로는 가운데로 지정되어 있고 왼쪽 정렬을 하려면 (alignment: .leading)을 사용하면 됩니다.    아래는 위 코드가 화면에 그려진 결과입니다. Divider()를 이용해 콘텐츠를 나누는 줄을 그릴 수 있습니다.      2. 지도와 관련된 데이터 불러오기: MapView.swift   // MapView.swift // Landmarks  import SwiftUI import MapKit  struct MapView: View {     @State private var region = MKCoordinateRegion(         // 경복궁의 위도와 경도         center: CLLocationCoordinate2D(latitude: 37.580_535, longitude: 126.977_341),         span: MKCoordinateSpan(latitudeDelta: 0.05, longitudeDelta: 0.05)         )      var body: some View {         Map(coordinateRegion: $region)     } }  struct MapView_Previews: PreviewProvider {     static var previews: some View {         MapView()     } }   SwiftUI 프레임워크를 추가하고 그 외에 또 다른 프레임 워크를 추가하면,  (여기서는 MapKit라는 프레임워크를 추가했습니다.)  추가된 프레임워크와 관련된 SwiftUI의 특정 기능에 접근할 수 있게 됩니다.   MKCoordinateRegion는 위도, 경도로 표시된 특정 좌표 평면상의 지역을 직사각형의 형태로 가져오는 Structure입니다. 위 코드에서는 가져온 지역 정보를 region이라는 이름의 private state variable에 담았습니다.   center: 와 span:은 파라미터 입니다.  center: 는 가운데 오게 될 지역의 위도, 경도  span: 은 지도가 보여질 크기를 나타내는 horizontal span과 vertical span이 들어올 것입니다.   CLLocationCoordinate2D은 국제 좌표계를 기준으로 특정 지역의 위도 경도를 이용하여 지역 좌표 object를 생성하는 Structure입니다. center: 파라미터를 지나는 값이니 생성된 좌표 object를 중심점으로 사용한다는 뜻이겠죠?   MKCoordinateSpan은 지도로 표현된 지역의 가로와 세로 크기를 표현하는 Structure입니다. delta values를 이용해서 원하는 줌 레벨을 설정할 수 있습니다. delta value이 커지면 줌 레벨은 작아집니다. delta value가 작아지면 줌 레벨을 커지면서 더 가까이 지도를 볼 수 있습니다.   body property의 Map()은 Generic Structure로, 사용할 지도 인터페이스를 보여주는 역할을 합니다. 위 코드에는 표현되지 않았지만 사용자의 위치를 보여주거나 이동경로를 추적하는 등의 기능을 합니다.  아래는 위 코드가 화면에 그려진 결과입니다. 더블 클릭을 하여 화면을 확대하거나, 양쪽으로 끌어 움직일 수 있습니다.        3. 동그라미 모양으로 이미지 잘라내기: CircleImage.swift   //  CircleImage.swift //  Landmarks  import SwiftUI  struct CircleImage: View {     var body: some View {         Image(\"kbpalace\")             .clipShape(Circle())             .overlay {                 Circle().stroke(.white, lineWidth: 4)             } //overlay {}             .shadow(radius: 7)     } }  struct CircleImage_Previews: PreviewProvider {     static var previews: some View {         CircleImage()     } }  이 부분에서는 .clipShape(Circle()) 메서드를 사용하여 이미지를 동그랗게 잘라냅니다. .overlay 부분에서는 테두리가 될 부분을 만들어 줍니다. overlay 메서드는 레이어를 만들어 줍니다. 우리가 앞에서 만들었던 동그라미 모양의 사진 위에 레이어가 한층 생기는 거죠. Circle().stroke(.white, lineWidth: 4)는 동그라미 모양의 테두리를 그려줍니다. .shadow는 그림자를 그려줍니다.     4. Views를 결합하기   //  ContentView.swift //  Landmarks  import SwiftUI  struct ContentView: View {     var body: some View {         VStack {             MapView()                 .ignoresSafeArea(edges: .top)                 .frame(height: 300)              CircleImage()                 .offset(y: -130)                 .padding(.bottom, -130)              VStack(alignment: .leading) {                 Text(\"경복궁\")                     .font(.title)                 .foregroundColor(.black)                 HStack {                     Text(\"Gyeongbokgung Palace\")                         .font(.subheadline)                     Spacer()                     Text(\"Korea\")                         .font(.subheadline)                 } // HStack                 .font(.subheadline)                 .foregroundColor(.secondary)                  Divider()                 Spacer()                 Text(\"About Gyeongbokgung\")                     .font(.title2) //                Spacer()                 Text(\"Gyeongbokgung, also known as Gyeongbokgung Palace or Gyeongbok Palace, was the main royal palace of the Joseon dynasty. Built in 1395, it is located in northern Seoul, South Korea.\")                     .font(.body)                 Spacer()               } // VStack             .padding()              Spacer()         } // 가장 바깥쪽 VStack      } }  struct ContentView_Previews: PreviewProvider {     static var previews: some View {         ContentView()     } }    이제 위에서 만든 모든 View 들은 합쳐줍니다. .offset() 메서드의 y 파라미터의 값을 주어 원래의 dimension에서 콘텐츠를 조금 올려줍니다. .offset() 메서드가 없다면 VStack 안에서 겹치지 않고 나열되어 있을 것입니다.       ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift"],
        "url": "/til/landmarks/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Codility_Developer Training: 배열 챕터의 문제 CyclicRotation",
        "excerpt":"CyclicRotation 문제 읽기   1. 문제를 파악해보자   N개의 정수로 이루어진 배열이 주어집니다. 배열의 Rotation이란 각각의 element를 오른쪽 인덱스로 옮긴다는 뜻입니다. 맨 마지막 인덱스에 있던 요소는 첫 인덱스로 이동합니다.   //the rotation of array A A = [3, 8, 9, 7, 6] // is A = [6, 3, 8, 9, 7]  위의 예제는 배열 A를 한번 rotate한 결과입니다.   목표는 배열 A를 K번 오른쪽 인덱스로 한칸씩 이동시키는 것입니다.   [3, 8, 9, 7, 6] -&gt; [6, 3, 8, 9, 7] [6, 3, 8, 9, 7] -&gt; [7, 6, 3, 8, 9] [7, 6, 3, 8, 9] -&gt; [9, 7, 6, 3, 8]  위의 예제는 3번 rotate한 결과입니다.   2. 로직을 생각해보자   일단 아직은 더 익숙한 언어인 Java로 구체적인 수를 적용하여 코드를 작성해봅니다.  package array;  public class CyclicRotaion {   public static void main(String[] args) {      // 주어진 배열     int[] A = {3, 8, 9, 7, 6};      // 마지막 인덱스의 값 빈 변수에 할당하기     int p = A[A.length-1];      // 한칸씩 옮기기     A[A.length-1] = A[A.length-2];     A[A.length-2] = A[A.length-3];     A[A.length-3] = A[A.length-4];     A[A.length-4] = A[A.length-5];      // 0번째 인덱스에 옮겨두었던 마지막 인덱스 값 할당하기     A[A.length-5] = p;      for(int i = 0; i &lt; A.length; i++) {       System.out.print(A[i] + \" \");     } // for문   } }  위 코드의 실행 결과는 6, 3, 8, 9, 7입니다.   3. 이클립스에서 작성한 문제 해결 코드   package array;  import java.util.Scanner;  public class CyclicRotaion {   public static void main(String[] args) {        // 주어진 배열       int[] A = {3, 8, 9, 7, 6};        // 마지막 인덱스의 값 빈 변수에 할당하기       // 배열의 크기에 상관없이 항상 마지막 인덱스 값을 나타냄.       int p = A[A.length-1];        for(int i = 1; i &lt;= (A.length-1); i++) {           A[A.length-i] = A[A.length-(i+1)];       }        // 0번째 인덱스에 옮겨두었던 마지막 인덱스 값 할당하기       A[A.length-A.length] = p;        // 배열의 값을 출력하는 for문       for(int i = 0; i &lt; A.length; i++) {           System.out.print(A[i] + \" \");       }   } }  반복되는 부분을 for문을 사용하여 작성해줍니다.   4. 코딜리티에 제출한 문제 해결 코드   아래는 최종 정리해서 코딜리티에 제출한 코드입니다.   class Solution {   public int[] solution(int[] A, int K) {     // write your code in Java SE 8      int p = 0; // 마지막 인덱스의 값 옮겨둘 변수      while(K &gt;= 1) { // while문 사용하여 반복할 횟수 K이용        p = A[A.length-1];        for(int i = 1; i &lt;= (A.length-1); i++) {            A[A.length-i] = A[A.length-(i+1)];          } // for문 끝        A[A.length-A.length] = p;       K--;      } // while 문 끝      return A;   } // 메서드 끝 }        내가 푼 풀이의 정확도는 87%        분석 결과를 보니 빈 배열이 입력되었을 때 프로그램이 꺼지는 문제가 발생.   … 문제 해결은 계속됩니다.   추가해야 할 글      문제 해결 과정   빈 배열이 입력되었을 때 프로그램이 꺼지는 문제 해결하기  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Codility","코테"],
        "url": "/til/cyclicRotation/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "JavaScript: 팝업창 가운데에 띄우기",
        "excerpt":"아무런 설정을 하지 않고 window.open() 메서드를 사용해서 팝업창을 띄웠더니 화면 맨 왼쪽 위에 팝업창이 나타납니다. 이 팝업창을 가운데로 옮겨보았습니다.   도움을 받은 글: How to center a popup window on screen?   1. &lt;head&gt;태그 안에 JS function 작성하기     &lt;!DOCTYPE html&gt;   &lt;html&gt;   &lt;head&gt;     &lt;title&gt;Title of the document&lt;/title&gt;     &lt;script type=\"text/javascript\"&gt;             function login_window(url, title, w, h) {                 var left = (screen.width - w) / 2;                 var top = (screen.height - h) / 2;                 var myWindow = window.open(url, title, 'resizable=yes, width=' + w + ', height=' + h + ', top=' + top + ', left=' + left);             }     &lt;/script&gt;   &lt;/head&gt;  script 태그 안에 자바 스크립트 function을 작성해 줍니다.   저는 로그인하는 팝업창을 띄우는 것이라 function의 이름을 login_window라고 하였습니다. url, title, w, h와 같이 네 개의 파라미터를 작성해 줍니다. 이때는 파라미터의 이름이라 아무 이름이나 적어줍니다.   left, top 변수   두 개의 변수를 만들어 줍니다. 각각의 변수에는 (전체 스크린 한 면의 길이 - 내 팝업창 한 면의 길이) / 2 값이 할당됩니다. 그 값이 내 팝업창의 왼쪽 면의 위치, 위쪽 면의 위치가 됩니다.   window.open() 메서드   window.open() 메서드에 파라미터를 작성해 줍니다. 이때는 function에서 적어주었던 파라미터를 이용합니다. url, title은 똑같이 작성해 주고 resizable은 yes, width에는 function의 파라미터를 통과해서 들어온 w를 사용, height에는 h를 사용합니다. left와 top 변수도 사용합니다.   2. body 태그 부분 작성     &lt;body&gt;     &lt;ul&gt;         &lt;li class=\"signin-btn\" onclick=\"login_window('signin.html', 'Sign in to Otopi', '380', '500')\"&gt;&lt;span&gt;Sign in&lt;/span&gt;&lt;/li&gt;     &lt;/ul&gt;   &lt;/body&gt;  body 부분에 function을 사용할 곳에 function 이름과 파라미터를 사용하여 작성해 줍니다. 제가 만든 웹 페이지에서는 Sign in이라는 리스트를 클릭하면 팝업창이 생성됩니다. 클릭 시 function login_window가 실행됩니다. 파라미터를 통해 팝업창의 url, title, w, h의 크기를 전달합니다. 크기를 작성할 때 px을 적지 않도록 주의해 줍니다.   3. 가운데 정렬된 모습     ","categories": ["TIL"],
        "tags": ["learning","공부 기록","HTML","CSS","JavaScript"],
        "url": "/til/popup-center/",
        "teaser": "/assets/images/main_octopi.png"
      },{
        "title": "Playgrounds: Learn to Code 1",
        "excerpt":"Playgrounds: Learn to Code 1  아래 모든 내용들은 Playgrounds에서 학습하며 정리한 내용입니다.    모든 내용의 출처는 Playgrounds임을 밝힙니다.   Function: Grouping Tasks   Function은 여러개의 commands를 하나로 묶어 이름을 붙인 것입니다.    그리고 아무때나 원할 때 호출하여(call) 사용할 수 있습니다.     func tieMyShoe() {     loop()     swoop()     pull()   }      func 키워드 사용   function에 이름을 지어줍니다.   function은 언제나 이름 뒤에 ()를 붙여줍니다.   curly braces(중괄호 { }) 안에 commands를 추가해줌으로써 function이 어떤 기능들을 수행할지 정합니다.   필요할 때 언제든 tieMyShoe() 라는 이름을 사용하여 호출, 사용할 수 있습니다.   Composition   가끔씩 coding problem을 해결하려면 새로운 behavior을 수행하기 위해서 기존의 가지고 있던 commands를 혼합하여 함께 사용해야 할 떄가 있습니다. 이 과정을 compositon이라고 합니다. 원하는 행동을 수행할 command는 없지만 기존의 code를 합침으로써 원하는 행동을 할 수 있게 됩니다. 만약 여러번 같은 compositon을 수행해야 한다면 어떨까요? 그렇다면 여러개의 혼합된 코드를 여러번 사용하게 됩니다. 이럴때는 이 composition을 하나로 묶어 function으로 만들 수 있습니다.   function을 사용하므로써 코드를 간단하게 만들고 복잡한 일도 더 간단하게 처리할 수 있습니다.      반복되는 패턴을 파악합니다.   그 패턴을 function으로 만듭니다.   Decomposition   function 안에 다른 function을 호출할 수 있습니다. 더 큰 문제를 더 작은 조각으로 나누는 과정을 Decomposition이라고 합니다. 작은 일을 처리하는 function을 만들고 다른 funtion안에 그 functions을 사용하므로서 더 큰 문제를 해결하는 것 - 더 큰 문제를 작은 function으로 나누는 것을 Decomposition 이라 합니다.   Decompose a solution across multiple Function   작은 tasks를 해결하는 functions을 이용하는 것은 도움이 됩니다. 이 작은 일을 처리하는 function을 다른 function안에서 호출하므로써 더 큰 task를 해결 할 수 있게 됩니다. 더 작은 function으로 나누는 것은 코드의 가독성도 높여줍니다. 보통 function의 이름은 각 기능을 나타내도록 짓기 때문이죠.   또, 코드를 작성하는 과정을 단순화 시켜줍니다. 더 큰 task를 해결하기 위한 function을 작성한 뒤에는 작은 일을 처리하는 각각의 commands들은 신경쓰지 않을 수 있죠.      작은 명령 패턴을 찾는다.   명령들을 호출하는 function을 만든다.   만들어진 function으로 문제를 해결한다.   앱을 만든다는 것은 엄청나게 많은 작은 문제들의 해결방법을 찾는 것입니다. 작은 문제들의 해결책을 찾은 뒤에 코더들은 그 해결책을 모아 더 큰 문제를 해결합니다.   📖 틈새 영어 단어: Tweak      Tweak the code inside solveRow():     tweak은 작은 변화를 만든다는 뜻입니다.    For loops      ‘for’ 키워드를 사용합니다.   loop가 실행 될 횟수를 적어줍니다.   curly braces 안에 반복할 commands를 적어줍니다.     for eachSeed in 1...4 {     makeHole()     placeSeed()     moveFiveInchesForward()   }   앞서 coding tasks를 분할하기 위해 문제를 해결하며 반복되는 패턴을 function으로 만들어 보았습니다. 이제 loop를 이용하며 한 function을 여러 번 반복해서 호출할 수 있습니다. 어떤 코드를 순서대로 실행하는 것을 반복하는 것입니다. loops를 이용하면 반복해서 해야 할 일을 단순화 시킬 수 있습니다.      먼저 가장 가까이 있는 작은 문제를 해결할 패턴을 찾습니다.   다음 문제에서도 이 패턴이 적용되는지 알아봅니다.   적용이 된다면 반복합니다.   해결할 수 있는 작은 문제에 대한 해결책을 찾고 여러 개의 해결책을 모아 큰 문제를 해결하는 것은 좋은 문제 해결 방법 접근입니다.   Conditional Code   예상할 수 없는 것에 대해 어떻게 계획을 짤까요?    코드 안에서는 if문을 이용하여 각기 다른 조건들에 대한 계획을 짭니다.     if lightIsGreen {     moveForward()   } else {     wait()   }     ‘if’ 키워드를 사용합니다.   참 / 거짓으로 답할 수 있는 조건을 적어줍니다.   조건이 참(true)일 때 실행 할 commands를 if block 안에 적어줍니다.   조건이 false 일 때 실행될 코드는 else를 이용해서 적어줍니다.   메세지가 오’면’ 메세지가 왔다는 알림 소리가 울리고, 사파리는 웬 사이트를 열기 전에 인터넷이 연결되어 있는지 확인합니다. 연결되어 있다’면’ 웹사이트로 이동하죠.   Boolean condition   if - else문에서 if의 Boolean 조건이 true이면 if {} 안의 코드가 실행되고   false이면 else {} 안의 조건이 실행됩니다.     func solveRightSide() {     if isOnGem {       turnLeft()       collectGem()     }   }    for i in 1...2 {     solveRightSide()     moveForward()   }   위와 같은 방식으로도 사용할 수 있습니다. function안에 if문을 작성하고 for문을 이용해서 fuction을 호출하는 방식입니다. 이렇게 하므로써 코드를 재사용할 수 있습니다.   👷‍♂️ 여기까지 정리  Logical Operators   code에서 operator는 action을 보여주는 심볼입니다. 논리연산자는 조건문을 더 명확하게 특정지어줍니다.     &amp;&amp; (AND)                                               (OR)                           ! (NOT)   위의 각 연산자들은 각자의 방법으로 조건문을 변화시킵니다.      AND(&amp;&amp;) 논리 연산자는 모든 조건들이 true일 때만 코드가 실행됩니다.                                   OR(                       ) 논리 연산자는 조건 중 적어도 하나가 true일 때 코드가 실행됩니다.                           NOT(!) 논리 연산자는 조건을 반대로 만듭니다.   While Loops   While loop는 반복할 횟수가 명확히 정해져있지 않을 때 어떤 조건이 true인 동안 { } 안에 작성된 코드를 반복해서 실행합니다. 조건문과 함께 while 반복문을 사용하면 좀 더 다양한 상황에 문제를 해결할 수 있습니다.    때때로 coding problem을 어떻게 해결하는지는 어떤 옵션이 더 낫게 느껴지는지에 따라 정해집니다. coder들은 더 빠른 결과를 내는 해결책, 또는 재사용성이 높은 것이 어떤 것인지 자신의 의견에 기초에 결정하게 됩니다.   코딩에서는 문제와 여러개의 해결책들 중 어떤 것을 선택하는지에 대해 배우는 것이 중요합니다. 때때로 한 문제에 대한 어떤 접근은 다른 것과 비슷하게 문제를 해결하고 어떤 것은 다른 해결책보다 더 효율적이고, 재사용이 가능하고, 많은 상황에 적용 가능하기도 합니다. 적절한 도구(approprite tools)를 결정하는 힘이 길러집니다.   Land of bounty 다시 해보기  더 효율적인 방법 찾아보기   Nesting loops   nest one loop inside another은 루프안에서 다른 루프를 사용하는 것을 의미합니다. 루프 안에서 사용된 루프를 nested loops라고 합니다. 이때 바깥쪽의 루프를 Outer loop 안쪽의 루프는 inner loop라고 합니다. 다양한 상황에서 nested loops를 사용할 수 있습니다.   while loop와 Boolean 타입의 조건을 함께 사용할 때는 조건이 언제가는 false가 되야합니다. 만약 계속해서 true가 되면 무한 반복하는 infinite loop이 되고 이것은 컴퓨터를 멈추게 만들 수도 있습니다.      Algorithms   알고리즘은 규칙의 집합 그리고 그것을 기반으로 한 지시입니다. 예를 들어 네비게이션은 목적지로 가는 가장 빠른 길을 찾는 알고리즘을 이용합니다. 이때 알고리즘은 거리와 평균 속도를 비교하고, 현재의 교통량을 이용하여 가장 짧은 루트를 찾습니다. 알고리즘은 다양한 상황에서 적용 가능합니다.   알고리즘을 코드로 적용하기 전에 pseudocode를 이용하여 먼저 생각해볼 수 있습니다. pseodocode는 코드와 비슷한 형태이지만 진짜 코드는 아닌, 사람이 이해할 수 있는 언어로 만든 코드와 비슷한 구조를 가지고 있는 형태입니다.     navigate around wall {     if a block is on right side {       go forward     } else if blocks are in the front and on the right {       turn left       go forward     } else {       turn right       go forward     }   }   pseudocode의 예시입니다. 진짜 작동하는 코드아니고 알고리즘을 만들기 위해 생각을 코드의 구조로 나타낸 것입니다.   다른 상황에서 동일하게 적용되는 알고리즘을 만드는 것이 코딩의 힘입니다. 다양한 상황에서 문제를 해결하는 프로그램을 만드는 것이죠. 에를 들어 search engine의 algorithms은 우리가 검색한 단어가 무엇이든 원하는 정보를 주기 위해 엄청나게 많은 웹사이트의 정보를 동일한 방식으로 처리합니다.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","Playgrounds"],
        "url": "/til/playgrounds/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Navigating Apps: About Me",
        "excerpt":"Sample Apps Tutorials: About Me(Navigating Apps)  아래 모든 정보의 출처는 apple developer 공식 페이지이며 개인의 학습 용도로만 사용되었음을 밝힙니다.   All information below comes from the official apple developer page and is for personal learning purposes only.   Navigating Apps: About Me   Section 1: Tabbed Interface   탭 형태의 interface를 만드는 방법에 대해 알아봅니다.   ContentView view   ContentView view는 처음 앱이 열리면 보게 될 화면을 나타냅니다. User interface(UI)는 body부분에 생성됩니다.   TabView     struct ContentView: View {     var body: some View {       TabView {         // place tab views here!         HomeView()             .tabItem {               Label(\"Home\", systemImage: \"person\")             }       }     }   }   TabView를 사용해서 tab UI를 생성할 수 있습니다. Tab view 안에 원하는 tab item 목록을 작성해줍니다.   tab을 만들기 위해서…     tab을 눌렀을 때 보여지길 원하는 view의 instance를 생성합니다. 첫번째 tab이 앱을 열었을 때 가장 먼저 보이는 view가 됩니다.   HomeView view 아래에 dot notation을 이용하여 .tabItem modifier를 추가해줍니다. tabItem이 없다면 tab은 텅 비어있는 상태로 나타납니다.   Label view의 Title, Icon 패러미터를 이용하여 tab에 이름을 붙여주고 아이콘을 생성해줍니다. tabItem modifier는 오직 Label, Text, Image views만 허용합니다. Button과 같은 다른 view들은 비어있는 탭을 만듭니다.     Section 2: Your Data   app의 데이터를 수정하기   Data.swift   샘플 프로젝트에 app의 모든 Data만 따로 담은 파일이 있습니다. SwiftUI에서는 앱의 데이터를 앱의 visual components와 따로 분리하는 것이 가장 좋은 방법입니다. SwiftUI에 대해서 배우는동안 ‘“source of truth”를 가진다’라는 개념을 자주 접하게 될 것입니다. 이것은 한 value를 오직 한 장소에서만 정의한다는 의미입니다. 데이터를 변경해보며 이것에 대해 더 알아볼 것입니다.   데이터의 설계도     import Foundation   import SwiftUI    struct Info {       let image: String       let name: String       let story: string       let hobbies: [String]       let foods: [String]       let colors: [Color]       let funFacts: [String]   }    let information = Info(      )   struct Info { }는 앱 데이터의 설계도(또는 청사진, blueprint)를 제공합니다. 이것은 앱이 가지고 있는 데이터의 type과 이름을 정의하는 속성들(properties)을 가지고 있습니다. 위에 코드에서 알 수 있듯이 이 앱의 데이터는 String type의 story property와 Color 값들의 배열인 colors property를 가지고 있습니다. 이   Data value와 전역변수     import Foundation   import SwiftUI    struct Info {       let image: String       let name: String       let story: string       let hobbies: [String]       let foods: [String]       let colors: [Color]       let funFacts: [String]   }    let information = Info(       image: \"Placeholder\",       name: \"Future\",       story: I'll be an awesome developer.\\n• 🐶🐱🛶️🎤🎧\\n•       🏄‍♀️♀️🥾🏂⛷📚 \",       hobbies: [\"bicycle\", \"ticket.fill\", \"book.fill\"],       foods: [\"🥐\", \"🌮\"],       colors: [Color.blue, Color.purple, Color.pink],       funFacts: [           \"The femur is the longest and largest bone in the human body.\",           \"White sand beaches are made of parrotfish poop.\",       ]   )   위의 information value는 데이터를 담기 위해 Info structure을 사용합니다. 이것은 전역 변수(global variable)로 프로젝트안 어떤 폴더에서든 변수의 이름을 사용하여 이용할 수 있습니다.   The source of truth   위에서 information의 name에 값을 주었다. name의 값은 딱 한 번 만 생성되고 이것은 source of truth를 만든다. 언제든, 어떤 component, 어떤 view에서든 name을 사용하고 싶다면    information.name  이라는 이름을 이용하여 조회할 수 있다.   Section 3: Home Tab   기본적인 SwiftUI 코드에 대해 알아봅니다.   HomeView.swift   이 프로젝트에서 HomeView는 첫번째 탭에 해당됩니다. 첫번째 탭은 앱을 처음 열었을 때 보게 되는 화면입니다. HomeView view의 body부분에는 화면에 그려지는 컨텐츠들이 작성됩니다.     var body: some View {         VStack {             Text(\"All About\")                 .font(.largeTitle)                 .fontWeight(.bold)                 .padding()              Image(information.image)                 .resizable()                 .aspectRatio(contentMode: .fit)                 .cornerRadius(10)                 .padding(40)              Text(information.name)                 .font(.title)         }     }   Views와 Modifiers      VStack: VStack은 컨텐츠를 화면의 위에서 아래로, 수직 방향으로 배치합니다.   Text(“string”): quotation marks 안에 있는 문자열을 화면에 보여줍니다. Text의 스타일을 바꾸기 위해 modifiers를 사용했습니다. (.font()/.fontWeight())   .padding(): 서로 다른 view들 사이에 각 view를 둘러싼 공간을 추가합니다. 괄호안에 값을 적지 않으면 SwiftUI의 기본 패딩이 적용됩니다. 값을 넣어 커스텀할 수 있습니다.   Image(): 여기서 Image view는 Data file에서 바꿔주었더너 이미지를 보여줍니다. information.image 라는 이름을 사용하나 것이 보입니다.   .resizable: resizable modifier는 화면에 사용 가능한 공간에 이미지를 적용시킵니다. 만약 resizable modifier를 사용하지 않으면 이미지의 full size로 나타나게 됩니다.   .aspectRatio: image가 원래의 비율로 유지되도록 합니다. .fit으르 사용하면 SwiftUI가 사용가능한 공간에 맞는 사이즈로 이미지 사이즈를 변경합니다. (.fill은 화면을 채우는 방식)   .cornerRadius: 어떠 view든 모서리를 둥그렇게 만들 수 있습니다.   Section 4: Story Tab   스크롤 뷰를 이용하는 방법에 대해 알아봅니다.   ScrollView   Text의 문자열이 너무 길어져서 한 화면에 담지 못하게 되면 ScrollView를 사용하여 스크롤 할 수 있습니다.    ScrollView {      Text(information.story)          .font(.body)          .padding()        }  information.story는 Data file에서 입력했던 story를 담고 있습니다.   Section 5: Favorite Tab   여러개의 다른 stacks와 loops를 사용해서 UI 만들기   ForEach(_:)     HStack {       ForEach(information.hobbies, id: \\.self) { hobby in           Image(systemName: hobby)               .resizable()               .frame(maxWidth: 80, maxHeight: 60)        }       .padding()   }   .padding()  여기서 ForEach문은 Data file의 information.hobbies 배열의 각 item들을 id: \\.self로 구분하여 접근합니다.   ##13 Section 6: Fun Facts Tab   랜덤으로 정보를 화면에 띄우는 버튼을 추가해서 interactive한 앱을 만들어 봅니다.   Button view   이 챕터에서는 Button을 누를때마다 다른 문자열 정보를 화면에 출력하는 방법에 대해 알아봅니다.     @State private var funFact = \"\"    var body: some View {     VStack {       // 다른 컨텐츠들 생략        Text(funFact)           .padding()        Button(\"Show Random Fact\") {         funFact = information.funFacts.randomElement()!       }     }     .padding()   }  funFact 변수가 @State를 사용하고 있기 때문에 fucFact를 사용하고 있는 Text view는 funFact의 변수에 값이 변경될 때마다 자동으로 업데이트 됩니다.   Button을 탭할 때마다 funFact에 랜덤 값을 할당합니다. funFact변수에 값이 바뀌므로 Text view의 값도 변하게 됩니다.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","Sample Apps Tutorials"],
        "url": "/til/aboutMe/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Navigating Apps: Choose Your Own Story",
        "excerpt":"Sample Apps Tutorials: Choose Your Own Story(Navigating Apps)  아래 모든 정보의 출처는 apple developer 공식 페이지이며 개인의 학습 용도로만 사용되었음을 밝힙니다.  All information below comes from the official apple developer page and is for personal learning purposes only.   Choose Your Own Story   Views 사이에서 동적으로 변화하는 navigation에 대해 알아봅니다.   사용자의 선택에 따라 다른 페이지로 이동하는 이야기를 만들어봅니다.     Section 1: Create Your Own Story   당신만의 이야기 속 사건들을 구축하기 위해서 앱은 Story라는 instance가 필요합니다. 이 프로젝트에서 instance Story는 각 StoryPage는 이야기 부분과 선택지 부분으로 이루어져 있습니다.     // MyStory.swift    let story = Story(pages: [     StoryPage(       \"\"\" 이야기 부분 \"\"\"        choices: [           Choice(text: \"Front row!\", destination: 1),           Choice(text: \"Find somewhere in the middle\", destination: 1)           Choice(text: \"Back of the room\", destination: 2),            ]         ),       ]     )     // 위의 방식으로 StoryPage가 page20까지 Story의 배열 타입 패러미터로 작성되어 있습니다.  이야기 부분을 읽고 -&gt; 선택 -&gt; 페이지로 이동됩니다. 이동된 페이지에서도 마찬가지로 이야기 부분을 읽고 -&gt; 선택 -&gt; 해당 페이지로 이동합니다.   세개의 quotation marks   ””” “”” : String 값을 생성하는 특별한 방법입니다. 이 방법을 이용하면 여러 줄의 글을 쓸 수 있고 quotation marks도 사용할 수 있기 때문에 이야기와 같은 긴 글을 쓸 때 유용하게 사용할 수 있습니다.   The destination property   Choice의 destination property는 story navigation 앱의 키 요소입니다. destination의 숫자 값은 페이지의 index 번호입니다. 인덱스는 0부터 세기 때문에 1페이지는 0, 2페이지는 1의 식으로 숫자가 적용됩니다.   Section 2: Story Data Model   위에서 작성한 Story data를 구조화하는 방법에 대해 알아봅니다.   StoryModels.swift   이 앱에서는 Story라는 custom type을 이용합니다. Story의 instance를 생성해 스토리 페이지를 화면에 출력합니다. 각 페이지는 이야기 부분과 몇 개의 선택지로 이루어져 있습니다.     // StoryModels.swift    import Foundation    struct Story {      let pages: [StoryPage]      subscript(_ pageIndex: int) -&gt; StoryPage {       return pages[PageIndex]     }   }    struct StoryPage {     let text: String      let choices: [Choice]      init(_ text: String, choices: [Choice]) {       self.text = Text       self.choices = choices     }   }    struct Choice {     let text: String     let destination: Int   }   ☑️ What I Learned From This Part:       1. Custom Type 생성 과정            2. Custom type을 만드는 file에는 Foundation만 import하면 됨.            3. init()의 이름을 사용하지 않는 패러미터        init(_ text: String) -&gt; text는 패러미터의 이름일 뿐 생성자가 사용될 때 사용하는 이름은 아님. 이 경우에는 생성자 사용시 이름없이 바로 “”” “”” 으로 문자열을 입력해주었음.     StoryPage type   또 다른 custom type인 StoryPage는 이야기 부분인 text 상수 속성과 선택지 부분인 choices 배열 속성 부분으로 이루어져 있습니다. choices 배열은 사용자를 각 선택마다 다른 페이지로 이동시켜줍니다.   Choice type   Choice type도 custom type입니다. 선택지 버튼에 나타나는 문자열 부분과 페이지 인덱스 부분인  Int type의 destination 속성으로 이루어져 있습니다.   Section 3: Creating a Navigation view   StoryView.swift     // StoryView.swift    import SwiftUI    struct StoryView: View {      var body: some View {       NavigationView {         StoryPageView(story: story, pageIndex: 0)       }       .navigationViewStyle(.stack)     }   }    sturct ContentView_Previews: previewProvider {     static var previews: some View {       StoryView()     }   }   NavigationView   StoryView는 이 앱의 top-level view입니다. 맨 처음 앱이 실행되면 보이는 view이죠. 각각의 story page를 화면에 보여주고 페이지 사이를 이동하기 위해서 NavigationView를 이용합니다. NavigationView view는 각 스토리 페이지를 담는 컨테이너와 같습니다. 한 장의 스토리 페이지를 보여주고 Navigation Link가 탭 될 때마다 다른 페이지로 변경됩니다.   NavigationView는 StoryPageView라는 콘텐츠를 가지고 있고 그것을 화면에 보여줍니다. 여기서 이용된 story는 MyStory Data file에서 전역변수로 만들어주었습니다. story 안의 StoryPage 중 pageIndex: 0을 사용하여 첫 번째 페이지를 보여줍니다.   Section 4: Displaying a Story Page   StoryPageView.swift     // StoryPageView.swift    import SwiftUI    struct StoryPageView: View {      let story: Story     let pageIndex: Int      var body: some View {       VStack {           ScrollView{             Text(story[pageindex].text)           }            ForEach(story[pageIndex].choices, id: \\Choice.text) { choice in               NavigationLink(destination: StoryPageView(story: story, pageIndex: choice.destination)) {                 Text(choice.text)                     .multilineTextAlignment(.leading)                     .frame(maxWidth: .infinity, alignment: .leading)                     .padding()                     .background(Color.gray.opacity(0.25))                     .cornerRadius(8)                 }}       }       .padding()       .navigationTitle(\"Page \\(pageIndex + 1)\")       .navigationBarTitleDisplayMode(.inline)     }   }   앱의 스토리를 화면에 출력하기 위해서 Story type을 사용합니다. Story type은 이야기에 대한 모든 정보들을 담고 있습니다. 이야기에 대한 데이터를 변경하려면 MyStory Data file로 이동해 story 전역변수에 담긴 내용을 수정해 줍니다.   VStack을 이용해서 text / choices를 수직으로 배치합니다. 이야기 부분에는 ScrollView를 사용함으로써 많은 내용을 담더라도 스크롤을 이용해 화면에 모두 보일 수 있도록 합니다. pageIndex는 현재 페이지의 index 번호를 나타냄으로 Text(story[pageIndex].text)는 현재 페이지의 text 부분을 가져와 화면에 보여줍니다.   ForEach structure   ForEach view는 여러 개의 view를 생성할 때 사용됩니다. 여기서는 현재 페이지의 choices 배열을 화면에 보여줍니다. 배열은 각각 선택지를 담고 있습니다. 선택지가 3개라면 3개의 버튼을, 4개라면 4개의 NavigationLink를 만듭니다. { } 안의 코드를 배열의 각 item마다 반복하기 때문에 같은 형태의 NavigationLink를 만듭니다.   id argument   SwiftUI는 배열의 각 item을 분리, 구별하기 위해서 id argument를 사용합니다. 여기서는 각 choice가 다른 text를 가지고 있기 때문에 text를 id로 사용합니다.   NavigationLink   NavigationLink는 두가지가 필요합니다.     destination(여기서는 스토리 페이지)   화면에 출력할 content(여기서는 선택지 Text)   이 앱에서 NavigationLink의 destination은 각 선택지가 연결되어 있는 페이지 입니다.     NavigationLink(destination: StoryPageView()) {        // 이곳에 화면에 출력될 content code를 작성합니다.    }   Navigation links는 NavigationView 아래서만 작동합니다.   Aligning Text     Text(choice.text)       .multilineTextAlignment(.leading)       .frame(maxWidth: .infinity, alignment: .leading)       .padding()       .background(Color.gray.opacity(0.25))       .cornerRadius(8)     multilineTextAlignment(.leading)는 여러줄의 text를 정렬하는 modifier입니다. leading은 왼쪽 정렬입니다.   frame은 보이지 않은 frame에 text를 담습니다. maxWidth값에 .infinity로 주면 frame은 가능한 가장 넓은  width값을 가지게 됩니다.   alignment: .leading은 frame 안에 있는 text를 왼쪽 정렬합니다.   Navigation Bar     } // VStack 끝나는 부분   .padding()   .navigationTitle(\"Page \\(pageIndex + 1)\")   .navigationBarTitleDisplayMode(.inline)      VStack 아래에 다른 콘텐츠나 스택이 없는 상황에서. .padding()을 주면 화면 안에서 VStack 주변에 적절한 양의 padding을 줍니다. 패딩을 주지 않으면 콘텐츠들이 화면에 딱 붙어서 보입니다.   아래쪽 modifier 두 개는 view가 NavigationView 아래에 사용되었을 때 적용됩니다. Navigation view는 navigation bar를 제공합니다. Navigation Bar에는 title과 뒤로 가기 버튼이 기본적으로 주어집니다. Extra button이나 text와 같은 커스텀 가능한 다른 아이템들도 있습니다.      .navigationTitle modifier를 이용해서 현재 페이지의 번호를 화면에 출력할 수 있습니다.        .navigationBarTitleDisplayMode로는 타이틀의 크기와 나타나는 스타일을 바꿀 수 있습니다. inline은 더 작은 글씨로 나타나게 합니다. automatic과 large도 선택할 수 있습니다. (적용해 보니 automatic과 large 둘이 똑같이 나옵니다. 더 큰 사이즈에 글자로 왼쪽 정렬해서 텍스트 안의 head부분처럼 보이네요.)            ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","Sample Apps Tutorials"],
        "url": "/til/chooseYourOwnStory/",
        "teaser": "/assets/images/choose2.png"
      },{
        "title": "Navigating Apps: Date Planner",
        "excerpt":"Sample Apps Tutorials: About Me(Navigating Apps)  아래 모든 정보의 출처는 apple developer 공식 페이지이며 개인의 학습 용도로만 사용되었음을 밝힙니다.   Section 1: App Configuration   앱이 views들 사이에서 데이터를 공유하는 방법      하나의 데이터 object를 만든다.   전체 view hierachy에서 object를 사용한다.   DatePlannerApp.swift     // DatePlannerApp.swift    import SwiftUI    @main   struct DatePlannerApp: App {       @StateObject private var eventData = EventData()      var body: some Scene {       WindowGroup {         NavigationView {             EventList()             Text(\"Select an Event\")                 .foregroundStyle(.secondary)         }         .environmentObject(eventData)       }     }   }  NavigationView      서로 다른 views를 이동하기 위해 NavigationView를 사용합니다.   NavigationView 아래에는 앱의 home view가 작성됩니다.   이 앱의 첫화면이자 home view는 EventList() 입니다.   iPad의 가로 화면과 같은 더 넓은 앱화면 구성에서, SwiftUI는 NavigationView를 이용할 때 여러개의 컨텐츠를 하나의 스택이 아닌 나란한 행들로 화면에 나타냅니다. 이 앱에서 EventList는 하나의 sidebar column에 나타납니다. 각 컨텐츠는 primary pane에 나타납니다.      var eventData     @StateObject private var eventData = EventData()   이 앱은 eventData라는 이름의 변수에 데이터를 저장합니다. eventData 변수는 @StateObject wrapper와 함께 observable object인 EventData의 instance를 만듭니다. SwiftUI는 observable object에 일어나는 변화를 추적합니다. 만약 변화가 생기면 SwiftUI가 자동으로 이 object를 사용하는 view를 업데이트 합니다.     } // NavigationView 끝   .environmentObject(eventData)   eventData를 전체 view 계층에서 사용하기 위해서 .environmentObject와 eventData instance를 사용합니다. 이것을 사용하므로써 앱의 모든 navigation view의 child views들 그리고 child view의 child view까지 이 데이터를 사용할 수 있게 됩니다.   Section 2: Event Model   아래에서 Event model은 이벤트를 구성하고 시각화하기 위해 필요한 모든 데이터를 가지고 있습니다.    Event 모델을 구성하는 방법에 대해 알아봅니다.   Event.swift     // Event.swift    import SwiftUI    struct Event: Identifiable, Hashable {     var id = UUID()     var symbol: String = EventSymbols.randomName()     var color: Color = ColorOptions.random()     var title = \"\"     var tasks = [EventTask(text: \"\")]     var date = Date()      var remainingTaskCount: Int {         tasks.filter { !$0.isCompleted }.count     }      var isComplete: Bool {         tasks.allSatisfy { $0.isCompleted }     }      var isPast: Bool {         date &lt; Date.now     }      var isWithinSevenDays: Bool {         !isPast &amp;&amp; date &lt; Date.now.sevenDaysOut     }      var isWithinSevenToThirtyDays: Bool {         !isPast &amp;&amp; !isWithinSevenDays &amp;&amp; date &lt; Date.now.thirtyDaysOut     }      var isDistant: Bool {         date &gt;= Date().thirtyDaysOut     }    }    Event planner는 데이터를 분류, 구성하기 위해서 여러개의 Event object의 모음(collection)을 사용합니다. 각각의 Event object는 캠핑, 여행, 생일파티와 같은 특정 이벤트를 나타냅니다.      Identifiable protocol은 이벤트의 리스트를 생성할 때 SwiftUI가 이벤트의 값을 다른 것들과 확실히 구별하고 그것을 업데이트 해줍니다.   📖 틈새 영어 단어: populate        The Event type contains all of the information you need to populate an event.       컴퓨터에서 데이터 베이스나 테이블에 정보를 입력하는 것을 말합니다.      Event Type    struct Event: Identifiable, Hashable {     var id = UUID()     var symbol: String = EventSymbols.randomName()     var color: Color = ColorOptions.random()     var title = \"\"     var tasks = [EventTast(text: \"\")]     var date = Date()   }  Event type은 하나의 이벤트를 만들기 위한 모든 정보를 가지고 있습니다. 심볼과 색, 이벤트의 이름, 이벤트 안에서 수행해야 할 tasks와 날짜입니다. task는 이벤트를 누르면 to-do 형식으로 나타납니다.   Computed properties   Stored properties 아래에는 computed properties가 있습니다. Computed properties는 날짜나 수행한 task 수를 기반으로 이벤트를 정렬할 수 있도록 합니다.     var isPast: Bool {     date &lt; Date.now   }  에를 들어 위의 isPast property는 현재 날짜, 시간보다 이벤트의 날짜 시간이 적으면 true를 반환합니다. 이것을 이용해 사용자들은 과거 이벤트를 위한 카테고리에 지난 이벤트들을 모아둘 수 있습니다.   UUID()   참고한 페이지   a Universally Unique Identifier의 약자입니다.   정적인 view를 만들때는 SwiftUI가 어떤 뷰를 우리가 이용하고 있는지 알고, 여러가지 작업을 할 수 있습니다. 하지만 우리가 동적인 view를 만들기 위해서 List나 ForEch문을 사용하면 SwiftUI는 각 아이템들을 구별할 방법이 필요해집니다. 이때 사용할 수 있는 것이 UUID()입니다.   Section 3: Event Task   하나의 EventTask는 하나의 to-do 아이템을 나타냅니다. 이 챕터에서는 어떤 방식으로 task 부분을 구성하는지 알아봅니다.   EventTask.swift     // EventTask.swift      import SwiftUI    struct EventTask: Identifiable, Hashable {     var id = UUID()     var text: String     var isCompleted = false     var isNew = false   }   Event type과 마찬가지로 EventTask type 역시 Identifiable protocol을 따릅니다. 이것은 SwiftUI이 리스트 속 to-do 아이템의 모양을 관리하고 업데이트 할 수 있도록 합니다. EventTask type은 id, text, isComplete, isNew와 같은 to-do 아이템의 속성들을 가지고 있습니다.   Section 4: Event Data   앱의 event list에 정보를 입력하기 위해 observable object인 EventData를 사용합니다. 그리고 어떻게 데이터의 구조를 구성하고 업데이트하는지 알아봅니다.   EventData type     // EventData.swift   import SwiftUI    class EventData: ObservableObject {       @Published var events: [Event] = [           Event(symbol: \"gift.fill\",                 color: .red,                 title: \"Future's Birthday\",                 tasks: [EventTask(text: \"Wine\"),                         EventTask(text: \"Cheese plate\"),                         EventTask(text: \"Something too sweet\"),                         ],                 date: Date.roundedHoursFromNow(60 * 60 * 24 8 30)),           Event(symbol: \"theatermasks.fill\",                 //위와 같은 내용)       ]   }      EventData type은 어플에 나타나는 모든 이벤트를 저장하고 수정합니다.   ObservableObject protocol을 따릅니다. -&gt; EventData에 있는 published values 중 어떤 것에든 변화가 일어나면 SwiftUI가 그 values를 사용하고 있는 view들을 찾고 업데이트 해줍니다.   events property      EventData는 events라는 property를 가지고 있습니다. events는 Event라는 배열을 가지고 있습니다. (배열들은 미리 여러개의 이벤트 값이 입력되어 있습니다.)   @Published property wrapper는 events 배열에 변화가 일어날때마다 SwiftUI가 변화를 인지하고 그 배열을 사용하는 view들을 업데이트 하게 합니다. 이것은 배열로부터 이벤트를 추가하거나 삭제하면 바로 UI에 보여지도록 합니다.   EventData의 메서드       ] // events 속성의 배열 끝부분      func delete(_ event: Event) {       events.removeAll { $0.id == events.id }     }    }   removeAll(where:)   removeAll(where:) 메서드는 기준에 부합하는 집합의 모든 요소들을 삭제하는 메서드입니다.    ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","Sample Apps Tutorials"],
        "url": "/til/datePlanner/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Guided Swift Tour: 스위프트 기초 문법",
        "excerpt":"A Swift Tour 아래 모든 정보의 출처는 Swift 공식 문서이며 개인의 학습 용도로만 사용되었음을 밝힙니다.  All information below comes from the Swift documentation and is for personal learning purposes only.   문자열과 변수의 값     &lt;sub&gt;아래 모든 정보의 출처는 apple developer 공식 페이지이며 개인의 학습 용도로만 사용되었음을 밝힙니다.     All information below comes from the official apple developer page and is for personal learning purposes only.&lt;/sub&gt;   ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","Sample Apps Tutorials"],
        "url": "/til/guidedTour/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Swift: Playgrounds",
        "excerpt":"Learn to code 2  아래 모든 내용들은 Playgrounds에서 학습하며 정리한 내용입니다.    모든 내용의 출처는 Playgrounds임을 밝힙니다.   Variables   머리로 기억할 수 있는 것보다 더 많은 연락처를 저장한 스마트폰의 연락처 목록을 떠올려 봅시다. Coder는 변수(Variables)라는 컨테이너에 이름을 붙이고   정보를 담습니다. 우리가 수정하기 전까지는 연락처의 정보가 바뀌지 않듯 Variables의 정보는 우리가 변경하기 전까지 스스로 바뀌지 않습니다.     var name = \"Mia\"   var age = \"28\"      var 키워드를 사용합니다.   변수의 이름(name, age)이 필요합니다.   = (assignment operator, the equal sign)은 변수에 값을 할당합니다.   위의 변수 중 name은 String을 담고 있습니다. (“text”)   위의 변수 중 age는 Int(an integer, a whole number)를 담고 있습니다.   📖 틈새 영어 단어: a whole number        whole numbers       0을 포함한 자연수를 말합니다.       0, 1, 2, 3, 4, ....       변수를 할당한 뒤 다른 값을 할당할 수 있지만 자료형은 처음 할당한 값과 같아야 합니다. 만약 처음 String 타입의 자료를 담았다면 그 변수에는 게속해서 String 타입의 자료형을 담아야 합니다.     var age = 28   age = \"twenty-nine\" // 자료형이 다름으로 불가능   incrementing a value   incrementing a value는 현재 값과 비교하여 값을 증가시키는 코딩 패턴입니다.    var myNum = 0   myNum = myNum + 1  variable을에 할당된 수와 비교 연산자를 이용해서 while문의 Boolean 조건을 만들 수 있습니다. incrementing values 하며 반복 횟수 등을 기록할 수 있습니다.   변수 이름 정하기      camelCase: 첫번째 단어는 소문자로 시작 뒤로 이어지는 새 단어들은 대문자로 시작하도록 쓰는 방법입니다.   변수에 담길 값이 무엇인지 알려주는 이름으로 정합니다.   Constant   Constant(상수)는 variable(변수)와 같이 값을 담는 이름 붙인 컨테이너입니다. 하지만 프로그램이 실행되는 동안에는 값을 변경할 수 없다는 차이점이 있습니다.      ‘let’ 키워드를 사용합니다.   값이 변경되지 않는다는 것을 아는 경우 상수를 사용합니다.     let numberOfTries = 3   변수의 값과 상수의 값을 비교하는 식의 코드가 자주 사용됩니다.   Compound assignment operator     gemCounter = gemCounter + 1   gemCounter += 1   자료형(Types)   집을 지을 때는 blue print를 사용합니다. Blue print는 거실, 화장실, 침실과 같은 집의 기능들을 보여줍니다. 여러개의 집들을 지을 때 한 blue print를 이용한다면 그 집들은 모두 비슷한 모양으로 지어질 것입니다.   프로그래밍에서 type은 blue print와 같습니다. 그리고 instance는 blue print를 통해 지어진 집과 같습니다.   Blue print는 집의 특징(feature)과 작동 방식(behavior)을 알려줍니다.   Type에서 features는 properties라고 부르고 작동 방식(behavior)는 method라고 합니다.     Features: Color, Bedromms    var color = green   var bedrooms = 2    // property는 타입안에서 변수입니다.    Behaviors: Run Water, Turn on Lights    runWater()   turnLightsOn()    // method는 타입안에서 function입니다.   우리가 만든 여러개의 집중 하나의 차고를 열고 싶다고 가정해봅니다. 먼저 우리는 어떤 집인지 이름을 통해 지정합니다.     myHouse.openGarageDoor()  Swift에서 .(dot notation) 앞부분인 myHouse는 특정한 집을 가리키는 instance입니다.   . 뒷부분은 openGarageDoor()라는 myHouse의 메서드입니다.     bluePortal.isActive() = false  bluePortal이라는 인스턴스의 isActive()라는 메서드가 bluePortal을 켠다고 가정했을 때 ‘= false’는 bluePortal을 끕니다.   Using dot notation syntax   컴퓨터가 이해할 수 있는 코드를 작성하는 규칙을 syntax라고 합니다. Dot notation systax는 아래와 같이 생겼습니다.    greenPortal.isActive = true  Dot notation을 이용하면 특정 instance의 properties의 상태를 변경시킬 수 있습니다. 때때로 프로그램 안에서 여러번 instance의 propert의 상태를 변경해야합니다. greenPortal은 instance의 이름이고 isActive는 greenPortal의 property입니다.   State   State는 어떤 주어진 특정 시간에 변수에 담긴 정보를 말합니다.   instance에 이름을 부여하고 이름으로 그것을 나타내는 것은 프로그램 안에서 인스턴스의 요소들을 이용할 수 있게 해줍니다.   더 효율적인 문제 해결법을 찾는 것은 프로그램이 더 빠르게 작동한다는 것이고 그것은 사용자들이 앱을 사용할 때 행복해진다는 것입니다. 그리고 배터리가 얼만큼 오래 보존되는지와도 관련이 있습니다.   Factoring   코드를 효율적으로 작성하는 방법에 대해 생각해보는 것은 중요합니다. 작동하는 방식을 작은 단위로 나누어 재사용 가능한 function을 작성한다면 전체적으로는 더 적은 라인의 수로 코드를 작성할 수 있습니다. 이런 것을 factoring 코드라고 합니다. factoring the code는 재사용성을 높여줄 뿐 아니라 코드의 가독성을 높여주어 작성자 뿐 아니라 다른 누구든 코드가 어떻게 작성된건지 알아보기 쉽게 해줍니다.   //👷‍♂️ Learn to Code 2: Random Gems Everywhere 다시 풀기   Initialization   Initialization을 통해 instance를 만들 수 있습니다.     let expert = Expert()     let 키워드를 사용하여 constant를 생성합니다.   Type의 이름 + ()를 우측에 작성하여 초기화(Initialize) 합니다.     expert.turnLockUp()  expert라는 instance의 메서드 turnLockUp()을 호출하는 방식입니다. dot notation을 사용합니다. 메서드를 사용하기 위해서는 먼저 Initialize 해주어야 한다는 것을 기억합시다.   여러개의 instances   코드를 작성할 때는 큰 문제를 해결하기 위해 보통 여러개의 instance와 element를 함께 사용하게 됩니다. 만약 사진 편집 앱을 만든다면 이미지를 촬영하기 위해 카메라 앱을, 효과를 적용하기 위해 필터 라이브러리를 사용할 것입니다.   하나 이상의 instance를 사용할 때는 instance의 이름을 사용하여 각 instance의 메서드를 호출합니다.   Parameters   집을 여러가지 색으로 페인트 칠한다고 상상해 봅니다. 그렇다면 색마다 각기 다른 메서드를 만들 수 있겠죠.    paintGreen()   paintBlue()   paintOrange()  만약 초록색 페인트로 세 레이어에 걸쳐 색을 칠하고 싶다면 아래처럼 세번 paintGreen() 메서드를 호출할 수 있습니다.    paintGreen()   paintGreen()   paintGreen()   각 색마다 function을 만들어 사용하  대신에 Parameter를 이용해서 원하는 색을 사용할 수 있습니다.    func paint(color: Color)  color parameter는 function의 input value입니다. 패러미터는 Color와 같은 특정한 Type을 가집니다. function을 호출하면 작동방식 중 사용할 argument를 통과 시킵니다.    func paint(color: Color, layers: 3)  여러개의 패러미터를 가질 수 있습니다.     func move(count: Int) {     for i in 1...count {       moveForward()     }   }  Int Type의 count라는 패러미터를 가진 function move입니다. count는 function의 바디 부분에서 for문이 얼만큼 반복될지를 특정합니다. move function을 호출 시    move(count: 3)  argument 3을 통과시킴으로써 for문을 세번 돌릴 수 있게 됩니다.   여러개의 parameter를 이용하며 function이 동작하는 중 많은 부분을 커스터마이징 할 수 있습니다. 몇 번 반복문을 동작시킬지, Bool타입을 이용한다면 동작을 시킬지 시키지 않을지 등 많은 부분을 원하는대로 특정 지을 수 있습니다.   문제를 해결하며 작성해 본 예제 코드      let expert = Expert()    let character = Character()     var gemCount = 0     func turnMethod(up: Bool, times: Int) {        if up == true {            for i in 1...times {                expert.turnLockUp()            }            expert.turnRight()        } else {            for i in 1...times {                expert.turnLockDown()            }            expert.turnRight()        }    }     for i in 1...4 {        turnMethod(up: true, times: 4)    }     while gemCount != 3 {        if character.isOnGem {            character.collectGem()            gemCount += 1            character.turnRight()         }        character.moveForward()    }     for i in 1...4 {        turnMethod(up: false, times: 3)    }     while gemCount &lt; 7 {        if !character.isBlockedRight &amp;&amp; gemCount &gt; 5 {            character.moveForward()        } else if character.isBlockedRight &amp;&amp; character.isBlockedLeft{            character.moveForward()        } else if !character.isBlockedRight {            character.turnRight()            character.moveForward()        } else if character.isBlockedRight &amp;&amp; gemCount == 6 {            character.moveForward()        }         if character.isOnGem {            character.collectGem()            gemCount += 1            character.turnLeft()            character.turnLeft()            character.moveForward()        }    }  (패러미터를 이용한 funtion의 이용을 공부하며 작성해본 예제입니다. 더 적은 라인의 코드로 문제를 해결할 수 있을 것 같은데 아직은 자꾸만 코드가 길어집니다.)   Type과 Instances   하나의 type을 이용해 여러개의 instance를 만들 수 있습니다. type은 설계도, 청사진에 자주 비유됩니다. 같은 설계도를 사용해서 만든 instance이므로 같은 메서드를 사용해 같은 속성들에 접근, 이용할 수 있습니다.   World Building     let block1 = Block()   let block2 = Block()   let block3 = Block()   let block4 = Block()   let block5 = Block()    var gemCounter = 0    func stackBlocks(block: Block, col: Int, row: Int) {           world.place(block, atColumn: col, row: row)   }   func turnAround() {       turnLeft()       turnLeft()   }   func moveAndCollect(times: Int) {       for i in 1...times {           moveForward()           if isOnGem {               collectGem()               turnAround()           }       }   }    // stack blocks to get gems   stackBlocks(block: block1, col: 2, row: 2)   stackBlocks(block: block2, col: 2, row: 2)   stackBlocks(block: block3, col: 4, row: 2)   stackBlocks(block: block4, col: 6, row: 2)   stackBlocks(block: block5, col: 6, row: 2)    while gemCounter &lt; 3 {       moveForward()       if isOnClosedSwitch {           toggleSwitch()           turnRight()       } else if isBlocked &amp;&amp; isOnGem {           collectGem()           gemCounter += 1           turnAround()       } else if isOnOpenSwitch &amp;&amp; gemCounter &gt;= 1{           turnRight()       }   }  (여러개의 instance 사용 / factor codes into a function을 공부하며 작성한 예제. 처음 작성했을때는 else if가 세개 더 있었는데 문제를 해결하며 코드를 줄일 수 있었다.)   Array      [] = square brakets   , = a comma   위 두가지를 이용하여 배열(Array)를 만듭니다.     var ingredients = [icecream, bananas, chocolate, cherries]   배열은 아이템을 순서대로 나열한 목록입니다. 순서는 Index로 표현합니다. Index를 이용하여 각 item을 변경할 수 있습니다.     [icecream, bananas, chocolate, cherries]       0         1         2          3    ingredients[1] = strawberries   ingredients[3] = sprinkles    [icecream, strawberries, chocolate, sprinkles]       0           1            2          3   컴퓨터는 0부터 수를 세기 때문에 index 역시 0부터 시작합니다.   Array Methods   Swift에는 아이템을 삭제, 추가하는 등 간단한 동작을 수행하기 위해 array와 함께 사용되는 메서드가 있습니다.     [icecream, bananas, chocolate, cherries]       0         1         2          3    // remove(at: index numbers) 메서드   ingredients.remove(at: 2)    [icecream, bananas, cherries]       0         1         2    // append() 메서드   ingredients.append(sprinkles)    [icecream, bananas, cherries, sprinkles]       0         1         2         3    // insert(item, at: index number)   ingredients.insert(strawberries, at: 1)    [icecream, strawberries, bananas, cherries, sprinkles]       0            1         2         3          4  item이 추가, 삭제됨에 따라 index 번호가 자동으로 바뀝니다.   Iteration   배열에 담긴 각 아이템마다 같은 동작을 반복할 수 있습니다. 이런 과정을 iteration 이라고 합니다.     for item in ingredients {     place(item, in: bowl)   }   위 코드는 각 item 마다 place(item, in: bowl) 이라는 코드를 반복하며 수행합니다.     Code comments   // 를 이용하면 주석(code comments)를 작성할 수 있습니다. 주석은 코드의 대한 정보를 제공합니다. 앱을 이 코드를 실행하지 않습니다.   Item의 자료형   한 array안의 자료들은 모두 같은 자료형을 가지고 있어야 합니다.   만약 처음 integer 자료형의 배열을 만들었다면 String 아이템은 추가할 수 없습니다.   For-in loop     let columns = [0, 1, 2, 3, 4]    for i in columns {     world.place(Gem(0), atCol: i, row: 1)   }  For-in 반복문은 배열의 각 value마다 { } 안의 코드를 반복해서 실행합니다. 위 코드에서 i는 columns 배열의 각 값을 담는 변수입니다. 배열 columns의 값인 0, 1, 2, 3, 4가 i에 할당되고 각 값은 { } 안에 작성된 코드인 place 메서드의 atCol 패러미터의 인자로 통과됩니다. for-in 반복문이 돌때마다 (Gem(), 0, 1), (Gem(), 1, 1), (Gem(), 2, 1) … 식으로 코드가 실행됩니다. 더이상 할당될 값이 없으면 루프는 끝이납니다.   An array of type Coordinate   Coordinate의 인스턴스는 column과 row arguments를 이용하여 장소를 나타냅니다.     // Coordinate 인스턴스의 예.   let corner = Coordinate(column: 3, row: 3)    // blockLocations라는 Coordinate type의 배열 만들기   var blockLocations = [       Coordinate(column: 0, row: 0),       Coordinate(column: 3, row: 3),       Coordinate(column: 0, row: 3),       Coordinate(column: 3, row: 0)   ]   Array method     characters = [       Character(name: .blu),       Portal(color: pink),       Character(name: .hopper),       Gem()       ]    // Remove the portal.   characters.remove(at: 1)    // Remove the gem.   characters.remove(at: 2)    // Insert the expert.   characters.insert(Expert(), at: 1)   .remove() / .insert() / .append()   .removeFirst() / .removeLast / .removeAll   등이 있습니다.   Creating an empty array   값이 주어지지 않은 빈 배열을 만들 때에는 type을 정해주어야 합니다.     var newLocations: [Coordinate] = []   // 배열의 이름: [배열의 type] = []   Assign a removed item   때때로 한 배열에서 삭제한 아이템을 사용하고 싶을 때가 있을 겁니다. 다행히도 삭제된 item은 짧은 시간동안 저장됩니다. 그러므로 삭제된 값을 다른 변수에 할당하거나 다른 배열에 append 할 수 있습니다.     // Example    var rightColumn = world.column(7)   newArray.append(rightColumn.remove(at: 1))   위 예시 코드에서 newArray에 append된 좌표는 rightColumn에서 삭제된 좌표입니다.   위 코드에서 rightColumn은 메서드로 초기화되었습니다. world 인스턴스는 한 행, 또는 열에 모든 좌표를 가지고 있는 배열을 빠르게 생성할 수 있는 몇가지 메서드를 가지고 있습니다.     // Calling a method to create an array    var row1 = world.row(1)   var column5 = world.column(5)    var topRows = world.coordinates(inRows: [5, 6, 7])   var allCoords = world.allPossibleCoordinates   Fixing Index Out of Range Errors   Index out of range 에러를 찾고 해결해 봅니다.   Index를 사용해서 배열의 각 아이템에 접근할 수 있습니다. 배열의 아이템에 접근한다는 것은 그 아이템을 변수처럼 사용할 수 있게 된다는 것입니다.     // Using an index to access an item      let characters = [     Character(name: .byte),     Character(name: .blu),     Character(name: .hopper)   ]    // Byte toggles a switch   character[0].toggleSwitch    // Hopper jumps   character[2].jump()    // Index out of range error   character[3].collectGem()  위의 마지막 예제 코드처럼 존재하지 않은 index값에 접근하려고 하면 index out of range 오류가 발생합니다. 이것은 앱의 실행을 막는 bug이기 때문에 조심해야 합니다.   버그를 찾고 해결하는 것은 코더로써 중요한 일입니다. Index out of range 에러는 앱의 실행을 중단시키는 가장 흔한 에러 중 하나입니다.   Generate a Landscape   Int 타입의 배열을 이용하여 landscape을 생성해 봅니다.     // 각 인덱스에 할당되어 있는 값에 접근하기   var heights = [7, 3, 2, 4]   for i in 1...heights[0]  heights 배열의 0번째 인덱스에 할당된 값이 7이므로 위의 for loop은 7번 반복합니다.     // Example    var index = 0   for coordinate in allCoordinates {     for i in 1...height[index] {       world.place(Block(), at: coordinate)     }     index += 1   }   위 코드에서는 index 변수에 게속해서 누적으로 1을 더해주기 때문에 index out of range 에러가 발생한다. 이것을 막기 위해서 heights.count를 사용할 수 있다.     var index = 0   for coordinate in allCoordinates {     if index == heights.count {       index = 0 // Array out of bounds error를 막는 코드     }     for i in 0...heights[index] {       world.place(Block(), at: coordinate)     }     index += 1   }   heights.count는 배열의 아이템 수입니다. 아이템의 수가 10개라면 인덱스는 9까지 존재합니다. (0부터 시작하기 때문에) index == heights.count 라는 것은 인덱스가 10이 되었다는 것을 의미함으로 index out of range가 됩니다. 이것을 방지하기 위해 index가 heights 배열 아이템의 수와 같아졌을 때 0을 할당해주는 것입니다.   Randomized Lands   유니크한 월드를 만들어 보기 위해 randomization을 사용해 봅니다.     for i in 1...20 {     let localNumber = randomInt(from: 0, to: 12)     heights.append(localNumber)   }  랜덤 값을 이용하면 코드가 실행될때마다 조금씩 다른 결과를 만들 수 있습니다. 랜던 Boolean 타입을 사용할수도 있습니다.   Local variables   function이나 loop와 같은 code structure 안에서 정의된 변수를 local variable이라고 합니다. 위의 예시 코드에서는 localNumber가 이에 해당됩니다. local variable은 오로지 만들어진 code structure안에서만 사용할 수 있습니다. 그밖의 다른 곳에서는 사용할 수 없습니다.   Read and Tweak   이미 작성된 코드를 읽고, 수정하는 것은 코더에게 중요한 능력입니다. 다른 사람이 작성한 코드를 읽고 이해해야하는 일이 많을 것입니다. code comment를 이용하여 다른 사람들이 나의 코드를 좀 더 쉽게 이해할 수 있도록 하는 것도 좋은 방법입니다.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift","Playgrounds"],
        "url": "/til/playgrounds2/",
        "teaser": "/assets/images/teaser.jpg"
      }]
