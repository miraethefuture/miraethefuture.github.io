var store = [{
        "title": "영단어 정리",
        "excerpt":"  🗂  A      access   to find information, especially on a computer    (주로 컴퓨터에서)정보를 찾는 것      Users can access their voice mail remotely.   whatever thing is accessed by the URL you supply        allow   to make something happen, especially something helpful or useful.    어떤일이 일어나는 것을 가능하게 만들다.        append   to add something to a piece of writing.    글에 어떤 내용을 덧붙이다.      덧붙이다   첨부하다        assign   to give a particular time, value, place etc to something.    특정 시간, 값, 장소등을 어떤 것에게 배정하다. (할당 / 대입하다.)      How much time have you assigned for the meeting?   첨부하다        automate   to start using computers or machines to do a job, rather than people    어떤 일을 하기 위해 사람 대신 컴퓨터나 기계를 사용하다.      Cash machines automates two basic function of a back - deposits and withdrawals.   Build tools are programs that automate the creation of executable applications from source cord.     🗂️  B      bypass   to avoid obeying a rule, system, or someone in an official position.    규칙, 시스템, 공식적인 자리에 있는 사람에게 복종하는 것을 피하는 것      Francis bypassed his manager and wrote straight to the director.   You can bypass basic setup steps that are already familiar to you.     🗂️  C      compatible   if two pieces of computer equipment of software are compatible, they can be used together, especially when they are made by different companies.     소프트웨어에서 사용되는 도구 두가지가 compatible 하다면, 그것은 두가지가 함께 사용될 수 있다는 것을 의미합니다. (특히, 다른 회사에서 만들어진 두가지 도구 일 때 말이죠.)      Will the software on my PC be compatible with a Mac?          configure   to arrange something, especially computer equipment, so that it works with other equipment.    어떤 것을 미리 준비해두다. 특히 다른 도구들과 함께 작동될 수 있도록 컴퓨터 도구들 준비해두다.      This project is configured to fit the exaples in this tutorial.        conform    to obey a law, rule etc 규칙에 순응하다.       An app that uses SwiftUI app life cycle has a structure that conforms to the APP protocol    SwiftUI 앱 라이프 사이클을 사용하는 앱은 그 앱의 프로토콜에 순응하는 구조를 가지고 있다.         consecutive   consecutive numbers or periods of time follow one after the other without any interruptions.    consecutive nunmbers 이나 consecutive peridos of time은 중간에 끊어짐 없이 계속해서 하나의 수가 다른 하나의 수를 따르는 것을 말합니다.      Can they win the title for the third consecutive season?     걔네 삼년 연속으로 우승할 수 있을까?     🗂️  D      define   to describe something correctly and thoroughly, and to say what standards limits qualities etc it has that make it different from other things     어떤 것을 명확히 묘사하는 것, 그리고 그것이 다른 것들과는 다른 어떤 기준, 한계 등을 가지고 있는지 말하는 것.      the ability to define clients' needs     🗂️  E      executable   a computer file that can be run as a program    프로그램으로 실행 될 수 있는 파일.   (명사 / 형용사 둘 다 executable)    🗂️  G      goes a long way towards(to)   If you say that something goes a long way towards doing a particular thing, you mean that it is an important factor in achieving that thing.    something 은 a particular thing 을 달성하기 위한 중요한 요소이다.      Implementing the trends will go a long way to building a functional site.   :: 그 트렌드를 구현하는 것은 잘 작동하는 사이트를 만들기 위한 중요한 요소가 될 것이다.    Although not a cure, it goes a long way towards making the patient's life tolerable.   :: 치료법은 아니지만, 그것은 환자의 삶을 견딜 수 있게 만드는데 큰 도움이 된다.      🗣️ goes a long way towards 발음 들어보기   🗂️  I      invoke   to operate a computer program    컴퓨터 프로그램을 작동시키다.      In small projects, developers often manually invoke the build process          instruction   a command given to a computer to carry out a particular operation.    특정한 일을 수행하기 위해 컴퓨터에게 주어진 명령어.      to put a set of instructions into a computer in a form that it can understand and use.     🗂️  M      manually   operated or done by hand or without the help of electricity, computers etc    기계나 전기의 도움 없이 사람으로부터 수행됨.      It would take too long to do a manual search of all the data.   In small projects, developers often manually invoke the build process        metadata   information that describes what is contained in large computer databases, for example who wrote the information, what it is for, and in what form it is stored    큰 컴퓨터 데이타베이스에 무엇이 저장되어 있는지 알려주는 정보이다. 예를 들면 누가 이 정보를 작성했고, 무엇을 위한 것이고, 어떤 형식으로 저장되었는지에 관한 정보를 알려준다.      Spring Boot Annotations is a form of metadata that provides data about a program.        map onto   to match something or have direct relationship with something    어떤 것을 연결하거나 직접적인 관계를 가지는 것.      Spring Boot Annotations is a form of metadata that provides data about a program.     🗂️  P     protocol   an established method for conneting computers so that they can exchange information    컴퓨터들이 서로 정보를 교환할 수 있는 방법        phase   one of the stages of a process of development or change    개발 또는 변화 중인 절차의 한 단계      a new drug that is in the experimental phase   the first phase of renovation should be done by January     🗂️  R      retrieve   to get back information that has been stored in the memory of a computer    큰 컴퓨터 데이타베이스에 무엇이 저장되어 있는지 알려주는 정보이다. 예를 들면 누가 이 정보를 작성했고, 무엇을 위한 것이고, 어떤 형식으로 저장되었는지에 관한 정보를 알려준다.      Spring Boot Annotations is a form of metadata that provides data about a program.     🗂️  T      transfer   to copy recorded information from one system to another   시스템에 기록된 정보를 다른 시스템에 복사하는 것.      Spring Boot Annotations is a form of metadata that provides data about a program.     🗂️ U     underlying cause/principle/problem etc   the cause, idea etc that is the most important, although it is easily not noticed    알아차리기 힘들지만 가장 중요한 원인이나 아이디어.      the underlying causes of her depression      ","categories": ["vocabularies"],
        "tags": ["studying","learning","vocabularies"],
        "url": "/vocab/verb/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "JDBC로 오라클 클라우드 DB와 연결하여 이클립스 콘솔 창에 데이터 불러오기",
        "excerpt":"  💭 ..     맥북 유저에게 국비 수업이란...?    처음 국비 수업을 듣기로 결심했을 때 가장 걱정이 되었던 것은 나에겐 Windows 운영체제를 사용하는 랩탑이 없다는 것이었다. 국비 수업은 Windows를 기준으로 진행되기 때문에 macOS로 수업을 듣다가 문제가 생기면 강사님의 도움을 받기가 쉽지 않다. 수업 전 진행된 오티에서 강사님도 되도록이면 Windows를 사용할 것을 권했다. 나는 macOS를 사용한 지 오래되었고, 국비 수업을 듣기 전 독학하며 구글링 실력을 꽤 키웠다고 생각했기 때문에 굳이 Windows 운영체제의 랩탑을 구하려고 하지 않았다. 내가 혼자 해결할 수 있을 거라는 원인 모를(ㅎㅎ) 자신감이 있었다.  이클립스 IDE나 Java는 이미 설치해서 사용하고 있었기 때문에 수업 중 설치하는 시간에 문제가 없었다. 그 후로 쭉 문제없이 수업을 잘 들었다. 작은 에러들은 구글링으로 해결할 수 있었다. 그러던 중 데이터베이스에 대해 배우는 주가 시작되었다. 국비 수업이 시작되기 전, 수업에 대한 정보들을 검색해 보던 중 m1 칩 맥북은 오라클을 사용할 수 없다는 것을 알게 되었고 아래 도움이 된 글 목록 중 첫 번째에 있는 블로그의 글을 보고 미리 오라클 클라우드에 가입 후 DB를 생성하고 SQL Developer와 연동은 해둔 상태였다. 하지만 당시에는 DB와 Java로 작성된 프로그램을 연결하려면 JDBC를 이용해야 한다는 것을 몰랐다. DB와 Java를 연결하는 수업이 시작되었고 많은 분들이 JDBC driver를 다운로드하고 연결하는 과정에 어려움을 겪었다. 나도 다르지 않았다.  아무것도 모르던 4개월 전, 깃헙 페이지로 개발 블로그를 만들려고 구글링을 하며 오랜 시간을 삽질했던 때가 있었다. 그때는 한 가지 문제를 해결하려고 3일, 4일을 구글링하고도 원하는 답을 찾지 못할 때도 있었다. 그때의 기억이 떠올라서 식은땀이 쫙 났다.      'DB와 자바를 연결하지 못하면 수업을 듣기 힘들 텐데 어쩌나.. 밤을 새워서라도 해야겠다.'  라고 생각하고 있었는데 다행히 벌써 많은 분들이 애플 실리콘칩 맥북 + 오라클 클라우드 DB를 연동하는 방법에 대한 블로그 글을 올려주셨고 덕분에 생각보다 빠르게 해결할 수 있었다. 수업이 끝나기 전에 연결이 잘 되어서 엄청 기쁘고 다행이라는 생각이 들었다.     다음에 또 필요할 때를 대비해 기록을 남겨둔다. 국비 수업을 들으려는 다른 macOS 유저들에게도 조금이나마 도움이 되길 바란다.    🔦 도움이 된 글  1. Apple Silicon m1 맥북에서 Oracle Database 사용하기  2. Apple Silicon) M1 으로 oracle&amp;eclipse 연동하기 (3)  3. okky 쿠잉님 댓글   1. JDBC의 역할   JDBC는 DB와 Java를 연결해 주는 API입니다. 자바 언어로 작성한 프로그램에서 데이터 베이스에 접근하고 여러 가지 데이터와 관련된 작업을 수행할 수 있게 되죠. 예를 들면, 이클립스에서 몇 가지 자바 클래스와 메서드 그리고 SQL 문을 사용하여 직접 DB에 접근해 데이터를 검색, 추가, 삭제, 수정할 수 있게 되는 것입니다.   2. SQL Developer를 이용해 테이블 만들기   먼저 저는 SQL Developer를 이용하여 오라클 클라우드 DB에 간단한 테이블을 하나 만들어 주었습니다. 테이블 이름은 stardew_valley 입니다.                          VNAME       ADDRESS       AGE                       1       Gus       The Stardrop Saloon       48                 2       Abigail       Pierres General Store       24                 3       Sebastian       24 Mountain Road       26              3. Java 프로그램 내에서 연결된 DB의 데이터에 접근하기   먼저 작업하고 있는 Java project에 ojdbc8.jar를 추가합니다. 위 도움을 받은 글 목록 중 두번째 블로그 글을 보면 꼭 ojdbc8.jar을 받아야 한다고 하셨는데요. 저도 처음에 다른 버전으로 받았다가 제대로 실행되지 않는 문제를 겪었습니다.   import java.sql.*;  public class Jdbc_test {   public static void main(String[] args) {      String url = \"jdbc:oracle:thin:@데이터 베이스 이름_high?TNS_ADMIN=전자지갑 압출 풀어준 폴더의 경로\";     String userid= \"데이터베이스 userid\"; // 변경하지 않았다면 admin     String pwd = \"데이터베이스 접속 비밀번호\"; // DB 생성 시 지정했던 비밀번호       try{        // 오라클 드라이버 로딩       Class.forName(\"oracle.jdbc.OracleDriver\");        // DB에 연결       Connection con = DriverManager.getConnection(url, userid, pwd);        // sql문 작성 - DB에 저장되어있는 테이블에서 모든 레코드 정보 가져오기       String sql = \"select * from stardew_valley\"; // \"\"; 안에 sql문 작성 후 sql 변수에 할당        // 작성한 sql문을 DB로 전달하기 위해 연결       PreparedStatement ps = con.prepareStatement(sql);        // 실행 후 결과값을 ResultSet 타입의 변수에 할당       ResultSet rs = ps.executeQuery();        // 반복문 이용 결과값 출력       while(rs.next()) { // next() 메서드는 값이 있으면 true 반환 -&gt; 값이 없을 때가지 반복         String vname = rs.getString(\"vname\");         String address = rs.getString(\"address\");         int age = rs.getInt(\"age\");          // 임시 header 출력         System.out.println(vname + \"\\t\" + address + \"\\t\" + age);        }        // 연결되어있던 객체들 닫아주기       ps.close(); con.close(); rs.close();      } catch(Exception e) {       e.printStackTrace();     }   } }  실행하면 작성해 준 임시 header 아래로 위 표와 같은 모든 데이터를 console 창에 출력합니다.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Java","Oracle Cloud","Database"],
        "url": "/til/jdbc/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Swift를 배워보자!",
        "excerpt":"💭 ..     Swift를 배워보자.    유투브 튜토리얼, 애플 개발자 페이지의 튜토리얼, 구글링을 통해 Swift를 공부해보려고 합니다.        그 과정에서 기록이 필요한 것들을 정리해봅니다.    1. Hello, world!  A Swift Tour 공식 가이드를 읽으며 공부합니다.   print(\"Hello, world!\")   스위프트에서 이 한줄의 코드는 완벽하게 한 프로그램입니다. input/output 또는 문자열을 다루기 위해 따로 라이브러리를 추가하지 않아도 됩니다. main() function 또한 필요하지 않습니다. 또한 Swift는 각각의 statement의 끝에 세미콜론(;)을 작성하지 않습니다.   2. 간단한 값들(Simple Values)   상수는 let, 변수는 var를 사용해서 만듭니다. var(변수)에는 다른 값을 다시 할당할 수 있고, let(상수)는 한번 값이 정해지면 다른 값을 할당할 수 없습니다.   var myVariable = 42 myVariable = 50 let myConstant = 42  var, let의 이름 뒤에 : 을 이용해서 데이터 타입을 지정할 수 있습니다. 컴파일러가 할당된 값이 어떤 데이터 자료형을 가지고 있는지 추측할 수 있는 경우에는 자료형을 명시하지 않아도 됩니다.   let implicitInteger = 70 let implicitDouble = 70.0 let explicitDouble: Double = 70   3. View에 대해 조사해보자.  애플 공식 문서 중 Declaring a Custom View를 보며 View에 대해 알아봅니다.      컴퓨터 프로그래밍 분야에서 'Declare'는 어떤 의미로 사용될까요?    a declaration은 변수와 같은 요소들의 이름과 데이터 타입을 결정하여 컴파일러에게 알려주는 것을 의미합니다.    Declaring a Custom View  Custom View의 이름과 데이터 타입을 정하고 컴파일러에게 알려주기.  view를 선언(declaring)하는 방법으로 간단하게 user interface를 묘사할 수 있습니다.  a hierarchy에 Text, Image, Button과 같은 뷰들을 선언하므로서 간단하게 user interface를 묘사할 수 있습니다. hierarchy는 계층인데요. VStack 아래에 views들이 있고 view들에는 적용된 modifier들이 있죠 그것들을 하나의 hierarchy라고 하는 것 같습니다. 이제 SwiftUI가 사용자로부터 받은 input이나 데이터의 변화등에 응답할 view들을 화면에 그리고 업데이트합니다.   SwiftUI가 제공하는 built-in view와 다른 view들을 함께 혼합해서 사용할 수 있습니다. modifier를 이용해서 뷰를 배치하고 data 모델에 연결할 수 있습니다. 그리고 custom view들을 화면에 보여지는 앱 뷰에 놓으면 됩니다.   struct MyView: View { // &lt;- View Protocol 입니다. }  View Protocol을 따르는 structure를 정의 했습니다.  View protocol은 기능의 청사진을 제공합니다. 이 경우에는 SwiftUI가 화면에 그릴 각 요소들의 작동하는 방식을 제공합니다.   custom view를 view hierarchy에 포함되게 하려면 View protocol이 요구하는 몇가지 사항들을 충족시켜야 합니다.   View protocol의 주요구사항은 body computed property를 꼭 정의해주어야 한다는 것입니다.   4. 인스턴스(Instances)   5. Properties는 뭘까요?   Properties는 값(values)와 특정 class, structure, enumeration을 연결시킵니다.      Stored properties   Computed properties   Stored properties는 instance의 한 부분을 하는 변수와 상수를 담는 역할을 합니다. 그에 반해, computed properties는 값을 담기 보다는 계산합니다.  Computed properties는 class, structure, enumeration으로 부터 제공, 사용되고 stored properties는 class와 structure로 부터 제공, 사용됩니다.   …계속됩니다.😎      ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift"],
        "url": "/til/basicSwift/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "A Swift Tour : 디지털 시계 앱을 만들며 스위프트 배워보기",
        "excerpt":"💭 ..     Swift는 어떤 언어일까?    디지털시계 앱을 만들며 Swift의 기초적인 것들을 알아봅니다.         1. ContentView와 ContentView_Previews  Intro to SwiftUI: Digital Clock &lt;- 블로그의 글을 보며 공부합니다.   //  ContentView.swift //  Your Digital Clock  import SwiftUI  struct ContentView: View {     @State var date = Date()     var body: some View {          ZStack {             Image(\"unsplash-photo\")             .resizable()             .scaledToFill()             .ignoresSafeArea()          VStack {              Text(\"\\(timeString(date: date))\")                  .font(.system(size: 160))                  .fontWeight(.bold)                  .foregroundColor(Color.white)                  .onAppear(perform: {let _ = self.updateTimer})                 // 여기 이해 안됨. date: date               Text(\"\\(greeting())\")                  .font(.system(size: 75))                  .foregroundColor(Color.white)               Text(\"\\(dateString(date: date))\")                  .font(.system(size: 20))                  .foregroundColor(Color.white)                  .onAppear(perform: {let _ = self.updateTimer})                  .offset(y: 100)                } // VStack            } // ZStack        } // body       // ContentView structure     var timeFormat: DateFormatter {         let formatter = DateFormatter()         formatter.dateFormat = \"hh:mm:ss a\"         return formatter     } // 시간 부분 Formatter      var dateFormat: DateFormatter {         let formatter = DateFormatter()         formatter.dateFormat = \"yyyy/MM/dd EEEE\"         return formatter     }      func timeString(date: Date) -&gt; String {         let time = timeFormat.string(from: date)         return time     }      func dateString(date: Date) -&gt; String {         let time = dateFormat.string(from: date)         return time     }       var updateTimer: Timer {         Timer.scheduledTimer(withTimeInterval: 1, repeats: true, block: { _ in             self.date = Date()         })     } // timeInterval 마다 블락 안의 코드가 실행됨      func greeting() -&gt; String {         var greet = \"\"          let midNight0 = Calendar.current.date(bySettingHour: 0, minute: 00, second:00, of: date)!         let nightEnd = Calendar.current.date(bySettingHour: 3, minute: 59, second: 59, of: date)!          let morningStart = Calendar.current.date(bySettingHour: 4, minute: 00, second: 0, of: date)!         let morningEnd = Calendar.current.date(bySettingHour: 11, minute: 59, second: 59, of: date)!          let noonStart = Calendar.current.date(bySettingHour: 12, minute: 00, second: 00, of: date)!         let noonEnd = Calendar.current.date(bySettingHour: 16, minute: 59, second: 59, of: date)!          let eveStart = Calendar.current.date(bySettingHour: 17, minute: 00, second: 00, of: date)!         let eveEnd = Calendar.current.date(bySettingHour: 20, minute: 59, second: 59, of: date)!          let nightStart = Calendar.current.date(bySettingHour: 21, minute: 00, second: 00, of: date)!         let midNight24 = Calendar.current.date(bySettingHour: 23, minute: 59, second: 59, of: date)!          if ((date &gt;= midNight0) &amp;&amp; (date &lt;= nightEnd)) {             greet = \"Good Night\"         } else if (date &gt;= morningStart) &amp;&amp; (date &lt;= morningEnd) {             greet = \"Good Morning\"         } else if ((date &gt;= noonStart) &amp;&amp; (noonEnd &gt;= date)) {             greet = \"Good Afternoon\"         } else if ((date &gt;= eveStart) &amp;&amp; (eveEnd &gt;= date)) {             greet = \"Good Evening\"         } else if ((date &gt;= nightStart) &amp;&amp; (midNight24 &gt;= date)) {             greet = \"Good Night\"         }          return greet      } // func greeting  } // ContentView 끝   struct ContentView_Previews: PreviewProvider {     static var previews: some View {         ContentView()         .previewInterfaceOrientation(.landscapeLeft)     } }  Xcode에서 처음 프로젝트를 열면 ContentView 그리고 ContentView_Previews라는 이름을 가진 두개의 structure가 기본적으로 생성되어 있습니다. 이 글에서는 이 두가지의 structure를 이용하여 간단한 디지털 시계앱을 만들어보며 시간/날짜 정보를 불러오는 방법에 대해 알아보겠습니다.   ContentView: View와 var body: some View에서 View는 이 structure가 View protocol을 따를 것이라는 의미입니다. Protocol은 요구사항을 가지고 있습니다. View 프로토콜의 가장 주요한 요구사항은 body property가 있어야 한다는 것입니다.   body property 부분에는 스크린에 나타날 view들이 작성됩니다. 이때의 view는 프로토콜 view가 아닌 Text view, Image view, Button view와 같은 SwiftUI의 built-in view 또는 외부 프레임의 view들을 말합니다. 위 코드에서는 ZStack의 하위에 Image view와 VStack이, 그리고 VStack 하위에는 Text view가 body property 안에 작성되었습니다.   2. 현재 날짜와 시간 정보 가져오기   struct ContentView: View {   @State var date = Date() }           ‘@State’ property wrapper는 해당 변수가 모니터링 되고 있다는 것을 의미합니다.            ‘Date()’는 사용자가 있는 지역의 날짜와 시간 정보를 가져옵니다.       import SwiftUI  struct ContentView: View {     @State var date = Date()     var body: some View {         VStack {           Text(\"\\(date)\")         }     } }  struct ContentView_Previews: PreviewProvider {     static var previews: some View {         ContentView()     } }   시간 정보는 초마다 계속해서 바뀌므로 property wrapper인 @State 를 사용해서 바뀐 시간을 계속해서 업데이트, 반영해 주고 문자열 date에 escape character \\ 를 추가해서 Date()를 담고 있는 date 변수의 할당되어 있는 정보를 문자열로 가져옵니다.   3. DateFormatter  import SwiftUI  struct dateString: View {     @State var date = Date()     var body: some View {         Text(\"\\(date)\")     } }  struct dateString_Previews: PreviewProvider {     static var previews: some View {         dateString()     } }   위 코드로 가져온 날짜/시간 데이터를 화면에 출력해봅니다. 아직 형식을 지정해주지 않았기 때문에 아래 사진처럼 보여집니다. 날짜, 시간, 분이라는 정보가 포함되어 있지 않고 나열된 문자열로써 나타납니다.      시간 부분의 형식을 먼저 지정해보겠습니다.   var timeFormat: DateFormatter {   let formatter = DateFormatter()   formatter.dateFormat = \"hh:mm:ss a\"   return formatter }   DateFormatter는 시간/날짜 데이터를 문자열 형식으로 보여지게 하는 Class입니다. dateFormat은 DateFormatter Class의 instance property입니다. 데이터를 받은 사람이 사용할 수 있는 날짜/시간 데이터의 형식 중 하나입니다.     hh - 12시간 표기법 시간   mm -  분   ss -  초   a - am/pm   그 다음으로는 가져온 시간 데이터를 문자열로 바꿔주는 function을 작성해봅니다.  func timeString(date: Date) -&gt; String {   let time = timeFormat.string(from: date)   return time }   여기까지 수정 👷   4. Live Time   SwiftUI가 State variable에 일어난 변화들을 감시합니다. @State는 스스로 변화를 만들지는 않습니다.  Date() initializer는 시간의 한 지점을 가져옵니다. 우리가 방금 만든 디지털 시계가 자동으로 흘러가지 않는 이유이죠.   우리가 보는 시계들처럼 초가 흘러가고 60초가 지나면 1분이 늘어나게 만드려면 매초마다 date variable을 새로 고침해주어야 합니다.  그러려면 Timer 객체를 사용하면 됩니다. Timer는 일정 시간이 지나면 특정 메세지를 타겟 객체에 보냅니다. Timer을 설정해주면 SwiftUI가 @State의 변화를 인식하고 그것에 따라 우리의 시계를 업데이트 해줄 것입니다.   Timer 객체를 생성하는 코드를 작성해봅니다.   var updateTimer: Timer {   Timer.scheduledTimer(withTimeInterval; 1, repeats: true,     block: {       self.date = Date()       })   }   scheduledTimer() 메서드를 이용합니다. 첫번째 인자는 withTimeInterval이고 시간의 간격을 입력해줍니다.  두번째는 repeat 입니다. 반복할 것인지 아닌지 bool 타입으로 입력해줍니다.  세번째는 block 입니다. Timer가 반복될 때마다 작동될 코드를 작성해줍니다.   아직은 초마다 시계가 움직이지 않죠? 한 단계가 더 남아있습니다. Text View 아래에 .onAppear modifier을 사용하여 Timer가 스크린에 나타나도록 해줍니다.   Text(\"\\(timeString(date: date))\")   .onAppear(perform: {let _ = self.updateTimer})   .onAppear(perform: action) 은 function modifier 입니다. View가 나타나면 action을 수행합니다. self.updateTimer function은 저장할 필요가 없는 값을 반환하기 때문에 ‘let _‘을 사용했습니다. underscore 는 아무것도 할당하고 싶지 않다는 것을 나타냅니다. 이 스텝까지 잘 마치셨다면 디지털 시계가 초마다 움직이는 것을 볼 수 있을 것입니다!   5. Time of Day Greeting   시간에 따라 달라지는 인사말을 추가해볼 것입니다.     4:00:00am to 11:59:59am -&gt; Morning   12:00:00pm to 4:59:59pm -&gt; Afternoon   5:00:00pm to 8:59:59pm -&gt; Evening   8:00:00pm to 3:59:59am -&gt; Night  위의 기준으로 시간을 나누고 각 시간대의 인사말이 시계 아래에 나타나도록 해봅시다.   func greeting() -&gt; String {         var greet = \"\"          let midNight0 = Calendar.current.date(bySettingHour: 0, minute: 00, second:00, of: date)!         let nightEnd = Calendar.current.date(bySettingHour: 3, minute: 59, second: 59, of: date)!          let morningStart = Calendar.current.date(bySettingHour: 4, minute: 00, second: 0, of: date)!         let morningEnd = Calendar.current.date(bySettingHour: 11, minute: 59, second: 59, of: date)!          let noonStart = Calendar.current.date(bySettingHour: 12, minute: 00, second: 00, of: date)!         let noonEnd = Calendar.current.date(bySettingHour: 16, minute: 59, second: 59, of: date)!          let eveStart = Calendar.current.date(bySettingHour: 17, minute: 00, second: 00, of: date)!         let eveEnd = Calendar.current.date(bySettingHour: 20, minute: 59, second: 59, of: date)!          let nightStart = Calendar.current.date(bySettingHour: 21, minute: 00, second: 00, of: date)!         let midNight24 = Calendar.current.date(bySettingHour: 23, minute: 59, second: 59, of: date)!          if ((date &gt;= midNight0) &amp;&amp; (date &lt;= nightEnd)) {             greet = \"Good Night.\"         } else if (date &gt;= morningStart) &amp;&amp; (date &lt;= morningEnd) {             greet = \"Good Morning\"         } else if ((date &gt;= noonStart) &amp;&amp; (noonEnd &gt;= date)) {             greet = \"Good Afternoon.\"         } else if ((date &gt;= eveStart) &amp;&amp; (eveEnd &gt;= date)) {             greet = \"Good Evening.\"         } else if ((date &gt;= nightStart) &amp;&amp; (midNight24 &gt;= date)) {             greet = \"Good night.\"         }          return greet      }   Calendar.current.date(bySettingHour…) 메서드는 주어진 date 데이터에 특정한 시간을 나타내는 variable을 만듭니다. 여기서는 우리가 위에서 만든 @State date가 주어진 날짜 데이터입니다.   아래 부분은 나누어 놓은 시간대와 현재 시간을 비교하는 부분입니다. 현재 시간과 비교해서 해당되는 인사말을 greet 변수에 담고 반환합니다. 여기까지 하면 시간을 스크린에 띄우는 것은 완성!   … 디지털시계 만들기는 계속 됩니다.      ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift"],
        "url": "/til/basicSwift2/",
        "teaser": "/assets/images/yourDigitalClock.png"
      },{
        "title": "SwiftUI Tutorial: 여러 개의 View를 만들고 결합하기",
        "excerpt":"SwiftUI Tutorial을 따라가며 아래 Landmark앱을 만들어 보겠습니다. 튜토리얼의 출처는 SwiftUI Essentials: Creating and Combining Views 입니다.      ☑️ What I Learned From This Tutorial:      SwiftUI 프레임워크와 다른 프레임워크를 함께 사용하는 방식   여러개의 파일을 하나의 View로 합치기   Stack의 사용법   지도와 관련된 Structures   alignment: .leading   Divider()   Spacer()              1. Stacks을 이용해 텍스트 배치하기: ContentView.swift   // ContentView.swift // Landmarks  import SwiftUI  struct ContentView: View {   var body: some View {      VStack(alignment: .leading) {          Text(\"경복궁\")             .font(.title)             .foregroundColor(.black)          HStack {              Text(\"Gyeongbokgung Palace\")                 .font(.subheadline)             Text(\"Korea\")                 .font(.subheadline)         } // HStack 끝         .font(.subheadline)         .foregroundColor(.secondary)          Divider()         Text(\"About Gyeongbokgung\")             .font(.title2)         Text(\"Gyeongbokgung, also known as Gyeongbokgung Palace or Gyeongbok Palace,         was the main royal palace of the Joseon dynasty.         Built in 1395, it is located in northern Seoul, South Korea.\")             .font(.body)      } // VStack     .padding()   } }  struct ContentView_Previews: PreviewProvider {   static var previews: some View {       ContentView()     } }   이 부분에서는 Stack과 Spacer()를 이용해서 Text view를 배치하는 것에 대해 알아보았습니다. .foregroundColor(.secondary)는 옅은 회색을 화면에 보여줍니다. alignment가 기본적으로는 가운데로 지정되어 있고 왼쪽 정렬을 하려면 (alignment: .leading)을 사용하면 됩니다.    아래는 위 코드가 화면에 그려진 결과입니다. Divider()를 이용해 콘텐츠를 나누는 줄을 그릴 수 있습니다.      2. 지도와 관련된 데이터 불러오기: MapView.swift   // MapView.swift // Landmarks  import SwiftUI import MapKit  struct MapView: View {     @State private var region = MKCoordinateRegion(         // 경복궁의 위도와 경도         center: CLLocationCoordinate2D(latitude: 37.580_535, longitude: 126.977_341),         span: MKCoordinateSpan(latitudeDelta: 0.05, longitudeDelta: 0.05)         )      var body: some View {         Map(coordinateRegion: $region)     } }  struct MapView_Previews: PreviewProvider {     static var previews: some View {         MapView()     } }   SwiftUI 프레임워크를 추가하고 그 외에 또 다른 프레임 워크를 추가하면,  (여기서는 MapKit라는 프레임워크를 추가했습니다.)  추가된 프레임워크와 관련된 SwiftUI의 특정 기능에 접근할 수 있게 됩니다.   MKCoordinateRegion는 위도, 경도로 표시된 특정 좌표 평면상의 지역을 직사각형의 형태로 가져오는 Structure입니다. 위 코드에서는 가져온 지역 정보를 region이라는 이름의 private state variable에 담았습니다.   center: 와 span:은 파라미터 입니다.  center: 는 가운데 오게 될 지역의 위도, 경도  span: 은 지도가 보여질 크기를 나타내는 horizontal span과 vertical span이 들어올 것입니다.   CLLocationCoordinate2D은 국제 좌표계를 기준으로 특정 지역의 위도 경도를 이용하여 지역 좌표 object를 생성하는 Structure입니다. center: 파라미터를 지나는 값이니 생성된 좌표 object를 중심점으로 사용한다는 뜻이겠죠?   MKCoordinateSpan은 지도로 표현된 지역의 가로와 세로 크기를 표현하는 Structure입니다. delta values를 이용해서 원하는 줌 레벨을 설정할 수 있습니다. delta value이 커지면 줌 레벨은 작아집니다. delta value가 작아지면 줌 레벨을 커지면서 더 가까이 지도를 볼 수 있습니다.   body property의 Map()은 Generic Structure로, 사용할 지도 인터페이스를 보여주는 역할을 합니다. 위 코드에는 표현되지 않았지만 사용자의 위치를 보여주거나 이동경로를 추적하는 등의 기능을 합니다.  아래는 위 코드가 화면에 그려진 결과입니다. 더블 클릭을 하여 화면을 확대하거나, 양쪽으로 끌어 움직일 수 있습니다.        3. 동그라미 모양으로 이미지 잘라내기: CircleImage.swift   //  CircleImage.swift //  Landmarks  import SwiftUI  struct CircleImage: View {     var body: some View {         Image(\"kbpalace\")             .clipShape(Circle())             .overlay {                 Circle().stroke(.white, lineWidth: 4)             } //overlay {}             .shadow(radius: 7)     } }  struct CircleImage_Previews: PreviewProvider {     static var previews: some View {         CircleImage()     } }  이 부분에서는 .clipShape(Circle()) 메서드를 사용하여 이미지를 동그랗게 잘라냅니다. .overlay 부분에서는 테두리가 될 부분을 만들어 줍니다. overlay 메서드는 레이어를 만들어 줍니다. 우리가 앞에서 만들었던 동그라미 모양의 사진 위에 레이어가 한층 생기는 거죠. Circle().stroke(.white, lineWidth: 4)는 동그라미 모양의 테두리를 그려줍니다. .shadow는 그림자를 그려줍니다.     4. Views를 결합하기   //  ContentView.swift //  Landmarks  import SwiftUI  struct ContentView: View {     var body: some View {         VStack {             MapView()                 .ignoresSafeArea(edges: .top)                 .frame(height: 300)              CircleImage()                 .offset(y: -130)                 .padding(.bottom, -130)              VStack(alignment: .leading) {                 Text(\"경복궁\")                     .font(.title)                 .foregroundColor(.black)                 HStack {                     Text(\"Gyeongbokgung Palace\")                         .font(.subheadline)                     Spacer()                     Text(\"Korea\")                         .font(.subheadline)                 } // HStack                 .font(.subheadline)                 .foregroundColor(.secondary)                  Divider()                 Spacer()                 Text(\"About Gyeongbokgung\")                     .font(.title2) //                Spacer()                 Text(\"Gyeongbokgung, also known as Gyeongbokgung Palace or Gyeongbok Palace, was the main royal palace of the Joseon dynasty. Built in 1395, it is located in northern Seoul, South Korea.\")                     .font(.body)                 Spacer()               } // VStack             .padding()              Spacer()         } // 가장 바깥쪽 VStack      } }  struct ContentView_Previews: PreviewProvider {     static var previews: some View {         ContentView()     } }    이제 위에서 만든 모든 View 들은 합쳐줍니다. .offset() 메서드의 y 파라미터의 값을 주어 원래의 dimension에서 콘텐츠를 조금 올려줍니다. .offset() 메서드가 없다면 VStack 안에서 겹치지 않고 나열되어 있을 것입니다.       ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift"],
        "url": "/til/landmarks/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Codility_Developer Training: 배열 챕터의 문제 CyclicRotation",
        "excerpt":"CyclicRotation 문제 읽기   1. 문제를 파악해보자   N개의 정수로 이루어진 배열이 주어집니다. 배열의 Rotation이란 각각의 element를 오른쪽 인덱스로 옮긴다는 뜻입니다. 맨 마지막 인덱스에 있던 요소는 첫 인덱스로 이동합니다.   //the rotation of array A A = [3, 8, 9, 7, 6] // is A = [6, 3, 8, 9, 7]  위의 예제는 배열 A를 한번 rotate한 결과입니다.   목표는 배열 A를 K번 오른쪽 인덱스로 한칸씩 이동시키는 것입니다.   [3, 8, 9, 7, 6] -&gt; [6, 3, 8, 9, 7] [6, 3, 8, 9, 7] -&gt; [7, 6, 3, 8, 9] [7, 6, 3, 8, 9] -&gt; [9, 7, 6, 3, 8]  위의 예제는 3번 rotate한 결과입니다.   2. 로직을 생각해보자   일단 아직은 더 익숙한 언어인 Java로 구체적인 수를 적용하여 코드를 작성해봅니다.  package array;  public class CyclicRotaion {   public static void main(String[] args) {      // 주어진 배열     int[] A = {3, 8, 9, 7, 6};      // 마지막 인덱스의 값 빈 변수에 할당하기     int p = A[A.length-1];      // 한칸씩 옮기기     A[A.length-1] = A[A.length-2];     A[A.length-2] = A[A.length-3];     A[A.length-3] = A[A.length-4];     A[A.length-4] = A[A.length-5];      // 0번째 인덱스에 옮겨두었던 마지막 인덱스 값 할당하기     A[A.length-5] = p;      for(int i = 0; i &lt; A.length; i++) {       System.out.print(A[i] + \" \");     } // for문   } }  위 코드의 실행 결과는 6, 3, 8, 9, 7입니다.   3. 이클립스에서 작성한 문제 해결 코드   package array;  import java.util.Scanner;  public class CyclicRotaion {   public static void main(String[] args) {        // 주어진 배열       int[] A = {3, 8, 9, 7, 6};        // 마지막 인덱스의 값 빈 변수에 할당하기       // 배열의 크기에 상관없이 항상 마지막 인덱스 값을 나타냄.       int p = A[A.length-1];        for(int i = 1; i &lt;= (A.length-1); i++) {           A[A.length-i] = A[A.length-(i+1)];       }        // 0번째 인덱스에 옮겨두었던 마지막 인덱스 값 할당하기       A[A.length-A.length] = p;        // 배열의 값을 출력하는 for문       for(int i = 0; i &lt; A.length; i++) {           System.out.print(A[i] + \" \");       }   } }  반복되는 부분을 for문을 사용하여 작성해줍니다.   4. 코딜리티에 제출한 문제 해결 코드   아래는 최종 정리해서 코딜리티에 제출한 코드입니다.   class Solution {   public int[] solution(int[] A, int K) {     // write your code in Java SE 8      int p = 0; // 마지막 인덱스의 값 옮겨둘 변수      while(K &gt;= 1) { // while문 사용하여 반복할 횟수 K이용        p = A[A.length-1];        for(int i = 1; i &lt;= (A.length-1); i++) {            A[A.length-i] = A[A.length-(i+1)];          } // for문 끝        A[A.length-A.length] = p;       K--;      } // while 문 끝      return A;   } // 메서드 끝 }        내가 푼 풀이의 정확도는 87%        분석 결과를 보니 빈 배열이 입력되었을 때 프로그램이 꺼지는 문제가 발생.   … 문제 해결은 계속됩니다.   추가해야 할 글      문제 해결 과정   빈 배열이 입력되었을 때 프로그램이 꺼지는 문제 해결하기  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Codility","코테"],
        "url": "/til/cyclicRotation/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "웹 페이지를 만들며 HTML과 CSS에 대해 알아보기",
        "excerpt":"튜토리얼 출처: Easy Tutorials: How To Make A Website Using HTML And CSS      What I Learned From This Project:      HTML link element   linear-flex를 이용해서 목록을 옆으로 나열하기   !important         Octopi Project    HTML과 CSS(+JS 한스푼)을 공부하며 웹 페이지를 만들어 봅니다. 기획 보다는 HTML과 CSS를 공부하는 느낌으로 만들 것이기 때문에 웹 페이지의 주제는 고민하지 않고 머릿속에 떠오른 단축키를 모아놓은 웹 사이트로 가보겠습니다.     link HTML element   &lt;link rel=\"stylesheet\" href=\"style.css\"&gt; &lt;!-- &lt;link&gt;는 &lt;head&gt; 부분에 작성되어야 합니다. --&gt;  &lt;link&gt; element는 외부 리소스와 현재 작업 중인 document의 관계를 지정해 줍니다. 주로 stylesheets와 연결할 때 많이 사용됩니다. 또한 아이콘을 설정해 줄 때도 사용됩니다. 저도 블로그 타이틀에 파비콘을 추가했을 때 &lt;link&gt;를 사용했던 기억이 나네요.       (내 블로그 파비콘과 노션 파비콘)     위 코드에서는 외부에 작성된 stylesheet와 현재 html파일의 관계를 &lt;link&gt; 로 연결해줍니다. 이제 stylesheet에서 CSS를 이용해 현 document에 있는 태그들의 속성을 수정할 수 있게 되었습니다.   &lt;p style=\"color: blue\"&gt;   The style attribute can override it, though.&lt;/p&gt;  style.css 파일을 연결하여 작업하는 중 위 예제 코드처럼 html 파일에서 바로 속성을 사용할 수도 있습니다. 이 경우 html의 속성이 CSS style sheet에서 적용된 속성보다 우선 순위에 있습니다.   rel은 relationship을 의미합니다. &lt;link&gt; element의 가장 중요한 기능 중 하나입니다. rel에 지정된 값은 연결된 외부 리소스와 현 document가 어떤 관계를 가지고 있는지 나타내줍니다. 이것들을 Link types라고 합니다. stylesheet, icon, tag 등 여러가지 관계들이 있습니다. link types는 두 문서들간의 관계를 나타냅니다.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","HTML","CSS","JavaScript"],
        "url": "/til/myOctopi/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "SwiftUI Essentials: Building Lists and Navigation",
        "excerpt":"튜토리얼의 출처는 SwiftUI Essentials: Building Lists and Navigation 입니다.     ☑️ What I Learned From This Tutorial:      데이터를 이용하기   Foundation framework의 사용   Codable / Hashable conformance   Guard      Section 1: Landmark model 생성하기   샘플 데이터 파일 추가하기   다운받은 프로젝트 파일에 압축을 풀면 Resources 폴더에 landmarkData.json 파일이 있습니다. 튜토리얼 Creating and Combining Views에서 만들었던 프로젝트를 그대로 사용합니다. 왼쪽에 위치한 프로젝트의 navigation pane 부분에 landmarkData.json 파일을 드래그해서 넣어줍니다. 다이얼로그 창이 나타나면 ‘Copy items if needed’을 선택하고 Add to targets: 에 Landmarks를 선택하고 Finish 버튼을 눌러줍니다. 앞으로의 튜토리얼을 진행하며 게속해서 이 샘플 데이터를 사용할 것입니다.       (샘플 데이터인 landmarkData.json 파일을 추가해 준 모습)     새로 만든 Landmark.swift 파일에 structure 생성     //  Landmark.swift    import Foundation    struct Landmark: Hashable, Codable {       var id: Int       var name: String       var park: String       var state: String       var description: String   }  Landmark.swift라는 이름의 스위프트 파일을 만들어 줍니다. Landmark structure를 정의하고 landmarkData.json 파일에 있는 키와 이름이 같은 property 몇개를 만들어줍니다.   👷 작성하는 중..   Foundation framework   Foundation framework는 가장 기본적인 data types과 collections 그리고 운영체제 서비스에 접근하도록 합니다. 데이터를 저장 또는 유지하기, 텍스트의 처리, 날짜와 시간의 계산, 정렬 및 필터링, 그리고 네트워킹과 같은 가장 기본적인 기능을 하는 layer를 정의합니다. Foundation으로부터 정의된 클래스, 프로토콜, 데이터 자료형들은 macOS, iOS, watchOS, tvOS SDKs의 모든 범위에서 사용됩니다.      Codable conformance   Codable은 데이터 파일과 structure사이에서 데이터를 이동시키는 것을 더 쉽게 만들어줍니다.   JSON data를 가져오는 메서드 생성하기     //  ModelData.swift    import Foundation    func load&lt;T: Decodable&gt;(_ filename: String) -&gt; T {       let data: Data // Data protocal? Data..structure type? 뭔데?        guard let file = Bundle.main.url(forResource: filename, withExtension: nil)       else {           fatalError(\"Couldn't find \\(filename) in main bundle.\")       } // else문        do {           data = try Data(contentsOf: file)       } catch {           fatalError(\"Couldn't load \\(filename) from main bundle.\") // main bundle이 뭐야?       } // catch문        do {           let decoder = JSONDecoder()           return try decoder.decode(T.self, from: data)       } catch {           fatalError(\"Couldn't parse \\(filename) as \\(T.self):\\n\\(error)\")       }   }  Bundle   Bundles는 macOS와 iOS에서 사용되는 코드와 resource를 캡슐화하기 위해 사용되는 기술입니다. 개발자가 필요로하는 resource의 위치를 제공함으로써 개발을 단순화 해줍니다. Bundles는 디렉토리와 파일을 사용합니다. Binary files 보다 더 쉽고 개발 과정이나 배포후에도 쉽게 수정할 수 있습니다.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift"],
        "url": "/til/list-and-navi/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "JavaScript: 팝업창 가운데에 띄우기",
        "excerpt":"아무런 설정을 하지 않고 window.open() 메서드를 사용해서 팝업창을 띄웠더니 화면 맨 왼쪽 위에 팝업창이 나타납니다. 이 팝업창을 가운데로 옮겨보았습니다.   도움을 받은 글: How to center a popup window on screen?   1. &lt;head&gt;태그 안에 JS function 작성하기     &lt;!DOCTYPE html&gt;   &lt;html&gt;   &lt;head&gt;     &lt;title&gt;Title of the document&lt;/title&gt;     &lt;script type=\"text/javascript\"&gt;             function login_window(url, title, w, h) {                 var left = (screen.width - w) / 2;                 var top = (screen.height - h) / 2;                 var myWindow = window.open(url, title, 'resizable=yes, width=' + w + ', height=' + h + ', top=' + top + ', left=' + left);             }     &lt;/script&gt;   &lt;/head&gt;  script 태그 안에 자바 스크립트 function을 작성해 줍니다.   저는 로그인하는 팝업창을 띄우는 것이라 function의 이름을 login_window라고 하였습니다. url, title, w, h와 같이 네 개의 파라미터를 작성해 줍니다. 이때는 파라미터의 이름이라 아무 이름이나 적어줍니다.   left, top 변수   두 개의 변수를 만들어 줍니다. 각각의 변수에는 (전체 스크린 한 면의 길이 - 내 팝업창 한 면의 길이) / 2 값이 할당됩니다. 그 값이 내 팝업창의 왼쪽 면의 위치, 위쪽 면의 위치가 됩니다.   window.open() 메서드   window.open() 메서드에 파라미터를 작성해 줍니다. 이때는 function에서 적어주었던 파라미터를 이용합니다. url, title은 똑같이 작성해 주고 resizable은 yes, width에는 function의 파라미터를 통과해서 들어온 w를 사용, height에는 h를 사용합니다. left와 top 변수도 사용합니다.   2. body 태그 부분 작성     &lt;body&gt;     &lt;ul&gt;         &lt;li class=\"signin-btn\" onclick=\"login_window('signin.html', 'Sign in to Otopi', '380', '500')\"&gt;&lt;span&gt;Sign in&lt;/span&gt;&lt;/li&gt;     &lt;/ul&gt;   &lt;/body&gt;  body 부분에 function을 사용할 곳에 function 이름과 파라미터를 사용하여 작성해 줍니다. 제가 만든 웹 페이지에서는 Sign in이라는 리스트를 클릭하면 팝업창이 생성됩니다. 클릭 시 function login_window가 실행됩니다. 파라미터를 통해 팝업창의 url, title, w, h의 크기를 전달합니다. 크기를 작성할 때 px을 적지 않도록 주의해 줍니다.   3. 가운데 정렬된 모습     ","categories": ["TIL"],
        "tags": ["learning","공부 기록","HTML","CSS","JavaScript"],
        "url": "/til/popup-center/",
        "teaser": "/assets/images/main_octopi.png"
      },{
        "title": "Playgrounds",
        "excerpt":"Playgrounds: Learn to Code 1  아래 모든 내용들은 Playgrounds에서 학습하며 정리한 내용입니다.    모든 내용의 출처는 Playgrounds임을 밝힙니다.   Function: Grouping Tasks   Function은 여러개의 commands를 하나로 묶어 이름을 붙인 것입니다.    그리고 아무때나 원할 때 호출하여(call) 사용할 수 있습니다.     func tieMyShoe() {     loop()     swoop()     pull()   }      func 키워드 사용   function에 이름을 지어줍니다.   function은 언제나 이름 뒤에 ()를 붙여줍니다.   curly braces(중괄호 { }) 안에 commands를 추가해줌으로써 function이 어떤 기능들을 수행할지 정합니다.   필요할 때 언제든 tieMyShoe() 라는 이름을 사용하여 호출, 사용할 수 있습니다.   Composition   가끔씩 coding problem을 해결하려면 새로운 behavior을 수행하기 위해서 기존의 가지고 있던 commands를 혼합하여 함께 사용해야 할 떄가 있습니다. 이 과정을 compositon이라고 합니다. 원하는 행동을 수행할 command는 없지만 기존의 code를 합침으로써 원하는 행동을 할 수 있게 됩니다. 만약 여러번 같은 compositon을 수행해야 한다면 어떨까요? 그렇다면 여러개의 혼합된 코드를 여러번 사용하게 됩니다. 이럴때는 이 composition을 하나로 묶어 function으로 만들 수 있습니다.   function을 사용하므로써 코드를 간단하게 만들고 복잡한 일도 더 간단하게 처리할 수 있습니다.      반복되는 패턴을 파악합니다.   그 패턴을 function으로 만듭니다.   Decomposition   function 안에 다른 function을 호출할 수 있습니다. 더 큰 문제를 더 작은 조각으로 나누는 과정을 Decomposition이라고 합니다. 작은 일을 처리하는 function을 만들고 다른 funtion안에 그 functions을 사용하므로서 더 큰 문제를 해결하는 것 - 더 큰 문제를 작은 function으로 나누는 것을 Decomposition 이라 합니다.   Decompose a solution across multiple Function   작은 tasks를 해결하는 functions을 이용하는 것은 도움이 됩니다. 이 작은 일을 처리하는 function을 다른 function안에서 호출하므로써 더 큰 task를 해결 할 수 있게 됩니다. 더 작은 function으로 나누는 것은 코드의 가독성도 높여줍니다. 보통 function의 이름은 각 기능을 나타내도록 짓기 때문이죠.   또, 코드를 작성하는 과정을 단순화 시켜줍니다. 더 큰 task를 해결하기 위한 function을 작성한 뒤에는 작은 일을 처리하는 각각의 commands들은 신경쓰지 않을 수 있죠.      작은 명령 패턴을 찾는다.   명령들을 호출하는 function을 만든다.   만들어진 function으로 문제를 해결한다.   앱을 만든다는 것은 엄청나게 많은 작은 문제들의 해결방법을 찾는 것입니다. 작은 문제들의 해결책을 찾은 뒤에 코더들은 그 해결책을 모아 더 큰 문제를 해결합니다.   📖 틈새 영어 단어: Tweak      Tweak the code inside solveRow():     tweak은 작은 변화를 만든다는 뜻입니다.    For loops      ‘for’ 키워드를 사용합니다.   loop가 실행 될 횟수를 적어줍니다.   curly braces 안에 반복할 commands를 적어줍니다.     for eachSeed in 1...4 {     makeHole()     placeSeed()     moveFiveInchesForward()   }   앞서 coding tasks를 분할하기 위해 문제를 해결하며 반복되는 패턴을 function으로 만들어 보았습니다. 이제 loop를 이용하며 한 function을 여러 번 반복해서 호출할 수 있습니다. 어떤 코드를 순서대로 실행하는 것을 반복하는 것입니다. loops를 이용하면 반복해서 해야 할 일을 단순화 시킬 수 있습니다.      먼저 가장 가까이 있는 작은 문제를 해결할 패턴을 찾습니다.   다음 문제에서도 이 패턴이 적용되는지 알아봅니다.   적용이 된다면 반복합니다.   해결할 수 있는 작은 문제에 대한 해결책을 찾고 여러 개의 해결책을 모아 큰 문제를 해결하는 것은 좋은 문제 해결 방법 접근입니다.   Conditional Code   예상할 수 없는 것에 대해 어떻게 계획을 짤까요?    코드 안에서는 if문을 이용하여 각기 다른 조건들에 대한 계획을 짭니다.     if lightIsGreen {     moveForward()   } else {     wait()   }     ‘if’ 키워드를 사용합니다.   참 / 거짓으로 답할 수 있는 조건을 적어줍니다.   조건이 참(true)일 때 실행 할 commands를 if block 안에 적어줍니다.   조건이 false 일 때 실행될 코드는 else를 이용해서 적어줍니다.   메세지가 오’면’ 메세지가 왔다는 알림 소리가 울리고, 사파리는 웬 사이트를 열기 전에 인터넷이 연결되어 있는지 확인합니다. 연결되어 있다’면’ 웹사이트로 이동하죠.   Boolean condition   if - else문에서 if의 Boolean 조건이 true이면 if {} 안의 코드가 실행되고   false이면 else {} 안의 조건이 실행됩니다.     func solveRightSide() {     if isOnGem {       turnLeft()       collectGem()     }   }    for i in 1...2 {     solveRightSide()     moveForward()   }   위와 같은 방식으로도 사용할 수 있습니다. function안에 if문을 작성하고 for문을 이용해서 fuction을 호출하는 방식입니다. 이렇게 하므로써 코드를 재사용할 수 있습니다.   👷‍♂️ 여기까지 정리  Logical Operators   code에서 operator는 action을 보여주는 심볼입니다. 논리연산자는 조건문을 더 명확하게 특정지어줍니다.     &amp;&amp; (AND)                                               (OR)                           ! (NOT)   위의 각 연산자들은 각자의 방법으로 조건문을 변화시킵니다.      AND(&amp;&amp;) 논리 연산자는 모든 조건들이 true일 때만 코드가 실행됩니다.                                   OR(                       ) 논리 연산자는 조건 중 적어도 하나가 true일 때 코드가 실행됩니다.                           NOT(!) 논리 연산자는 조건을 반대로 만듭니다.   While Loops   While loop는 반복할 횟수가 명확히 정해져있지 않을 때 어떤 조건이 true인 동안 { } 안에 작성된 코드를 반복해서 실행합니다. 조건문과 함께 while 반복문을 사용하면 좀 더 다양한 상황에 문제를 해결할 수 있습니다.    때때로 coding problem을 어떻게 해결하는지는 어떤 옵션이 더 낫게 느껴지는지에 따라 정해집니다. coder들은 더 빠른 결과를 내는 해결책, 또는 재사용성이 높은 것이 어떤 것인지 자신의 의견에 기초에 결정하게 됩니다.   코딩에서는 문제와 여러개의 해결책들 중 어떤 것을 선택하는지에 대해 배우는 것이 중요합니다. 때때로 한 문제에 대한 어떤 접근은 다른 것과 비슷하게 문제를 해결하고 어떤 것은 다른 해결책보다 더 효율적이고, 재사용이 가능하고, 많은 상황에 적용 가능하기도 합니다. 적절한 도구(approprite tools)를 결정하는 힘이 길러집니다.   Land of bounty 다시 해보기  더 효율적인 방법 찾아보기   Nesting loops   nest one loop inside another은 루프안에서 다른 루프를 사용하는 것을 의미합니다. 루프 안에서 사용된 루프를 nested loops라고 합니다. 이때 바깥쪽의 루프를 Outer loop 안쪽의 루프는 inner loop라고 합니다. 다양한 상황에서 nested loops를 사용할 수 있습니다.   while loop와 Boolean 타입의 조건을 함께 사용할 때는 조건이 언제가는 false가 되야합니다. 만약 계속해서 true가 되면 무한 반복하는 infinite loop이 되고 이것은 컴퓨터를 멈추게 만들 수도 있습니다.      Algorithms   알고리즘은 규칙의 집합 그리고 그것을 기반으로 한 지시입니다. 예를 들어 네비게이션은 목적지로 가는 가장 빠른 길을 찾는 알고리즘을 이용합니다. 이때 알고리즘은 거리와 평균 속도를 비교하고, 현재의 교통량을 이용하여 가장 짧은 루트를 찾습니다. 알고리즘은 다양한 상황에서 적용 가능합니다.   알고리즘을 코드로 적용하기 전에 pseudocode를 이용하여 먼저 생각해볼 수 있습니다. pseodocode는 코드와 비슷한 형태이지만 진짜 코드는 아닌, 사람이 이해할 수 있는 언어로 만든 코드와 비슷한 구조를 가지고 있는 형태입니다.     navigate around wall {     if a block is on right side {       go forward     } else if blocks are in the front and on the right {       turn left       go forward     } else {       turn right       go forward     }   }   pseudocode의 예시입니다. 진짜 작동하는 코드아니고 알고리즘을 만들기 위해 생각을 코드의 구조로 나타낸 것입니다.   다른 상황에서 동일하게 적용되는 알고리즘을 만드는 것이 코딩의 힘입니다. 다양한 상황에서 문제를 해결하는 프로그램을 만드는 것이죠. 에를 들어 search engine의 algorithms은 우리가 검색한 단어가 무엇이든 원하는 정보를 주기 위해 엄청나게 많은 웹사이트의 정보를 동일한 방식으로 처리합니다.   Playgrounds: Learn to Code 2   Variables   머리로 기억할 수 있는 것보다 더 많은 연락처를 저장한 스마트폰의 연락처 목록을 떠올려 봅시다. Coder는 변수(Variables)라는 컨테이너에 이름을 붙이고   정보를 담습니다. 우리가 수정하기 전까지는 연락처의 정보가 바뀌지 않듯 Variables의 정보는 우리가 변경하기 전까지 스스로 바뀌지 않습니다.     var name = \"Mia\"   var age = \"28\"      var 키워드를 사용합니다.   변수의 이름(name, age)이 필요합니다.   = (assignment operator, the equal sign)은 변수에 값을 할당합니다.   위의 변수 중 name은 String을 담고 있습니다. (“text”)   위의 변수 중 age는 Int(an integer, a whole number)를 담고 있습니다.   📖 틈새 영어 단어: a whole number        whole numbers       0을 포함한 자연수를 말합니다.       0, 1, 2, 3, 4, ....       변수를 할당한 뒤 다른 값을 할당할 수 있지만 자료형은 처음 할당한 값과 같아야 합니다. 만약 처음 String 타입의 자료를 담았다면 그 변수에는 게속해서 String 타입의 자료형을 담아야 합니다.     var age = 28   age = \"twenty-nine\" // 자료형이 다름으로 불가능   incrementing a value   incrementing a value는 현재 값과 비교하여 값을 증가시키는 코딩 패턴입니다.    var myNum = 0   myNum = myNum + 1  variable을에 할당된 수와 비교 연산자를 이용해서 while문의 Boolean 조건을 만들 수 있습니다. incrementing values 하며 반복 횟수 등을 기록할 수 있습니다.   변수 이름 정하기      camelCase: 첫번째 단어는 소문자로 시작 뒤로 이어지는 새 단어들은 대문자로 시작하도록 쓰는 방법입니다.   변수에 담길 값이 무엇인지 알려주는 이름으로 정합니다.   Constant   Constant(상수)는 variable(변수)와 같이 값을 담는 이름 붙인 컨테이너입니다. 하지만 프로그램이 실행되는 동안에는 값을 변경할 수 없다는 차이점이 있습니다.      ‘let’ 키워드를 사용합니다.   값이 변경되지 않는다는 것을 아는 경우 상수를 사용합니다.     let numberOfTries = 3   변수의 값과 상수의 값을 비교하는 식의 코드가 자주 사용됩니다.   Compound assignment operator     gemCounter = gemCounter + 1   gemCounter += 1   자료형(Types)   집을 지을 때는 blue print를 사용합니다. Blue print는 거실, 화장실, 침실과 같은 집의 기능들을 보여줍니다. 여러개의 집들을 지을 때 한 blue print를 이용한다면 그 집들은 모두 비슷한 모양으로 지어질 것입니다.    프로그래밍에서 type은 blue print와 같습니다. 그리고 instance는 blue print를 통해 지어진 집과 같습니다.    Blue print는 집의 특징(feature)과 작동 방식(behavior)을 알려줍니다.    Type에서 features는 properties라고 부르고 작동 방식(behavior)는 method라고 합니다.     Features: Color, Bedromms    var color = green   var bedrooms = 2    // property는 타입안에서 변수입니다.    Behaviors: Run Water, Turn on Lights    runWater()   turnLightsOn()    // method는 타입안에서 function입니다.   우리가 만든 여러개의 집중 하나의 차고를 열고 싶다고 가정해봅니다. 먼저 우리는 어떤 집인지 이름을 통해 지정합니다.     myHouse.openGarageDoor()  Swift에서 .(dot notation) 앞부분인 myHouse는 특정한 집을 가리키는 instance입니다.   . 뒷부분은 openGarageDoor()라는 myHouse의 메서드입니다.     bluePortal.isActive() = false  bluePortal이라는 인스턴스의 isActive()라는 메서드가 bluePortal을 켠다고 가정했을 때 ‘= false’는 bluePortal을 끕니다.   Using dot notation syntax   컴퓨터가 이해할 수 있는 코드를 작성하는 규칙을 syntax라고 합니다. Dot notation systax는 아래와 같이 생겼습니다.    greenPortal.isActive = true  Dot notation을 이용하면 특정 instance의 properties의 상태를 변경시킬 수 있습니다. 때때로 프로그램 안에서 여러번 instance의 propert의 상태를 변경해야합니다. greenPortal은 instance의 이름이고 isActive는 greenPortal의 property입니다.   State    State는 어떤 주어진 특정 시간에 변수에 담긴 정보를 말합니다.   instance에 이름을 부여하고 이름으로 그것을 나타내는 것은 프로그램 안에서 인스턴스의 요소들을 이용할 수 있게 해줍니다.   더 효율적인 문제 해결법을 찾는 것은 프로그램이 더 빠르게 작동한다는 것이고 그것은 사용자들이 앱을 사용할 때 행복해진다는 것입니다. 그리고 배터리가 얼만큼 오래 보존되는지와도 관련이 있습니다.   Factoring   코드를 효율적으로 작성하는 방법에 대해 생각해보는 것은 중요합니다. 작동하는 방식을 작은 단위로 나누어 재사용 가능한 function을 작성한다면 전체적으로는 더 적은 라인의 수로 코드를 작성할 수 있습니다. 이런 것을 factoring 코드라고 합니다. factoring the code는 재사용성을 높여줄 뿐 아니라 코드의 가독성을 높여주어 작성자 뿐 아니라 다른 누구든 코드가 어떻게 작성된건지 알아보기 쉽게 해줍니다.   //👷‍♂️ Learn to Code 2: Random Gems Everywhere 다시 풀기   Initialization   Initialization을 통해 instance를 만들 수 있습니다.     let expert = Expert()     let 키워드를 사용하여 constant를 생성합니다.   Type의 이름 + ()를 우측에 작성하여 초기화(Initialize) 합니다.     expert.turnLockUp()  expert라는 instance의 메서드 turnLockUp()을 호출하는 방식입니다. dot notation을 사용합니다. 메서드를 사용하기 위해서는 먼저 Initialize 해주어야 한다는 것을 기억합시다.   여러개의 instances   코드를 작성할 때는 큰 문제를 해결하기 위해 보통 여러개의 instance와 element를 함께 사용하게 됩니다. 만약 사진 편집 앱을 만든다면 이미지를 촬영하기 위해 카메라 앱을, 효과를 적용하기 위해 필터 라이브러리를 사용할 것입니다.   하나 이상의 instance를 사용할 때는 instance의 이름을 사용하여 각 instance의 메서드를 호출합니다.   Parameters   집을 여러가지 색으로 페인트 칠한다고 상상해 봅니다. 그렇다면 색마다 각기 다른 메서드를 만들 수 있겠죠.    paintGreen()   paintBlue()   paintOrange()  만약 초록색 페인트로 세 레이어에 걸쳐 색을 칠하고 싶다면 아래처럼 세번 paintGreen() 메서드를 호출할 수 있습니다.    paintGreen()   paintGreen()   paintGreen()   각 색마다 function을 만들어 사용하  대신에 Parameter를 이용해서 원하는 색을 사용할 수 있습니다.    func paint(color: Color)  color parameter는 function의 input value입니다. 패러미터는 Color와 같은 특정한 Type을 가집니다. function을 호출하면 작동방식 중 사용할 argument를 통과 시킵니다.    func paint(color: Color, layers: 3)  여러개의 패러미터를 가질 수 있습니다.     func move(count: Int) {     for i in 1...count {       moveForward()     }   }  Int Type의 count라는 패러미터를 가진 function move입니다. count는 function의 바디 부분에서 for문이 얼만큼 반복될지를 특정합니다. move function을 호출 시    move(count: 3)  argument 3을 통과시킴으로써 for문을 세번 돌릴 수 있게 됩니다.   여러개의 parameter를 이용하며 function이 동작하는 중 많은 부분을 커스터마이징 할 수 있습니다. 몇 번 반복문을 동작시킬지, Bool타입을 이용한다면 동작을 시킬지 시키지 않을지 등 많은 부분을 원하는대로 특정 지을 수 있습니다.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift"],
        "url": "/til/playgrounds/",
        "teaser": "/assets/images/teaser.jpg"
      }]
