var store = [{
        "title": "만들어 가면서 배우는 JAVA 플레이그라운드(구구단 구현하기 추가미션)",
        "excerpt":"아래 모든 내용은 인프런 강의 ‘만들어 가면서 배우는 JAVA 플레이그라운드’의 내용입니다.   추가 미션 문제      사용자에게 입력 값을 받아서 구구단을 출력   입력값이 11 이라면 2 * 1 부터 2 * 11 까지 ~ 11 * 1 부터 11 * 11 까지 한번에 출력   현재 상황: 11을 입력해서 11 * 1 ~ 11 *11 은 출력할 수 있으나 2,3,4,5,6,7,8,9,10,11 단을 한꺼번에 출력하는 것이 안됨.   import java.util.Scanner;  public class Finalmission {     public static void main(String[] args) {         System.out.println(\"출력할 구구단의 값은? :\");         Scanner scanner = new Scanner(System.in);         int number = scanner.nextInt();          int[] result = new int[number];         for(int j = 2; j &lt;= number; j ++) {         \tfor(int i = 0; i &lt; result.length; i++) {             \tresult[i] = j * (i + 1);             \tSystem.out.println(result[i]);              }         }     } }  ","categories": [],
        "tags": ["code","Java"],
        "url": "/posts/gugudan/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "영단어 정리",
        "excerpt":"  🗂  A      access   to find information, especially on a computer    (주로 컴퓨터에서)정보를 찾는 것      Users can access their voice mail remotely.   whatever thing is accessed by the URL you supply        allow   to make something happen, especially something helpful or useful.    어떤일이 일어나는 것을 가능하게 만들다.        append   to add something to a piece of writing.    글에 어떤 내용을 덧붙이다.      덧붙이다   첨부하다        assign   to give a particular time, value, place etc to something.    특정 시간, 값, 장소등을 어떤 것에게 배정하다. (할당 / 대입하다.)      How much time have you assigned for the meeting?   첨부하다        automate   to start using computers or machines to do a job, rather than people    어떤 일을 하기 위해 사람 대신 컴퓨터나 기계를 사용하다.      Cash machines automates two basic function of a back - deposits and withdrawals.   Build tools are programs that automate the creation of executable applications from source cord.     🗂️  B      bypass   to avoid obeying a rule, system, or someone in an official position.    규칙, 시스템, 공식적인 자리에 있는 사람에게 복종하는 것을 피하는 것      Francis bypassed his manager and wrote straight to the director.   You can bypass basic setup steps that are already familiar to you.     🗂️  C      compatible   if two pieces of computer equipment of software are compatible, they can be used together, especially when they are made by different companies.     소프트웨어에서 사용되는 도구 두가지가 compatible 하다면, 그것은 두가지가 함께 사용될 수 있다는 것을 의미합니다. (특히, 다른 회사에서 만들어진 두가지 도구 일 때 말이죠.)      Will the software on my PC be compatible with a Mac?          configure   to arrange something, especially computer equipment, so that it works with other equipment.    어떤 것을 미리 준비해두다. 특히 다른 도구들과 함께 작동될 수 있도록 컴퓨터 도구들 준비해두다.      This project is configured to fit the exaples in this tutorial.        conform    to obey a law, rule etc 규칙에 순응하다.       An app that uses SwiftUI app life cycle has a structure that conforms to the APP protocol    SwiftUI 앱 라이프 사이클을 사용하는 앱은 그 앱의 프로토콜에 순응하는 구조를 가지고 있다.         consecutive   consecutive numbers or periods of time follow one after the other without any interruptions.    consecutive nunmbers 이나 consecutive peridos of time은 중간에 끊어짐 없이 계속해서 하나의 수가 다른 하나의 수를 따르는 것을 말합니다.      Can they win the title for the third consecutive season?     걔네 삼년 연속으로 우승할 수 있을까?     🗂️  D      define   to describe something correctly and thoroughly, and to say what standards limits qualities etc it has that make it different from other things     어떤 것을 명확히 묘사하는 것, 그리고 그것이 다른 것들과는 다른 어떤 기준, 한계 등을 가지고 있는지 말하는 것.      the ability to define clients' needs     🗂️  E      executable   a computer file that can be run as a program    프로그램으로 실행 될 수 있는 파일.   (명사 / 형용사 둘 다 executable)    🗂️  G      goes a long way towards(to)   If you say that something goes a long way towards doing a particular thing, you mean that it is an important factor in achieving that thing.    something 은 a particular thing 을 달성하기 위한 중요한 요소이다.      Implementing the trends will go a long way to building a functional site.   :: 그 트렌드를 구현하는 것은 잘 작동하는 사이트를 만들기 위한 중요한 요소가 될 것이다.    Although not a cure, it goes a long way towards making the patient's life tolerable.   :: 치료법은 아니지만, 그것은 환자의 삶을 견딜 수 있게 만드는데 큰 도움이 된다.      🗣️ goes a long way towards 발음 들어보기   🗂️  I      invoke   to operate a computer program    컴퓨터 프로그램을 작동시키다.      In small projects, developers often manually invoke the build process          instruction   a command given to a computer to carry out a particular operation.    특정한 일을 수행하기 위해 컴퓨터에게 주어진 명령어.      to put a set of instructions into a computer in a form that it can understand and use.     🗂️  M      manually   operated or done by hand or without the help of electricity, computers etc    기계나 전기의 도움 없이 사람으로부터 수행됨.      It would take too long to do a manual search of all the data.   In small projects, developers often manually invoke the build process        metadata   information that describes what is contained in large computer databases, for example who wrote the information, what it is for, and in what form it is stored    큰 컴퓨터 데이타베이스에 무엇이 저장되어 있는지 알려주는 정보이다. 예를 들면 누가 이 정보를 작성했고, 무엇을 위한 것이고, 어떤 형식으로 저장되었는지에 관한 정보를 알려준다.      Spring Boot Annotations is a form of metadata that provides data about a program.        map onto   to match something or have direct relationship with something    어떤 것을 연결하거나 직접적인 관계를 가지는 것.      Spring Boot Annotations is a form of metadata that provides data about a program.     🗂️  P     protocol   an established method for conneting computers so that they can exchange information    컴퓨터들이 서로 정보를 교환할 수 있는 방법        phase   one of the stages of a process of development or change    개발 또는 변화 중인 절차의 한 단계      a new drug that is in the experimental phase   the first phase of renovation should be done by January     🗂️  R      retrieve   to get back information that has been stored in the memory of a computer    큰 컴퓨터 데이타베이스에 무엇이 저장되어 있는지 알려주는 정보이다. 예를 들면 누가 이 정보를 작성했고, 무엇을 위한 것이고, 어떤 형식으로 저장되었는지에 관한 정보를 알려준다.      Spring Boot Annotations is a form of metadata that provides data about a program.     🗂️  T      transfer   to copy recorded information from one system to another   시스템에 기록된 정보를 다른 시스템에 복사하는 것.      Spring Boot Annotations is a form of metadata that provides data about a program.     🗂️ U     underlying cause/principle/problem etc   the cause, idea etc that is the most important, although it is easily not noticed    알아차리기 힘들지만 가장 중요한 원인이나 아이디어.      the underlying causes of her depression      ","categories": ["vocabularies"],
        "tags": ["studying","learning","vocabularies"],
        "url": "/vocab/verb/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "[20220107] Gradle/Build tools/Building/상속",
        "excerpt":"  오늘의 공부는 Gradle 이 무엇인지 알아보며 시작해본다. Gradle 은 웹 애플리케이션을 만들 때 자동으로 자료들을 모아주고 테스트해주고 빌드해주는 소프트웨어다. ‘a build system’ 또는 ‘a build automation tool’ 이라고 하는데 구글링을 해보니 한국말로도 ‘빌드 도구’ 라고 번역되어 있다. 그렇다면 build tool 은 정확히 무엇일까?   Build tools는 작성된 코드를 응용 프로그램으로 만들어주는 프로그램이라고 한다. 작은 규모의 프로젝트에서는 개발자들이 컴퓨터의 도움없이 이 작업을 하곤 하지만 규모가 큰 프로젝트에서는 컴퓨터 프로그램인 build tools가 이런 작업을 행하는게 실용적이다. Gradle이 이 빌드 도구 중 하나인 것이다   Building한다는 것에는 여러가지 세부 단계들이 포함되어 있고 크게 두가지로 단계로 나누어진다.     compiling : 컴파일링은 사람이 작성한 코드를 컴퓨터가 이해하고 사용할 수 있는 형식으로 바꾸는 것        linking : 링킹은 컴파일링 된 파일들을 하나의 실행 가능한 파일로 만들어주는 것               상속(Inheritance)   스프링 부트를 이용한 게시판 만들기에 관심이 생겨서 글들을 읽어보다가 Gradle이 정확히 무엇인지 궁금해졌었고, 개념만 공부했을때는 와닿지 않았던 상속이 어떤 느낌으로 사용되는지 약간 알게 되었다. 그래서 한번 더 상속에 대해 정리해보려 한다.   자바에서 상속은 한 클래스가 다른 클래스의 속성을 취하는 것이다. 상속을 사용하므로써 우리는 이미 있는 어떤 클래스의 메소드와 필드(변수)를 다시 사용할 수 있다. 객체를 재사용할 수 있다는 점에서 상속은 객체 지향 프로그램에서 중요한 규칙이다.   extends means that you are creating a subclass of the basic class you are extending.    ","categories": ["TIL"],
        "tags": ["software","learning","공부 기록"],
        "url": "/til/gradle/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "[20220111] Spring Boot Annotation/REST resources",
        "excerpt":"  Spring Boot Annotation  스프링 부트 애노테이션은 메타 데이터의 한 타입이다. (메타 데이터는 거대한 데이터베이스 속에 무엇이 들어있는지 알려주는 정보인데, 예를 들면 누가 이 정보를 기록했고, 무엇을 위한 정보이고, 어떤 형식으로 저장되었는지를 알려준다.) 애노테이션은 프로그램에 대한 정보를 보충하기 위해 사용되는데 어플리케이션의 일부는 아니다. 작동하는 코드에 직접적인 영향을 미치지 않는다.  컴퓨터가 이해할 수 있는 주석으로 생각하면 되려나?    REST resources  Spring boot 애노테이션 중 @RestController 라는 것이 있었고 이것을 사용하면 RESTful한 web services 를 만들 수 있다라고 하여 REST란 무엇인지 검색해보고 있다.  검색 중 stack overflow 에 What are REST resources? 라는 질문글을 읽어보게 됐는데 질문자의 ‘REST resources에 관한 몇개의 글을 읽어봤지만 글들이 너무 추상적이어서 오히려 전보다 더 헷갈림’이라는 말에 크게 공감했다. 답변자 중 한명은 ‘REST resources에 관한 글들이 추상적인 이유는 REST resource 라는 개념이 추상적이기 때문’이라고 했다.  여러명의 답변을 정리해보자면,     “whatever thing is accessed by the URL you supply”  그게 무엇이든 네가 제공한 URL 로 찾을 수 있는 정보   A resource is anything that’s important enough to be referenced as a thing in itself.  resource 는 ‘어떤 것’이라고 부를 수 있을만한 그 어떤 것이든 될 수 있다.   Data responded back are the resources  요청해서 받은 데이터가 resources 다.   흠… 감이 오는 것 같기도..? 몇개 더 읽어봐야겠다.  ","categories": ["TIL"],
        "tags": ["software","learning","공부 기록"],
        "url": "/til/annoation/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "[20220113] Java Container/Content pane/Classes and Objects",
        "excerpt":"  💭  국비 Java 학원 수업 개강일이 얼마 남지 않았다. 지금까지는 JAVA에 대해 예습해보았고 커리큘럼에 있는 다른 것들도 미리 한번씩 봐두면 좋을 것 같아서 담당자님께 설명 들었던 것을 떠올리며 커리큘럼을 보고 있다. Java GUI에 대해서는 한번도 알아본적이 없는 것 같아서 검색해 보던 중 코드를 작성하며 정리해주신 블로그를 발견했다. 코드와 설명을 적어주셔서 참고하며 공부해보고 있다.   Java Swing 에서 Container 란?  하나의 컨테이너는 여러개의 레이어들을 가지고 있다. 레이어를 \b컨테이너를 덮고 있는 투명한 필름이라고 생각할 수 있다. Java Swing에서 objects를 담기 위해 사용되는 이 레이어를 content pane이라고 한다.      content pane = container 속 layer    Container가 가지고 있는 content pane layer에 objects가 추가된다. getContentPane() 메소드가 컨텐트 페인 레이어를 불러온다. 그러면 objects를 그 안에 추가할 수 있다.   컨텐트 페인을 구글링해보았더니 아래와 같은 사진들이 나온다. pane의 사전적 의미는 창문이나 문에 쓰이는 유리의 한 조각이다. 사전적 의미를 함께 떠올리면 좀 더 이해하기가 쉽다.      Constructor in Java  생성자에 대한 몇개의 강의도 듣고, 생성자를 만들어보기도 했지만 왜 생성자를 사용하는지 궁금하다. (분명히 예전에 강의를 봤는데 기억이 안난다😵;)  생성자(Constructor)는 코드의 집합인데, new 연산자를 통해 클래스 안의 객체의 상태를 초기 설정 하는데 사용되며 메소드와 비슷하다.   Java Classes and Objects  이 페이지를 번역하며 공부  클래스(classes)와 객체(objects)는 자바에서 가장 중요한 개념이다. Java의 모든 것들은 클래스, 그리고 객체와 관련되어있다. attributes, methods도 마찬가지다. 예를 들어보자, 현실 세계에서 자동차는 객체다. 자동차는 색, 무게와 같은 속성(attributes)을 가지고 있다. 또 자동차는 움직이고 멈추는 메소드도 가지고 있다. (메소드를 어떻게 번역하면 좋을까? 기능? 작동방식?) 클래스는 자동차를 만드는 사람이나 회사 또는 청사진으로 비유된다.      Creat an Object     자바에서 객체는 클래스로부터 만들어진다.  public class Main {                 //클래스 이름은 항상 대문자로 시작   int x = 5;    public static void main(String[] args) {     Main myObj = new Main();       // 클래스명 + 오브젝트명 설정 = new 연산자 + 클래스명();     System.out.println(myObj.x);   }  }   Java this Keyword  이 페이지를 번역하며 공부   public class Point {   public int x = 0;   public int y = 0;    //생성자 Constructor   public Point(int a, int b) {     x = a;     y = b;   } }  위의 작성된 코드를 보면, class … (다음에 계속)  public class Point {   public int x = 0;   public int y = 0;    //생성자 Constructor   public Point(int x, int y) {     this.x = x;     this.y = y;   } }  ","categories": ["TIL"],
        "tags": ["software","learning","공부 기록"],
        "url": "/til/javaGui-copy/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Java this Keyword / MySQL 데이터베이스 삭제하기 / ORM",
        "excerpt":"  💭  벌써 1월 14일이라니 시간이 참 빠르다. 오늘은 어제 알아보던 것에 이어서 Java this keyword를 보면서 시작해본다.   Java this Keyword  이 페이지를 번역하며 공부    &lt;Using this with a Field&gt;   this keyword를 사용하는 가장 흔한 이유는 field(필드변수)의 이름이 메소드 패러미터나 생성자 패러미터와 같을 때 덮어씌여지는 것을 방지하기 위해서이다. 아래 두 예제는 이름이 Point 인 클래스를 만드는 두가지 방법을 보여준다.   public class Point {   public int x = 0;   public int y = 0;    //생성자 Constructor   public Point(int a, int b) {     x = a;     y = b;   } }  위의 작성된 코드에서는 fields의 이름이 각각 x, y이고 생성자 패러미터는 각각 a, b 이다. 두가지의 이름이 다르기 때문에 문제가 생기지 않는다.   public class Point {   public int x = 0;   public int y = 0;    //생성자 Constructor   public Point(int x, int y) {     this.x = x;     this.y = y;   } }  하지만 위 코드에서는 fields 의 이름과 생성자 패러미터의 이름이 같다. 이때 fields 앞에 this. 를 붙여주어야 한다.      MySQL 데이터베이스 삭제하기   터미널을 열고 /usr/local/mysql/bin/mysql -u root -p 을 입력해줍니다. 그리고 비밀번호를 입력해줍니다. (내가 기억하려고 써보는 MySQL 실행시키는 방법)  show databases; 를 입력하면 아래 사진처럼 어떤 데이터베이스들이 있는지 보여줍니다. 저는 example 이라는 이름의 데이터베이스를 삭제할거에요.      DROP DATABASE example 을 입력하면 삭제 됩니다.      Java ORM  이 페이지를 번역하며 공부   Java ORM은 Object-Relational Mapping의 약자로 Java objects와 Relational databases 사이에서 데이터를 변환해주는 기술이다.   public class ContactInfo {   int id;   String name;   String email;  }   위 3가지의 필드를 가지고 있는 ContactInfo라는 클래스가 있다고 가정해보자. 그리고 이 정보들을 MySQL 데이터베이스에 저장하고 싶다. 이때 ORM을 이용해서 어플리케이션의 데이터베이스에 객체들을 담을 테이블을 만들 수 있다. 테이블은 contactinfo라는 이름을 가지게 되고 id, name, email 세개의 열(columns)을 가진다.  ","categories": ["TIL"],
        "tags": ["learning","MySQL","Java","this keyword","ORM"],
        "url": "/til/java-continued/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Accessing Data with JPA",
        "excerpt":"  💭  오늘은 많은 자료들을 봤지만 확실히 이해한 것들은 없는 느낌이다.   Accessing Data with JPA  이 페이지를 참고  package com.example.accessingdatajpa;  import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id;  @Entity //Entity annotation : JPA entity 라는 것을 알려줌. public class Customer {    @Id   @GeneratedValue(strategy=GenerationType.AUTO) //annotate id 필드 - ID가 자동으로 만들어져야 한다는 것을 알려줌.   private Long id; // annotated with @Id - JPA가 이 필드를 ID로 인식함.   private String firstName;   private String lastName; //firstName과 lastName은 unannotated 됨. 같은 이름으로 columns에 mapped 되었다고 여겨짐    // Default constructor 다른 이유없이 JPA를 위해서 존재함. 직접적으로 사용하지 않기 때문에 protedted로 지정.   protected Customer() {}    // 이 생성자를 이용해서 데이터베이스에 저장 될 instances 를 만듬     public Customer(String firstName, String lastName) {     this.firstName = firstName;     this.lastName = lastName;   }   ","categories": ["TIL","공부 기록"],
        "tags": ["software","learning","JPA"],
        "url": "/til/%EA%B3%B5%EB%B6%80%20%EA%B8%B0%EB%A1%9D/go/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "HTTP / 백준 2558번 / Java Abstraction",
        "excerpt":"  💭     백엔드 개발자 로드맵을 보고 각 항목에 관련된 글을 읽어보려 한다.   백준 문제 풀이하며 레벨 올리기!   Java에 대해 공부하기   Domain name resolution  이 페이지를 참고  Domain name resolution은 도메인 이름을 IP 주소로 변환하는 처리 과정을 말한다. 하나의 도메인 이름은 하나의 IP 주소와 연결되고, 하나의 IP 주소는 여러개의 도메인 이름들과 연결될 수 있다. 이것은 여러개의 도메인 이름이 하나의 같은 IP 주소를 가질 수 있는 것을 의미한다.   Application Protocols : HTTP and World Wide Web  이 페이지를 참고  인터넷에서 가장 흔하게 사용되는 서비스 중 하나는 World Wide Web 이다. Web을 작동시키는 응용 프로그램 프로토콜은 HTTP(Hyper Text Transfer Protocol)이다. HTTP를 HTML과 헷갈리지 말자. HTML은 웹 페이지를 작성하는 언어이다. HTTP는 웹 브라우저와 웹 서버가 서로 정보를 교환하기 위해 사용하는 통신 규약이다. HTTP는 응용 프로그램 레벨의 통신규약인데, HTTP가 통신 규약 스택에서 TCP 위에 있고 특정 응용프로그램(웹 브라우저, 웹 서버와 같은)으로부터 이용되기 때문이다.   HTTP는 비연결형 문자 기반 프로토콜이다. 클라이언트(웹 브라우저)가 웹 서버에 이미지, 웹 페이지 등을 요청한다. 클라이언트가 요청한 뒤 이미지나 웹 페이지가 전송 완료되면 클라이언트와 서버 사이의 연결이 끊긴다. 새 요청이 있을 때마다 다시 연결한다. 대부분의 프로토콜은 연결 지향적이다. 이것은 서로 정보를 주고 받고 있는 컴퓨터가 인터넷을 통해 계속해서 연결을 유지한다는 뜻이다. HTTP는 그러지 않다. 클라이언트로부터 HTTP 요청이 이루어지기 전에 먼저 서버와 새롭게 연결이 되어야 한다.   당신이 웹 브라우저에 URL 을 입력할 때 어떤 일이 일어날까?     URL이 도메인 이름을 포함하고 있다면, 브라우저는 먼저 domain name server를 연결합니다. 그리고 도메인 이름에 연결된 IP 주소를 찾아옵니다.   웹 브라우저는 웹 서버와 연결되고 원하는 웹 페이지를 불러오기 위해 HTTP 요청을 보냅니다. (통신 규약 스택을 통해)   웹 서버는 요청을 확인하고 웹 페이지를 확인합니다. 만약 요청으로 들어온 페이지가 있다면, 웹 서버는 페이지를 전송합니다. 만약 서버가 요청 들어온 페이지를 찾을 수 없다면, 서버는 HTTP 404 error 메시지를 보냅니다. (웹서핑을 해본 사람이면 알겠지만 404 는 ‘페이지를 찾을 수 없음’을 의미합니다.)   웹 브라우저가 요청한 페이지를 받으면 연결이 끊어집니다.   그리고 브라우저가 페이지를 분석하며 어떤 요소들(이미지, 작은 응용프로그램들)이 더 필요한지 찾습니다.   브라우저는 필요한 요소들을 가져오기 위해 서버에 새로이 연결하고, 요소들을 요청합니다. (각 요소마다 따로 따로 새 요청을 합니다.)   브라우저가 모든 것들(이미지, 작은 응요프로그램 등)을 가져오면, 브라우저의 윈도우창에 완전한 페이지가 나타납니다.     백준 2588번 문제 풀어보기  2588번 문제   아래 사진은 (세 자리 수) × (세 자리 수) 의 답을 구하는 과정을 보여준다.      (사진의 출처는 백준 사이트의 해당 문제 페이지입니다.)   여기서 (3),(4),(5),(6)에 해당하는 수들을 출력하는 프로그램을 만들면 된다. a = (1), b = (2) 라고 할 때, (3)은  a * (b의 1의 자리수), (4)은  a * (b의 10의 자리수), (5)은  a * (b의 100의 자리수) 이니까 입력 받은 b 를 먼저 각각 하나의 1의 자리 숫자로 쪼개고, 쪼개진 각 수에 a 를 곱해보자고 생각했다. 백의 자리수를 쪼개는 방법을 검색하다 이 페이지 찾았다. 아래 방법으로 숫자를 쪼개서 하나씩 구할 수 있다.   class Main {   public static void main(String[] args) {      int num = 1020;      while (num &gt; 0) {        System.out.println( num % 10);        num = num / 10;        }     }   }   그리고 세시간동안 혼자 생각해보며 (3), (4), (5) 까지는 구했는데 (아래처럼 작성) (6)을 구하지 못하고 답을 찾아봤다. 문제의 레벨을 봤을때 물론 엄청 간단할거라 생각했지만… 길을 잘못 들어도 한참 잘못 들었더라 하하..   import java.util.*;  class Main {     public static void main (String[] args) {         Scanner sc = new Scanner(System.in);         int a, b;         a = sc.nextInt();         b = sc.nextInt();          int[] arr = new int[3];         int[] arr2 = new int[3];          while (b &gt; 0) {         \tfor(int i = 0; i &lt; arr.length; i++) {         \tarr[i] = b % 10;         \tb = b / 10;         \tarr2[i] = a * arr[i]; \t          \tSystem.out.println(arr2[i]);          }      }   }  }                 다른 분이 올린 답을 보고 생각해봅니다.   import java.util.*;  class Main {     public static void main (String[] args) {         Scanner sc = new Scanner(System.in);         int a, b;         a = sc.nextInt();         b = sc.nextInt();          System.out.println(a * (b % 10));         System.out.println(a * ((b / 10) % 10));         System.out.println(a * (b / 100));         System.out.println(a * b);     }  }             패드에 써가면서 생각해보기        Java Abstraction  Abstract Classes and Methods   데이터 추상화는 중요한 세부 정보들은 숨기고 꼭 보여져야하는 정보들만 유저들이 볼 수 있도록 하는 것이다. 데이터 추상화는 abstract classes 나 interfaces를 통해 이뤄질 수 있다. abstract 키워드는 non-access modifier 이다.  아래 표는 Acccess Modifier 와 Non-Access Modifier 를 보여준다.                  Acess Modifiers       Non-Access Modifiers                       private       static                 default or No Modifier       final                 protected       abstract                 public       synchronized                         trasient                         volatile                         strictfp                      Abstract class는 객체를 만들 수 없도록 제한된 클래스이다.            Abstract method는 Abstract class 에서만 사용될 수 있다. abstract methods는 바디 부분이 없다.       abstract class Animal {   public abstract void animalSound(); // public 과 abstract 가 같이 사용되네..?   public void sleep() {     System.out.println(\"Zzz\");   } }   위 코드를 보면 알 수 있듯이, 하나의 abstract class는 abstract method와 일반적인 method 둘다 가질 수 있다.   Animal Obj = new Animal(); // abstract class인 Animal 클래스는 객체를 만들 수 없으므로 에러 발생   Abstract class에 접근하기 위해서는 Abstract class를 상속 받는 subclass를 만들어야 한다.   // Abstract class abstract class Animal {   // Abstract method   public abstract animalSound(); //바디 없음   // Regular method   public void sleep() {     System.out.println(\"Zzz\");   } }  // Animal 클래스를 상속받는 Subclass class Pig extends Animal {   public void animalSound() {     // 위 Abstract 메소드의 바디가 여기서 작성됨     System.out.println(\"The pig says: wee wee\");   } }  class Main {   public static void main(String[] args) {     Pig myPig = new Pig(); // Pig 객체 만들기     myPig.animalSound();     myPig.sleep(); //Pig 객체가 Anmal 클래스를 상속받으므로 sleep 메소드 사용 가능    } }   ","categories": ["TIL"],
        "tags": ["software","learning","공부 기록"],
        "url": "/til/theinternet/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "E-mail / 백준 2884번 문제 풀어보기",
        "excerpt":"  💭     How Does the Internet Work? 라는 글 읽기   백준 문제 풀기   Java   Application Protocols: SMTP and Electronic Mail  많이 사용되는 인터넷 서비스 중 하나는 이메일이다. 이메일은 Simple Mail Transfer protocol 또는 SMTP 라고 불리는 어플리케이션 레벨의 통신규약을 사용한다. SMTP 역시 HTTP와 같은 텍스트 기반의 통신규약이지만 HTTP와 다르게 연결 지향적이다. SMTP는 HTTP보다 더 복잡하다. 더 많은 명령어들과 고려해야 할 사항들이 있다.   우리가 이메일을 읽기 위해 Mail client를 열었을 때 일어나는 일은 다음과 같다.      Mail client(메일을 보내고 열기 위해 메일 서버에 접근하는 프로그램. 맥북이나 아이폰 기본 어플인 Apple mail, Google mail, Microsoft OUtlook 등이 있다.)가 기본 메일 서버에 연결한다. 메일 서버의 IP와 도메인 이름은 보통 메일 클라이언트가 설치 될 때 함께 설정 된다.   메일 서버는 \b자신의 메일 클라이언트가 맞는지 확인하기 위해 언제나 첫번째 메시지를 보낼 것이다.   클라이언트는 SMTP HELO 명령을 전송하고 서버는 250 OK 라는 메시지로 답할 것이다.   클라이언트가 메일을 보내는지, 확인하는지 등의 따라 SMTP 명령을 보낼 것이고 서버는 그에 따라 맞는 답변을 보낼 것이다.   이런 요청/응답 연결은 클라이언트가 SMTP QUIT라는 명령어를 보내기 전까지 계속될 것이다. SMTP QUIT 명령을 받은 서버는 goodbye 라고 응답할 것이고 연결은 끊어진다.      (이거를 메일 클라이언트들이 해준다는 거겠지?)   💭   이 글은 꽤 오래전에 쓰여졌는데 마지막 부분에서 작성자는, 이 글에 쓰여진 인터넷이 작동하는 원리가 얼마나 오래 같은 방식을 유지할 것인가에 대해 물었다. 나도 글을 읽으며 요즘도 이런 방식을 사용하는지 의문이 들기도 해서 최신의 정보도 함께 찾아보면 좋을 것 같다는 생각이 들었다.       백준 2884번 문제 풀기   아침잠이 많아 맨날 지각하는 상근이를 위해 친구 창영이가 아이디어를 던져줍니다. ‘45분 빠르게 알람을 맞춰봐!’ 상근이는 자기가 45분 빠르게 알람을 맞추면 되는데..프로그램을 만들기로 결심했어요. 나중에 개발자가 되려나봐요.🙃   시간과 분을 나타내는 정수 두개를 입력받고 45분 전으로 설정된 시간을 출력하는 문제입니다.   일단 if문 항목에 있는 문제라 if 문을 사용해야 한다는 힌트는 가지고 있습니다.  분(m)으로 입력받은 값 m 이 45보다 크다면 45를 빼서 입력받은 시간과 함께 출력하면 되고 45보다 작다면, m = 60 - (45 - m) 으로 생각하면서 코드를 써봤는데 틀렸다. 이클립스에서는 예제대로 작동하는데 뭔가 잘못된 것 같다. 이 문제에 시간을 많이 써서 답을 찾아보기로! (아래 코드는 내가 작성한 틀린 코드)    import java.util.*;  class Main {     public static void main (String[] args) {         Scanner sc = new Scanner(System.in);         int h, m;         h = sc.nextInt();         m = sc.nextInt();          if(h &gt; 0 &amp;&amp; m &gt;= 45) {           int hour = h;         \tint min = m - 45;         \tSystem.out.println(hour + \" \" + min);         }          if(h &gt; 0 &amp;&amp; m &lt; 45 ) {         \tint hour = h - 1;         \tint min = 60 - (45 - m);         \tSystem.out.println(hour + \" \" + min);         }          if(h == 0 &amp;&amp; m &gt;= 45) {         \tint hour = 23;           int min = m - 45;           System.out.println(hour + \" \" + min);         }          if(h == 0 &amp;&amp; m &lt; 45) {         \tint hour = 23;           int min = 60 - (45 - m);           System.out.println(hour + \" \" + min);         }     }  }    답 구글링을 해보니 정말 간단하게 코드를 작성하셨다. 어떻게 코드를 작성하는지에 대해 생각해보면 좋을 것 같다. 가장 첫번째가 되어야 하는 조건을 구별하는 것을 연습해야겠다. 오늘은 문제 풀이에 시간을 더 쓸 수 없을 것 같아서 내일 한번 더 보고 생각해보기로! 언제나 블로그에 답 남겨주시는 개발자 분들께 감사하며..!  ","categories": ["TIL"],
        "tags": ["software","learning","공부 기록"],
        "url": "/til/email/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "return Keyword in Java / Java statements",
        "excerpt":"  💭     Java   Returning a Value from a Method  이 페이지를 참고   메소드는 아래 상태가 되면 자신을 실행시킨 코드로 돌아온다.     메소드의 모든 statements를 수행했을 때   return statement에 도달 했을 때        throws an exception (covered later),      메소드를 정의할 때 return type을 선언한다. 메소드의 바디에서 값을 받기위해 return statement를 사용한다. void 로 정의된 메소드는 값을 리턴하지 않기 때문에 바디 부분에 return statement를 포함하지 않아도 된다. 포함 할 수도 있는데   Java Statements  이 페이지를 참고   Java statements 는 자바 프로그래밍 언어가 무엇을 해야하는지 지시해주는 것이다. assignment statement는 아래와 같이 값을 변수에 대입시킨다. (할당한다.)   double entryFee = 15.75;   모든 Java statements는 세미콜론(;)으로 끝맺어야한다. Java는 세미콜론까지 정보들을 처리한다. 아래 declaration statement는 전달된 메소드를 이용해서 화면에 정보를 나타나게 한다.   System.out.println(\"Line 1\");  ","categories": ["TIL"],
        "tags": ["software","learning","공부 기록"],
        "url": "/til/copy/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Persist something? ORM과 JPA",
        "excerpt":"  💭   Persist something? Persistence?  이 페이지를 참고     Persistence는 아주 간단히 말하자면 영구적으로 저장(담아 둔다는)한다는 뜻이다. 자바를 이용하면서 우리는 오브젝트의 값을 데이터베이스에 저장한다. ORM은 JPA가 제공하는 표준 규격을 이용해 오브젝트를 데이터 베이스에 담는다. (새 튜플의 형태로) JPA에서 오브젝트들은 Entity로 변환된다. (엔티티는 오브젝트를 데이터 베이스의 테이블로 매핑하기 위해 사용됨)  persisting an entity는 오브젝트(엔티티로 변환된)를 데이터베이스에 영구적으로 저장한다는 뜻이다.   ‘Persist’는 어플리케이션이 종료된 후에도 계속해서 데이터가 남아있는 것을 의미한다. 어플리케이션이 종료되거나 사용자가 세션을 종료하고 새 세션을 시작해도 에전 데이터가 사라지지 않고 계속해서 저장돼있는 것이다.   Implementation  이 페이지에서 가져옴  컴퓨터 공학에서, Implementation(구현)이란 기술적으로 정리해놓은 규격서나 알고리즘을 프로그래밍 혹은 소프트웨어 배치를 통해 프로그램이나 소프트웨어의 부분, 다른 컴퓨터 시스템을 구축하는 것을 말한다. 하나의 규격서나 표준에도 다양한 구현이 있을 수 있다. 예를 들면, 웹 브라우저는 W3C에서 정한 규격서의 구현을 포함하고 있다. 또, 소프트웨어 개발 도구는 프로그래밍 언어의 구현을 포함하고 있다.       JSP (Java Server Pages)  이 페이지를 참고     웹 어플리케이션을 만들기 위해 사용되는 서버 쪽 기술.   동적 웹 컨텐트를 만들기 위해 사용된다.        (이 페이지에서는)     JSP 태그는 Java 코드를 HTML 페이지에 넣기 위해 사용된다.       Servlet Technology의 신식(?) 버전이다. (구글링 해보니 Servlet이 더 빠르지만 코드 작성하고 읽기는 JSP가 더 쉽다고 합니다.)  ","categories": ["TIL","공부 기록"],
        "tags": ["software","learning","JPA","ORM","Persistence"],
        "url": "/til/%EA%B3%B5%EB%B6%80%20%EA%B8%B0%EB%A1%9D/aboutjpa/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "JSP란...? / Tomcat Server & Eclipse로 JSP 작성 후 실행해보기",
        "excerpt":"  💭 ..      자바 웹 개발자 과정 수업을 듣기 시작한지 일주일이 지났다.    자바의 기본적인 문법은 여러가지 온라인 강의를 통해서 예습을 하고 시작했던터라 어렵지 않게 수업을 듣고 있다. 수업 커리큘럼에 JSP가 포함되어 있는데, 아직 JSP가 어떤것인지 잘 몰라서 한번 알아보려고 한다.     요즘 어떤 정보에 대한 글을 읽거나, 기술에 대해 알아보기 전에 '지금도 여전히 사용되는가?' 라는 질문을 먼저 검색해보게 된다. 나의 수준에서는 뭐든 배워두면 도움이 되겠지만, 배울 것은 너무나 많고 시간은 충분하지 않아서 자꾸만 정보의 중요성에 대해 생각해보게 된다. 언제나 새로운 것들이 마구 쏟아지는 지금 같은 시대에는 주로 사용되는 기술들도 빠르게 변한다. 그렇기 때문에 자꾸 위와 같은 질문을 검색해보는 것 같다. 새로운 기술이 언제나 좋은 것은 아니지만 대부분의 경우 새로운 기술이 더 빠르거나, 더 간단하게 복잡한 일을 처리하거나, 전 기술의 단점을 보완해서 나오는 경우가 많이 때문에 새로운 기술들에 대해 더 알고 싶은 것 같다.     JSP에 대해서도 구글링해보니 새로운 프로젝트에는 더이상 사용되지 않는 것 같지만, JSP에 대한 기본적인 것들을 알아두면 도움이 되는 것 같다. 작은 프로젝트를 진행할때는 여전히 사용되기도 하고 예전에 만들어진 어플리케이션들을 살펴봐야 할 수도 있고, 서블릿과 JSP가 자바 웹 개발의 기본적인 것들이라 스프링, hibernate을 배우기 전에 배워야 한다는 의견도 있다. 그리고 나는 지금 듣는 과정중 JSP에 대해 배우게 될 것이고, 테스트도 봐야해서 기본적인 것들을 알아보려고 한다.    🧑‍💻 JSP (Java Server Pages)  이 페이지의 내용을 참고   JSP는 서블릿처럼 웹 어플리케이션을 만드는 것에 사용된다. 서블릿과 같은 일을 하지만 더 많은 기능들을 가지고 있기 때문에 서블릿의 확장된 버전으로 생각해도 되겠다. JSP 페이지는 주로 HTML 태그와 JSP 태그로 이루어진다. (JSP 태그를 이용해서 자바 코드를 HTML 페이지에서 사용할 수 있다.) JSP페이지는 기술 파트와 디자인 파트를 나눌 수 있기 때문에 서블릿보다 유지가 쉽다. Expression Language와 Custom Tags와 같은 부가 기능을 제공하기도 한다.   💡 서블릿과 비교했을 때 JSP의 장점은 무엇이 있을까?          JSP는 서블릿을 확장한 기술이기 때문에 서블릿의 모든 기능들을 사용할 수 있다. implicit objects, predefined tags, expression language 그리고 custom tags와 같은 추가된 기능들을 사용할 수 있다.            JSP는 비즈니스 로직과 프레젠테이션 로직을 쉽게 분리 할 수 있다. 덕분에 JSP는 쉽게 관리 할 수 있다.            JSP 페이지가 수정되었더라도 프로젝트를 다시 컴파일 하거나 디플로이 할 필요가 없다. 서블릿 코드는 바뀐 부분들을 업데이트하고 리컴파일 해야하지만 JSP는 그럴 필요가 없기 때문에 빠르게 개발할 수 있다.            JSP에서는 Action tags, JSTL, Custom tags 등 많은 태그를 이용할 수 있기 때문에 서블릿보다 더 적은 코드 작성을 필요로 한다.       💡 JSP의 Lifecycle   JSP 페이지들은 아래 변화 단계를 따른다.     Translation of JSP Page   Compilation of JSP Page   Classloading (the classloader loads class file)   Instantiation (Object of the Generated Servlet is created).   Initialization (the container invokes jspInit() method).   Request processing (the container invokes _jspService() method).   Destroy (the container invokes jspDestroy() method).      Note!    jspInit(), _jspService() and jspDestroy() 는 JSP의 라이프사이클 메서드.    JSP는 JSP translator의 도움을 받아 서블릿(.java file)으로 변환(변형?)된다.  JSP translator는 JSP 페이지를 서블릿으로 변환하는 웹 서버의 한 부분이다. 서블릿이 된 JSP 페이지는 compiler 에 의해 컴파일 되고 클래스 파일로 변환된다. 서블릿에서 일어나는 모든 프로세스들은 후에 JSP에서 수행된다.   🐈 Tomcat Server &amp; Eclipse로 JSP 작성 후 실행해보기  이 페이지의 내용을 참고   톰캣 서버는 가장 좋은 웹 서버 중 하나이고, 아파치에서 개발한 오픈소스 자바 서블릿 컨테이너이다. 톰캣은 고유의 특징과 빠른 속도, 그리고 J2EE specifications를 실행하는 점 때문에 많은 개발자들이 이용하고 있다.   위 페이지를 참고하며 이클립스와 톰캣을 이용해 JSP 페이지를 만들어본다.           프로젝트 익스플로러에서 마우스 우클릭 New &gt; Dynamic Web project ✅               프로젝트 이름을 입력 &gt; Next ✅               프로젝트 이름을 입력 &gt; Next ✅               Next &gt; finish ✅                  프로젝트 익스플로러에 프로젝트가 만들어진 것을 볼 수 있습니다. ✅               src 위에서 우클릭 &gt; New &gt; JSP File ✅               Next &gt;✅               Finish 버튼 클릭 ✅               JSP 파일이 만들어졌습니다. &lt;body&gt; 부분에 Hello Earth! 를 입력 ✅               프로젝트에서 우클릭 &gt; Run As &gt; 1 Run on Server ✅               Apache &gt; Tomcat 서버 클릭 &gt; Next &gt; Add and Remove 창에서 Finish ✅               자동으로 사파리 창이 뜹니다. \b입력했던 Hello Earth!가 잘 뜨는걸 보니 JSP페이지가 잘 돌아가고 있습니다.          🙋 JSP Syntax 어떻게 작성하는데?      아래 작성된 태그가 .jsp 파일 맨 위에 추가 된다.            &lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;            JSP 페이지는 JSP   ✍️ Scriptlet    JSP scriptlet는 자바 언어로 쓰여진 코드, 변수, 메서드 선언부, 기호, 부호 등을 담을 수 있다.  ","categories": ["TIL"],
        "tags": ["learning","JSP","Java","Tomcat Server","Eclipse IDE"],
        "url": "/til/aboutJSP/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Java 배열 이용하여 정수를 내림차순으로 정렬하기",
        "excerpt":"  💭  입력받아 배열에 저장한 정수를 내림차순으로 정렬하기  (내림차순 - 값이 큰 순서에서 작은 순서로 정렬)   import java.util.Scanner;  public class Main {  \tpublic static void main(String[] args) {       Scanner sc = new Scanner(System.in);     //입력값을 받아 배열의 크기 정하기     System.out.println(\"배열의 크기를 입력하세요. : \");     int[] arr = new int[sc.nextInt()];      //for 문을 이용해 배열에 값 저장하기     for(int i = 0; i &lt; arr.length; i++) {         System.out.println((i + 1) + \"번째 정수 입력\");         arr[i] = sc.nextInt();     }      //내림차순으로 정렬하기      int box = 0;      for(int i = 0; i &lt; arr.length; i++) {         for(int j = i + 1; j &lt; arr.length; j++) {                  if(score[j] &gt; arr[i]) {                   box = arr[i];                        arr[i] = arr[j];                    arr[j] = box;                       }           }         }      //정렬된 배열 출력     for(int i = 0; i &lt; arr.length; i++) {       System.out.println(\"arr[\" + i + \"] : \" + arr[i]);     }     } }      ","categories": ["TIL"],
        "tags": ["learning","Java","Array","Descending order"],
        "url": "/til/decsendingOrder/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Java 추상화(Abstraction)와 메소드 재정의(Overriding)",
        "excerpt":"  💭 ..     자바 웹 개발자 과정 수업 2주차    중간에 연휴가 있어서 일수로는 7일차다.     오늘은 Overriding과 abstract 클래스와 메소드에 대해 배웠다.     강사님의 설명을 들으며 몇주전 abstract 에 대해 혼자 공부했던 기억이 나서 블로그를 보니..     오늘 처음 듣는 것 같았던 것들이 불과 이주전에 글로 써보기까지 했던 것들이었다.     처음엔 '공부를 한거야 만거야?'라고 스스로에게 물었는데 정리해둔걸 보니 '그래도 틀린 것들을 적어둔건 아니었구나 그때는 열심히 했네.'하는 생각이 들었다. 나는 지금 하고 있는 공부, 취업준비가 국비과정이 끝나면 모두 딱! 끝나버릴거라고 생각하지 않는다. 취업은 사실 바로 됐으면 하지만...! (네카라쿠배 바라는거 아니니까ㅋㅋㅋ) 어딜 취업하든 계속해서 아는 것을 넓혀나가야 할 것 같다는 생각이 든다. 배우면 배울수록, 조금씩 더 많이 알아갈수록 왠지 그럴 것 같다는 생각이 든다. 7일차고 어제 잠을 못자서 오후에는 피곤함이 조금 느껴졌는데 그래도 재미있었다. 아직은 자바를 배우고 있어서 그런걸수도..ㅎㅎ 아무튼 그래서 예전에 정리해뒀던거 + 오늘 배운 것들을 함께 정리해보려고 한다.     Let’s get started!  Overriding을 구글에 검색해보니 사전적 의미가 가장 먼저 나온다.      (adj) more important than any other considerations. \b가장 먼저 고려되는…    Overriding methods (메소드 재정의)는 부모 클래스로부터 상속받은 메소드를 자식 클래스가 그대로 사용하지 않고 바디 부분을 변경해서 사용하는 것이다. Overriding 이라는 단어의 사전적 의미 그대로 부모 클래스의 메소드를 override한 자식클래스의 메소드가 가장 중요한 것으로 고려된다. (그러므로 수정된 자식 클래스의 메소드의 기능이 사용된다.) ‘추상화 Abstraction’과  ‘메소드 재정의 Overriding method’는 서로 관련이 있다. 먼저 추상화에 대해서 알아보자.   Java Abstraction  Abstract Classes and Methods 이 페이지를 참고   데이터 추상화는 중요한 세부 정보들은 숨기고 꼭 보여져야하는 정보들만 사용자들이 볼 수 있도록 하는 것이다. 또, 응용 프로그램의 설계 부분과 구현하는 부분을 나누기 위해 사용된다. 추상화는 abstract classes 나 interfaces를 통해 이뤄질 수 있다.  abstract 메소드와 클래스는 책의 목차로 비유하고, override 된 메소드는 내용에 비유해주셨다.   (여기서 abstract 키워드는 non-access modifier 이다.  아래 표는 Acccess Modifier 와 Non-Access Modifier 를 보여준다.)                  Acess Modifiers       Non-Access Modifiers                       private       static                 default or No Modifier       final                 protected       abstract                 public       synchronized                         trasient                         volatile                         strictfp                      Abstract class는 객체를 만들 수 없도록 제한된 클래스이다.  Abstract class를 상속받는 자식클래스를 만들어서 자식클래스를 객체화 할 수 있다.            Abstract method는 Abstract class 에서만 사용될 수 있다. abstract methods는 바디 부분이 없다. (Abstract method만 있으면 interfaces)       코드를 보며 알아보자!   abstract class Animal {   public abstract void animalSound(); //abstract method (바디 없음)   public void sleep() {               // 일반적인 method     System.out.println(\"Zzz\");   } }   위 코드를 보면 알 수 있듯이, 하나의 abstract class는 abstract method와 일반적인 method 둘다 가질 수 있다.   Animal Obj = new Animal(); // abstract class인 Animal 클래스는 객체를 만들 수 없으므로 에러 발생   왜 객체를 만들 수 없는지 생각해보자. 객체는 클래스라는 설계도를 이용해서 만든다. 자동차를 떠올려보자. 자동차를 만들기위해 설계도를 만들었는데 그 중 한 부분이 없어진 것이다. 그렇다면 자동차를 만들 수 있을까? (만들수도 있겠지만ㅎㅎ) 온전한 자동차를 만들 수는 없을 것이다. 메소드는 객체에서 기능 부분을 담당한다. 그런데 자동차의 기능 중 한가지가 빠진것이다. 브레이크나 엑셀이 빠진다면..?  위의 코드를 보고 생각해보자면, Animal이라는 클래스에 animalSound라는 메소드가 텅 비어있는 것이다. 그래서 객체를 만들 수 없는 것이다.   Abstract class에 접근하기 위해서는 Abstract class를 상속 받는 subclass를 만들어야 한다.   // Abstract class abstract class Animal {   // Abstract method   public abstract animalSound(); //바디 없음   // Regular method   public void sleep() {     System.out.println(\"Zzz\");   } }  // Animal 클래스를 상속받는 Subclass class Pig extends Animal {   public void animalSound() {     // 위 Abstract 메소드의 바디가 여기서 작성됨     System.out.println(\"The pig says: wee wee\");   } }  class Main {   public static void main(String[] args) {     Pig myPig = new Pig(); // Pig 객체 만들기     myPig.animalSound();     myPig.sleep(); //Pig 객체가 Anmal 클래스를 상속받으므로 sleep 메소드 사용 가능    } }   ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Java","Abstraction","Overriding in Java"],
        "url": "/til/overriding/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "SQL 정리",
        "excerpt":"  💭     SQL    오늘은 IT국비지원교육 18일차 날이다. 16일간의 자바 여행을 잠깐 마치고 SQL 을 배우기 시작했다.     SQL은 생각보다 어렵지 않아서 자바를 배울 때보다는 편한 마음으로 수업을 듣고 있다.     기본적인 statements들은 많이 사용해 보면 외우게 될 것 같지만 머릿속에서 정리가 덜 된 느낌이라 블로그 글로 정리해 본다.     ⌨️ SQL(Structured Query Language)   SQL(Structured Query Language)은 데이터베이스에 저장된 데이터에 접근하고 조작하기 위해 사용되는 표준 언어다.   ✍️ SQL Statements? 프로그래밍 언어에서 Statements 란?   ✋ 잠깐 Statements가 무엇인지 예시를 보며 알아보자.       System.out.println(\"Hello World\");  -&gt; 자바에서 Hello World를 화면에 출력하는 Statement       Bicycle redBike = new Bicycle();  -&gt; 자바에서 객체를 만드는 Statement         SELECT * FROM Friends;  -&gt; Friends 라는 이름의 테이블의 모든 컬럼을 가져와 보여주는 Statement       SELECT Fname FROM Friends;  -&gt; Friends 테이블의 Fname 컬럼의 정보를 가져와 보여주는 Statement   Statements란 각 프로그래밍 언어의 문법에 맞게 쓰여진 문장으로, 수행되어야 하는 작업을 표현한 문장이라고도 할 수 있겠다.   🤘SQL을 이용해서 데이터 베이스에 테이블을 만들어보자     CREATE TABLE your_table (     column1 varchar2(10) primary key,     column2 number(5) not null,     column3 varchar2(15),     column4 date   );  위의 SQL 쿼리로 테이블을 만들 수 있다. ↓ 아래는 만들어진 테이블. (아직 데이터는 입력하지 않았다.)      🔊run a SQL query    ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Java"],
        "url": "/til/sql/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "프로그래밍에서 Iterations란? / 코딜리티의 open reading material를 읽어보며 for 문에 대해 알아보자.",
        "excerpt":"  🧱     Iterations    30분 작성한 글 날린거 실화냐..     '본격적으로 취업 준비를 해보자!' 하는 생각이 들었고, 블로그의 취직 성공기들을 읽어보다가 코딜리티라는 사이트를 알게 되었다. 리트코드나 프로그래머스는 한번씩 둘러봤는데, 코딜리티는 처음 듣는 곳이라 궁금해져 가입 후 연습문제를 풀기 전 open reading material을 읽어보려고 한다.    첫 레슨은 Iterations에 관한 글입니다.  Open reading material about Iterations 링크    프로그래밍에서 iterating이란 프로그램의 한 부분을 반복하는 것을 말합니다. 이 레슨에서는 Iterations를 수행하는 기초적인 프로그래밍 구조에 대해 알아볼 것 입니다. 바로 “for”과 “while” 반복문(loops)입니다.   ⚙️ For loops   반복문의 구조에 대해 먼저 알아봅시다. 만약 정해진 횟수만큼 반복하는 작업을 하려 한다면, 한 그룹에 속해있는 각각의 요소들에 대해 반복을 수행하려 한다면 for 문을 사용하면 됩니다.   For loop systax    (이 글에서는 python을 기준으로 설명합니다. 그런데 코드가 좀 다른건지.. 글에 적힌대로 VScode에서 실행하니까 에러가 나네요..?)    for some_variable in range_of_values:     loop_body   # 처음 개발 공부를 Python으로 시작했는데 자바만 공부하다보니 많이 어색하네요.  위 for문은 range_of_values의 크기만큼 반복하며 loop body의 내용을 수행합니다. range_of_values의 현재 값은 some_variable의 값에 할당됩니다. 가장 간단한 형태로 아래처럼 작성될 수 있습니다.     for i in range(0, 100):     print i     위 코드는 0부터 99까지의 모든 정수를 출력합니다. 0 ~ 어떤 정수 범위의 반복문 수행은 많이 사용됩니다. (Python list나 배열의 인덱스가 0부터 시작하는 주된 이유입니다.) 아래 반복문은 위의 반복문과 똑같은 값을 출력합니다. 0부터 시작이라면 0은 생략 가능하죠.    for i in range(100):     print i   예시 : 우리에게 양의 정수인 n 이 주어졌습니다. factorial을 구해볼건데요. 예를 들어 factorial 3은 3 * 2 * 1 입니다. factorial n을 구하여 변수 factorial 에 할당해봅시다.    factorial = 1   for i in range(1, n + 1):     # factorial n 의 값을 구할 수 있음     factorial *= i   또 다른 예시 : * 표로 공백으로 띄어진 삼각형을 출력해봅시다. 삼각형은 n 이라는 행을 가지고 있고, n은 양의 정수로 주어집니다. 각 행은 연달아 1, 2, …, n 개의 *을 가지고 있습니다. 예를 들면, n = 4 일때, 아래의 삼각형이 출력되어야 합니다.      *     * *     * * *     * * * *  이 삼각형을 출력하기 위해서는 두개의 반복문이 필요합니다. 하나의 반복문 안에 다른 반복문 하나가 있어야하죠. 바깥쪽의 반복문은 반복될 때마다 각 행을 출력하고 안쪽의 반복문은 반복될 때마다 *(별 asterisk) 하나를 출력합니다.    for i in range(1, n + 1):     for j in range(i):         print ' *',          # 맨날 자바 for문 작성하다가 python 으로 하니까 너무 좋다.     print    # 안쪽 for문의 바디에 해당됨. 개행 역할  (위에서도 잠깐 언급한 것처럼 이 자료의 코드 그대로 VScode에 돌리면 에러가 나네요..? Python이 아닌건가요? 아래 코드로 돌리면 제대로 별이 나옵니다.)    for i in range(1, 5) :     for j in range(i) :         print(' *', end=\"\")     print('')  range function에는 한가지 인자가 더 추가 될 수 있는데, 바로 step 이다. range(10, 0, -1) 은 10, 9, 8, 7, …, 1 까지의 범위를 의미한다. start 값은 10, stop 값은 0, 이 사이를 -1만큼씩 순차적으로 내려온다는 의미가 된다. 이렇게 세개의 인자를 사용할 때는 start 값을 생략할 수 없다.   또 다른 예시 : 이번에는 아래와 같은 삼각형을 출력해 봅시다. n개의 행을 가지고 있는 거꾸로 된 대칭 모양의 삼각형입니다. 각 행은 2n-1, 2n-3, …, 3, 1개의 *을 가지고 있어야 하고 0, 2, 4,…, 2(n-1)만큼의 공백을 가지고 있어야 합니다. 예를들어 n = 4인 삼각형은 아래처럼 출력되어야 합니다.    * * * * * * *     * * * * *       * * *         *  이 예제에서 우리는 세개의 반복문을 사용합니다. 하나의 바깥쪽 반복문과 두개의 안쪽 반복문입니다. 바깥쪽 반복문은 반복할때마다 하나의 행을 출력합니다. 첫번째 안쪽 반복문은 공백을 출력하고 두번째 안쪽 반복문은 *을 출력합니다.    for i in range(n, 0, -1) :     for j in range(n - i) :       print ' ',     for j in range(2 * i - 1) :       print ' *'     print    위의 코드로 별을 출력해보면 (출력되도록 print 부분을 수정하더라도) 공백을 찍는 부분의 식이 좀 잘못되어 있는 같다. 이 예제의 두번째줄이 공백을 출력하는 부분인데 n = 4 일때 (n-i)로 공백을 출력하게 되면 0, 1, 2, 3개의 공백을 출력하게 된다. 예제에서 출력되어야 하는 공백의 수는 0, 2, 4 이다.    만약 별과 별 사이에 공백이 없다면 위의 코드가 맞는데,, 내가 파악하지 못한 부분이 있는걸까?  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","python","코딜리티"],
        "url": "/til/Iterations/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "오라클 클라우드 DB와 자바 연결하기",
        "excerpt":"  💭 ..     맥북 유저에게 국비 수업이란...?    처음 국비 수업을 듣기로 결심했을 때 가장 걱정이 되었던 것은 나에겐 Windows 운영체제를 사용하는 랩탑이 없다는 것이었다. 국비 수업은 Windows를 기준으로 진행되기 때문에 문제가 생기면 강사님의 도움을 받기가 쉽지 않다. 수업 전 진행된 오티에서 강사님은 되도록이면 Windows를 사용할 것을 권했다. 나는 macOS를 사용한 지 오래되었고, 국비 수업을 듣기 전 독학하며 구글링 실력을 꽤 키웠다고 생각했기 때문에 굳이 Windows 운영체제의 랩탑을 구하려고 하지 않았다. 내가 혼자 해결할 수 있을 거라는 원인 모를(ㅎㅎ) 자신감이 있었다.  이클립스 IDE나 Java는 이미 설치해서 사용하고 있었기 때문에 수업 중 설치하는 시간에 문제가 없었다. 그 후로 쭉 문제없이 수업을 잘 들었다. 작은 에러들은 구글링으로 해결할 수 있었다. 그러던 중 데이터베이스에 대해 배우는 주가 시작되었다. 국비 수업이 시작되기 전, 수업에 대한 정보들을 검색해 보던 중 m1 칩 맥북은 오라클을 사용할 수 없다는 것을 알게 되었고 아래 도움이 된 글 목록 중 첫 번째에 있는 블로그 글을 보고 미리 오라클 클라우드에 가입 후 DB를 생성하고 SQL Developer와 연동은 해둔 상태였다. 하지만 당시에는 DB와 Java를 연결하려면 JDBC를 이용해야 한다는 것을 몰랐다. DB와 Java를 연결하는 수업이 시작되었고 많은 분들이 JDBC driver를 다운로드하고 연결하는 과정에 어려움을 겪었다. 나도 다르지 않았다.  아무것도 모르던 4개월 전, 깃헙 페이지로 개발 블로그를 만들려고 구글링을 하며 오랜 시간을 삽질했던 때가 있었다. 그때는 한 가지 문제를 해결하려고 3일, 4일을 구글링하고도 원하는 답을 찾지 못할 때도 있었다. 그때의 기억이 떠올라서 식은땀이 쫙 났다.      'DB와 자바를 연결하지 못하면 수업을 듣기 힘들 텐데 어쩌나.. 밤을 새워서라도 해야겠다.'  라고 생각하고 있었는데 다행히 벌써 많은 분들이 애플 실리콘칩 맥북 + 오라클 클라우드 DB를 연동하는 방법에 대한 블로그 글을 올려주셨고 덕분에 생각보다 빠르게 해결할 수 있었다. 수업이 끝나기 전에 연결이 잘 되어서 엄청 기쁘고 다행이라는 생각이 들었다.     다음에 또 필요할 때를 대비해 기록을 남겨둔다. 국비 수업을 들으려는 다른 macOS 유저들에게도 조금이나마 도움이 되길 바란다.    🔦 도움이 된 글  1. Apple Silicon m1 맥북에서 Oracle Database 사용하기  2. Apple Silicon) M1 으로 oracle&amp;eclipse 연동하기 (3)  3. okky 쿠잉님 댓글   JDBC의 역할   JDBC는 DB와 Java를 연결해 주는 API입니다. 자바 언어로 작성한 코드로 데이터 베이스에 접근하고 여러 가지 데이터 작업을 수행할 수 있게 되죠. 예를 들면, 이클립스에서 몇 가지 자바 클래스와 메서드 그리고 SQL 문을 사용하여 직접 DB에 접근해 데이터를 검색, 추가, 삭제, 수정할 수 있게 되는 것입니다.   SQL Developer를 이용해 테이블 만들기   먼저 저는 SQL Developer를 이용하여 오라클 클라우드 DB에 테이블을 하나 만들어 주었습니다. 테이블 이름은 stardew_valley 입니다.                          VNAME       ADDRESS       AGE                       1       Gus       The Stardrop Saloon       48                 2       Abigail       Pierres General Store       24                 3       Sebastian       24 Mountain Road       26               코드로 보자!   그리고 자바 코드를 작성하여 테이블의 값들을 검색해보겠습니다.   먼저 작업하고 있는 Java project에 ojdbc8.jar를 추가합니다. 위 도움을 받은 글 목록 중 두번째 블로그 글을 보면 꼭 ojdbc8.jar을 받아야 한다고 하셨는데요. 저도 처음에 다른 버전으로 받았다가 제대로 실행되지 않는 문제를 겪었습니다.   import java.sql.*;  public class Jdbc_test {   public static void main(String[] args) {      String url = \"jdbc:oracle:thin:@데이터 베이스 이름_high?TNS_ADMIN=전자지갑 압출 풀어준 폴더의 경로\";     String userid= \"데이터베이스 userid\"; // 변경하지 않았다면 admin     String pwd = \"데이터베이스 접속 비밀번호\"; // DB 생성 시 지정했던 비밀번호       try{        // 오라클 드라이버 로딩       Class.forName(\"oracle.jdbc.OracleDriver\");        // DB에 연결       Connection con = DriverManager.getConnection(url, userid, pwd);        // sql문 작성 - DB에 저장되어있는 테이블에서 모든 레코드 정보 가져오기       String sql = \"select * from stardew_valley\"; // \"\"; 안에 sql문 작성 후 sql 변수에 할당        // 작성한 sql문을 DB로 전달하기 위해 연결       PreparedStatement ps = con.prepareStatement(sql);        // 실행 후 결과값을 ResultSet 타입의 변수에 할당       ResultSet rs = ps.executeQuery();        // 반복문 이용 결과값 출력       while(rs.next()) { // next() 메서드는 값이 있으면 true 반환 -&gt; 값이 없을 때가지 반복         String vname = rs.getString(\"vname\");         String address = rs.getString(\"address\");         int age = rs.getInt(\"age\");          System.out.println(vname + \"\\t\" + address + \"\\t\" + age);        }        // 연결되어있던 객체들 닫아주기       ps.close(); con.close(); rs.close();      } catch(Exception e) {       e.printStackTrace();     }    } }    ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Java","Oracle Cloud","Database"],
        "url": "/til/jdbc/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "깃헙은 왜 기본 브랜치의 이름을 main으로 바꿨을까?",
        "excerpt":"💭     깃헙에 대해 배워가면서 한가지 궁금한 점이 생겼습니다.      블로그로 정보를 찾거나 구글링을 하다 보면 사람들은 레퍼지토리 안에 master 브랜치를 기본으로 가지고 있고,     레퍼지토리를 생성하면 master 브랜치가 생성된다는데. 제가 레퍼지토리를 만들면 언제나 main 이라는 이름의 기본 브랜치가 생성되었거든요.      '내가 뭔가 설정을 잘못한걸까?'하는 생각이 들어 구글링을 하기 시작했습니다.     그러다가 깃헙이 더이상 master branch라는 이름을 사용하지 않는다는 것을 알게되었어요. 왜일까? 궁금해서 이유를 찾아보니     생각보다 더 멋진 이유로 기본 브랜치의 이름을 main으로 바꿨다는 것을 알게 되어서 공유해 봅니다.       왜 깃헙은 master branch의 이름을 main으로 바꾸었을까?  Why GitHub renamed its master branch to main   여기 master branch에서 main branch로의 큰 변화가 일어난 이유가 있다.   시초부터, Git 분산 버전 관리 도구의 기본 branch name은 master로 설정되었다.  모든 깃 repository는 master branch를 가지고 있었다. master branch는 소프트웨어 개발 분야에서 없어서는 안 될 역할을 담당하고 있었다.  많은 프로젝트들에서 master branch는 실제 소스, 즉 모든 테스트를 거친 잘 작동하는 코드라는 것을 의미했다.   하지만 master 라는 용어는 컴퓨터 세계에서나 다른 세계에서나 더 이상 사람들이 좋아하지 않는 용어이다. Git 그리고 Github은 다른 사람들과 다르지 않았다. 2020년 10월 1일부터, 새롭게 생성되는 모든 깃헙의 레퍼지토리는 main 이라는 이름의 기본 branch를 생성한다. 깃헙은 더이상 master라는 기본 브랜치를 생성하지 않는다.  왜 깃헙이 master 브랜치의 이름을 main 브랜치로 바꾸었는지, 그리고 이것이 개발자들에게 어떤 영향을 미칠지 알아보자.   문화적 정서  2020년 여름, 컴퓨터 산업이 master and slave라는 용어를 사용한다는 것이 모두의 주목을 받았다. 많은 시위와 커져가는 사회적 동요 속에서, 이 유해하고 한물간 용어는 더 이상 적합하지 않은 것으로 고려되었다.   Software Freedom Conservancy는 “Conservancy와 Git 프로젝트는 초기 브랜치 이름인 ‘master’가 일부 사람들에게 불쾌감을 준다는 것을 알고 있으며, 그 용어의 사용으로 인해 상처를 입은 사람들에게 공감합니다.”라고 말했다.   사람들이 생각하는 것과는 달리, 깃의 master 브랜치에는 특별한 기능이 없다.  사용자들은 레퍼지토리에 해를 입히지 않고 master 브랜치를 삭제하거나 제거할 수 없다고 생각한다. 이것은 잘못된 사실이다. master 브랜치는 레퍼지토리에 맨 처음 브랜치가 만들어졌을 때 함께 생성된 기본 설정된 이름이라는 점 빼고는 다른 브랜치들과 다른 점이 없다.    master 브랜치를 삭제하거나 이름을 바꾸거나 심지어는 삭제 후에 새로운 master 브랜치를 만들 수도 있다.   깃헙의 이런 변화는 과거의 만들어진 레퍼지토리에는 영향을 주지 않는다. 또한 만약 깃헙 사용자가 master라는 이름의 브랜치를 사용하고 싶다면 사용할 수 있다.  깃헙은 master라는 용어를 금지하는 것은 아니다. 그저 사용을 격려하지 않는 것일 뿐이다.   매사추세츠주 캠브리지에 있는 HubSpot의 수석 설계자인 Whitney Sorenson은 깃헙이 master 브랜치의 이름을 main으로 변경하며 얻을 이점이 한시적으로 겪을 장애물보다 훨씬 크다고 했다. 그는 이러한 변화가 회사 시스템에 차별이 없는 언어를 더하기 위한 보다 큰 내부 계획의 일부라고 말했다. 그의 팀은 또한 whitelist와 blacklist를 allowlist와 blocklist로 교체하고 있다. Sorenson은 이메일로 “지금 이러한 변화를 만드는 것에는 시간이 걸리지만 그건 단지 일회적인 기술적 희생일 뿐, 내부적으로나 외부적으로 모두에 지속적인 영향을 미칠 것이다.”라고 말했다. 또 그는 “우리는 이 일을 장기전으로 보고 있으며, 차별이 없는 언어는 사람과 사람 사이의 소통에서 중요한 만큼 우리가 코딩하고, 그것으로 어떤 것을 구축할 때도 중요하다는 것을 안다.”라고 했다.  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Github","Article"],
        "url": "/til/mastertomain/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "코딜리티의 open reading material을 읽어보며 배열에 대해 알아보자.",
        "excerpt":"  Arrays  Codility / Arrays   배열은 많은 많은 항목들을 한곳에 담기 위해 사용되는 데이터 구조이다. 우리가 쇼핑 리스트와 같은 리스트를 가지고 있다고 상상해 보자. 우리는 쇼핑 리스트의 각 항목들을 한 페이지에 리스트로 작성한다. 하나의 항목을 적기 위해 한 페이지를 사용하지는 않는다. 이때 이 항목들의 리스트를 담고 있는 한 페이지가 한 배열에 비유될 수 있다. 1년 동안의 기온을 기록하려고 계획한다면, 우리는 각 날에 해당되는 365개의 변수를 만들지는 않을 것이다. 대신 한 배열을 만들어 그 안에 담을 것이다.   배열 만들기   우리는 아래와 같이 세 개의 품목을 담고 있는 쇼핑 리스트를 만들려고 한다.  shopping = ['bread', 'butter', 'cheese']   shopping 은 이 배열의 이름이다. 각각의 품목들은 element라고 하고 콤마로 구분된다. 충분한 메모리가 있다 할 때, 배열은 원하는 만큼의 품목을 담을 수 있다. 배열은 또한 품목이 없이 빈 상태로 있을 수 있다.   shopping = []   365일 동안의 기온을 기록한다 할 때, 우리는 그 데이터들을 담을 곳을 먼저 만들 수 있다.  temperatures = [0] * 365  temperatures 라는 이름의 배열에 365개의 0을 담았다.   배열 속 값에 접근하기   배열은 모든 elements에 접근할 수 있는 쉬운 방법을 가지고 있다. 각각의 element(요소)에는 인덱스라는 번호가 배정된다. Index number는 0부터 시작해서 순서대로 나열되는 정수이다. 위의 배열 중 shopping을 보자. shopping = [‘bread’, ‘butter’, ‘cheese’] 중 bread의 인덱스는 0이다. butter의 인덱스는 1이다. cheese의 인덱스는 2이다. 만약 우리가 특정 인덱스 넘버에 어떤 값이 저장되어 있는지 알고 싶다면 shopping[1]처럼 [] 안에 인덱스 숫자를 적어주면 된다. shopping[1]의 값은 butter이다.   배열의 값 수정하기   우리는 배열 속의 값을 따로따로 수정할 수 있다. 각각의 element는 독립적인 변수처럼 새로운 값을 할당받을 수 있다. 예를 들어, 우리가 42일째 되는 날의 기온을 기록하고 싶다고 하자. 기온이 25도였다고 하면,  temperatures[42] = 25  42번째 인덱스에 25라는 값을 할당해 주면 된다.   만약 shopping 배열에 하나의 품목을 더하고 싶다면 아래처럼 작성해 주면 된다.  shopping += ['eggs']  eggs의 인덱스는 3이 된다. (원래 배열의 마지막 인덱스 +1)   배열을 이용해 반복하기   우리는 종종 배열의 모든 elements들을 도는 반복문을 사용합니다. 예를 들면 특정 항목들의 개수를 구해야 할 때 사용될 수 있습니다. N 개의 elements를 가지고 있는 배열이 있다고 합시다. 우리는 순차적으로 인덱스 0부터 N-1까지 반복하며 각각의 요소에 접근할 수 있을 것입니다. len() function을 사용하면 쉽게 배열의 길이를 구할 수 있습니다. shopping 배열의 길이를 구해봅시다.  N = len(shopping)  temperatures 배열을 이용하여 영하였던 날들의 일수를 구해봅니다.  def negative(temperatures):     N = len(temperatures)     days = 0     for i in xrange(N):       if temperatures[i] &lt; 0:           days += 1     return days  xrange는 Python2에서 사용되는 function이라고 하네요. Python3에서도 작동되게 하려면 range()를 사용하면 된다고 합니다.  temperatures 배열의 길이만큼 반복하며 각각의 요소에 접근하고, 각 인덱스의 저장되어 있는 값인 기온이 0보다 낮으면 days 변수에 1씩 누적해서 더해주는 방식이네요.   인덱스를 이용하지 않고 각각의 elements를 이용해서 반복할 수도 있습니다.  for item in array:   ...  자바에도 똑같은 기능을 하는 for-each loop가 있죠!  for(변수 : 배열이름) { ... }            …다음에 계속  ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Arrays"],
        "url": "/til/arrayCo/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "Swift",
        "excerpt":"💭 ..     Swift를 배워보자.    유투브 튜토리얼, 애플 개발자 페이지의 튜토리얼, 구글링을 통해 Swift를 공부해보려고 합니다.        그 과정에서 기록이 필요한 것들을 정리해봅니다.    View에 대해 조사해보자.  애플 공식 문서 중 Declaring a Custom View 를 보며 알아봅니다.   컴퓨터 프로그래밍 분야에서 ‘Declare’는 어떤 의미로 사용될까요? a declaration은 변수와 같은 요소들의 이름과 데이터 타입을 결정하여 컴파일러에게 알려주는 것을 의미합니다. Declaring a Custom View는 Custom View의 이름을 정의하고 데이터 타입을 정하는 것이겠네요. Definition은 변수나 요소가 어디에 저장될지를 정하는 것입니다. (그 어디는 메모리일 가능성이 높겠죠?)   views를 선언(declaring)하는 방법으로 간단하게 user interface를 묘사할 수 있습니다.  a hirarchy에 Text, Image, Button과 같은 뷰들을 선언하므로서 간단하게 user interface를 묘사할 수 있습니다. hirarchy는 계층인데요. VStack 아래에 views들이 있고 view들에는 적용된 modifier들이 있죠 그것들을 하나의 hirarchy라고 하는 것 같습니다. (추론을 통한 뇌피셜;) 이제 SwiftUI가 사용자로부터 받은 input이나 데이터의 변화등에 응답할 view들을 화면에 그리고 업데이트합니다.   SwiftUI가 제공하는 built-in view와 다른 view들을 함께 혼합해서 사용할 수 있습니다. modifier를 이용해서 뷰를 배치하고 data 모델에 연결할 수 있습니다. 그리고 custom view들을 화면에 보여지는 앱 뷰에 놓으면 됩니다.   struct MyView: View { // &lt;- View Protocol 입니다.  }  View Protocol을 따르는 structure를 정의 했습니다.  View protocol은 기능의 청사진을 제공합니다. 이 경우에는 SwiftUI가 화면에 그릴 각 요소들의 작동하는 방식을 제공합니다.   custom view를 view hirarchy에 포함되게 하려면 View protocol이 요구하는 몇가지 사항들을 충족시켜야 합니다.   View protocol의 주요구사항은 body computed property를 꼭 정의해주어야 한다는 것입니다.   …계속됩니다.😎      ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift"],
        "url": "/til/basicSwift/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "A Swift Tour : 디지털 시계 앱을 만들며 스위프트 배워보기",
        "excerpt":"💭 ..     Swift는 어떤 언어일까?    Java를 공부한지 거의 5개월이 지났다. 국비수업 2개월 + 독학 3개월의 과정을 지났다. Java는 첫인상 보다는 매력있고 재미있는 언어였다.   가장 많이 사용되는 프로그래밍 언어 중 하나라 자료가 넘치도록 많다는 장점도 가지고 있다. 그러던 중 친구를 통해 Swift의 존재를 알게되었다.   원래 그 이름은 들어봤지만 Swift가 프로그래밍 언어인지 IDE인지 모를정도로 잘 알지 못했다. 그렇게 Swift에 대한 정보는 '잘 알지 못함'에서 '애플 개발자들이 사용하는 언어'로 승급했다.    신호로 퇴실 처리했습니다 감사합니다   1. 📖  A Swift Tour 공식 가이드를 읽으며 공부합니다.   새로운 프로그래밍 언어를 배울 때, 흔히 첫번째 프로그램으로 “Hello, world!”를 출력하는 프로그램을 만들곤 하죠. Swift에서는 단 한줄로 이 프로그램을 작성할 수 있습니다.    print(\"Hello, world!\")    C 나 Objective-C로 코드를 작성해본 경험이 있다면 이 syntax가 낯설지 않을 것입니다. 스위프트에서 이 한줄의 코드는 완벽하게 한 프로그램입니다. input/output 또는 문자열을 다루기 위해 따로 라이브러리를 추가하지 않아도 됩니다. 전역 범위로 작성된 코드는 프로그램의 시작점으로 사용되므로 main() function 또한 필요하지 않습니다. 각각의 statement의 끝에 세미콜론(;)을 작성하지도 않습니다.   2. 간단한 값들(Simple Values)   상수는 let, 변수는 var를 사용해서 만듭니다. var(변수)에는 다른 값을 다시 할당할 수 있고, let(상수)는 한번 값이 정해지면 바뀌지 않습니다.    var myVariable = 42 myVariable = 50 let myConstant = 42   var, let의 이름 뒤에 : 을 이용해서 데이터 타입을 지정할 수 있습니다. 컴파일러가 할당된 값이 어떤 데이터 자료형을 가지고 있는지 추측할 수 있는 경우에는 자료형을 명시하지 않아도 됩니다.    let implicitInteger = 70 let implicitDouble = 70.0 let explicitDouble: Double = 70    3. The boilerplate code  Intro to SwiftUI: Digital Clock &lt;- 블로그를 보며 공부합니다.   이론만 읽다보니 지루해지기 시작합니다. 지금 가장 만들어보고 싶은 앱은 디지털 시계 앱입니다. 구글링을 해봅니다. 여러개의 친절한 블로그를 발견했는데요. 그 중 하나를 읽어보며 코드 구조를 분석해봅니다.    import SwiftUI  struct ContentView: View {     var body : some View {           Text(\"Hello\")      } }   struct ContentView_Previews: PreviewProvider {     static var previews: some View {         ContentView()      } }   struct는 ContentView라는 이름의 View와 ContentView_Previews라는 이름의 previewProvider를 포함하고 있다.   View : 스크린에 렌더링 될 컨텐트를 담는 컨테이너다. subviews / parent views를 가질 수도 있다. View는 text, buttons, stacks, 그리고 lists 등 어떤 것이든 담을 수 있다.   ContentView 안에 body 변수를 가진다. 뷰 컨텐츠의 배열이 형성되는 곳이다. var body : some View 처럼 some 키워드가 View 앞에 오는데 이것은 body 변수가 뷰의 컨텐츠가 어떤 것이든 View를 return한다는 것을 나타낸다.   4. 현재 날짜와 시간 정보 가져오기    struct ContentView: View {   @State var date = Date() }           ‘@State’ property wrapper는 해당 변수가 모니터링 되고 있다는 것을 의미한다. 만약 변수의 값이 바뀌면 View는 업데이트를 반영한다.            ‘Date()’는 사용자가 있는 지역의 날짜와 시간 정보를 가져오는 initializer이다.        import SwiftUI  struct ContentView: View {     @State var date = Date()      var body: some View {          VStack {              Text(\"\\(date)\")          }     } }   struct ContentView_Previews: PreviewProvider {     static var previews: some View {         ContentView()     } }   시간 정보는 계속해서 바뀌므로 property wrapper인 @State 를 사용해서 바뀐 시간을 계속해서 반영해주고 문자열 date에 escape character ‘'를 추가해서 Date()를 담고 있는 date 변수의 할당되어 있는 문자열을 가져온다.   5. DateFormatter 사용   body variable 아래에 DateFormatter를 사용하는 코드를 작성해봅니다.   var timeFormat: DateFormatter {   let formatter = DateFormatter()   formatter.dateFormat = (\"hh:mm:ss a\")   return formatter }   이 코드를 분석해보자!  timeFormatter는 DateFormatter 객체이다. timeFormatter는 DateFormatter의 메서드를 호출할 수 있다.  dateFormat은 DateFormatter객체의 property이다. 주어진 날짜/시간 데이터에서 우리가 원하는 것만 보여줄 수 있도록 해준다.     소문자 “hh” = 12시간 표기법   대문자 “HH” = 24시간 표기법   “mm” = 분, “ss” = 초   a는 am/pm을 보여준다.   그 다음으로는 가져온 날짜 데이터를 문자열로 바꿔주는 function을 작성해봅니다.  func timeString(date: Date) -&gt; String {   let time = timeFormat.string(from: date)   return time }s   6. Live Time   SwiftUI가 State variable에 일어난 변화들을 감시합니다. @State는 스스로 변화를 만들지는 않습니다.  Date() initializer는 시간의 한 지점을 가져옵니다. 우리가 방금 만든 디지털 시계가 자동으로 흘러가지 않는 이유이죠.   우리가 보는 시계들처럼 초가 흘러가고 60초가 지나면 1분이 늘어나게 만드려면 매초마다 date variable을 새로 고침해주어야 합니다.  그러려면 Timer 객체를 사용하면 됩니다. Timer는 일정 시간이 지나면 특정 메세지를 타겟 객체에 보냅니다. Timer을 설정해주면 SwiftUI가 @State의 변화를 인식하고 그것에 따라 우리의 시계를 업데이트 해줄 것입니다.   Timer 객체를 생성하는 코드를 작성해봅니다.   var updateTimer: Timer {   Timer.scheduledTimer(withTimeInterval; 1, repeats: true,     block: {       self.date = Date()       })   }   scheduledTimer() 메서드를 이용합니다. 첫번째 인자는 withTimeInterval이고 시간의 간격을 입력해줍니다.  두번째는 repeat 입니다. 반복할 것인지 아닌지 bool 타입으로 입력해줍니다.  세번째는 block 입니다. Timer가 반복될 때마다 작동될 코드를 작성해줍니다.   아직은 초마다 시계가 움직이지 않죠? 한 단계가 더 남아있습니다. Text View 아래에 .onAppear modifier을 사용하여 Timer가 스크린에 나타나도록 해줍니다.   Text(\"\\(timeString(date: date))\")   .onAppear(perform: {let _ = self.updateTimer})   .onAppear(perform: action) 은 function modifier 입니다. View가 나타나면 action을 수행합니다. self.updateTimer function은 저장할 필요가 없는 값을 반환하기 때문에 ‘let _‘을 사용했습니다. underscore 는 아무것도 할당하고 싶지 않다는 것을 나타냅니다. 이 스텝까지 잘 마치셨다면 디지털 시계가 초마다 움직이는 것을 볼 수 있을 것입니다!   7. Time of Day Greeting   시간에 따라 달라지는 인사말을 추가해볼 것입니다.     4:00:00am to 11:59:59am -&gt; Morning   12:00:00pm to 4:59:59pm -&gt; Afternoon   5:00:00pm to 8:59:59pm -&gt; Evening   8:00:00pm to 3:59:59am -&gt; Night  위의 기준으로 시간을 나누고 각 시간대의 인사말이 시계 아래에 나타나도록 해봅시다.   func greeting() -&gt; String {         var greet = \"\"          let midNight0 = Calendar.current.date(bySettingHour: 0, minute: 00, second:00, of: date)!         let nightEnd = Calendar.current.date(bySettingHour: 3, minute: 59, second: 59, of: date)!          let morningStart = Calendar.current.date(bySettingHour: 4, minute: 00, second: 0, of: date)!         let morningEnd = Calendar.current.date(bySettingHour: 11, minute: 59, second: 59, of: date)!          let noonStart = Calendar.current.date(bySettingHour: 12, minute: 00, second: 00, of: date)!         let noonEnd = Calendar.current.date(bySettingHour: 16, minute: 59, second: 59, of: date)!          let eveStart = Calendar.current.date(bySettingHour: 17, minute: 00, second: 00, of: date)!         let eveEnd = Calendar.current.date(bySettingHour: 20, minute: 59, second: 59, of: date)!          let nightStart = Calendar.current.date(bySettingHour: 21, minute: 00, second: 00, of: date)!         let midNight24 = Calendar.current.date(bySettingHour: 23, minute: 59, second: 59, of: date)!          if ((date &gt;= midNight0) &amp;&amp; (date &lt;= nightEnd)) {             greet = \"Good Night.\"         } else if (date &gt;= morningStart) &amp;&amp; (date &lt;= morningEnd) {             greet = \"Good Morning\"         } else if ((date &gt;= noonStart) &amp;&amp; (noonEnd &gt;= date)) {             greet = \"Good Afternoon.\"         } else if ((date &gt;= eveStart) &amp;&amp; (eveEnd &gt;= date)) {             greet = \"Good Evening.\"         } else if ((date &gt;= nightStart) &amp;&amp; (midNight24 &gt;= date)) {             greet = \"Good night.\"         }          return greet      }   Calendar.current.date(bySettingHour…) 메서드는 주어진 date 데이터에 특정한 시간을 나타내는 variable을 만듭니다. 여기서는 우리가 위에서 만든 @State date가 주어진 날짜 데이터입니다.   아래 부분은 나누어 놓은 시간대와 현재 시간을 비교하는 부분입니다. 현재 시간과 비교해서 해당되는 인사말을 greet 변수에 담고 반환합니다. 여기까지 하면 시간을 스크린에 띄우는 것은 완성!   … 디지털시계 만들기는 계속 됩니다.    ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift"],
        "url": "/til/basicSwift2/",
        "teaser": "/assets/images/teaser.jpg"
      },{
        "title": "SwiftUI Tutorial: 여러 개의 View를 만들고 결합하기",
        "excerpt":"출처: SwiftUI Essentials: Creating and Combining Views   What I Learned From This Tutorial:      SwiftUI 프레임워크와 다른 프레임워크를 함께 사용하는 방식   여러개의 파일을 하나의 View로 합치기   Stack의 사용법   지도와 관련된 Structures   alignment: .leading   Divider()   Spacer()              // ContentView.swift // Landmarks  import SwiftUI  struct ContentView: View {   var body: some View {      VStack(alignment: .leading) {          Text(\"경복궁\")             .font(.title)             .foregroundColor(.black)          HStack {              Text(\"Gyeongbokgung Palace\")                 .font(.subheadline)             Text(\"Korea\")                 .font(.subheadline)         } // HStack 끝         .font(.subheadline)         .foregroundColor(.secondary)          Divider()         Text(\"About Gyeongbokgung\")             .font(.title2)         Text(\"Gyeongbokgung, also known as Gyeongbokgung Palace or Gyeongbok Palace,         was the main royal palace of the Joseon dynasty.         Built in 1395, it is located in northern Seoul, South Korea.\")             .font(.body)      } // VStack     .padding()   } }  struct ContentView_Previews: PreviewProvider {   static var previews: some View {       ContentView()     } }   ContentView의 body부분에는 뒤에서 MapView()와 CircleImage()가 추가됩니다.   // MapView.swift // Landmarks  import SwiftUI import MapKit  struct MapView: View {     @State private var region = MKCoordinateRegion(         // 경복궁의 위도와 경도         center: CLLocationCoordinate2D(latitude: 37.580_535, longitude: 126.977_341),         span: MKCoordinateSpan(latitudeDelta: 0.05, longitudeDelta: 0.05)         )      var body: some View {         Map(coordinateRegion: $region)     } }  struct MapView_Previews: PreviewProvider {     static var previews: some View {         MapView()     } }   SwiftUI 프레임워크를 추가하고 그 외에 또 다른 프레임 워크를 추가하면,  (여기서는 MapKit라는 프레임워크를 추가했습니다.)  추가된 프레임워크와 관련된 SwiftUI의 특정 기능에 접근할 수 있게 됩니다.   MKCoordinateRegion는 위도, 경도로 표시된 특정 좌표 평면상의 지역을 직사각형의 형태로 가져오는 Structure입니다. 위 코드에서는 가져온 지역 정보를 region이라는 이름의 private state variable에 담았습니다.   center: 와 span:은 파라미터 입니다.  center: 는 가운데 오게 될 지역의 위도, 경도  span: 은 지도가 보여질 크기를 나타내는 horizontal span과 vertical span이 들어올 것입니다.   CLLocationCoordinate2D은 국제 좌표계를 기준으로 특정 지역의 위도 경도를 이용하여 지역 좌표 object를 생성하는 Structure입니다. center: 파라미터를 지나는 값이니 생성된 좌표 object를 중심점으로 사용한다는 뜻이겠죠?   MKCoordinateSpan은 지도로 표현된 지역의 가로와 세로 크기를 표현하는 Structure입니다. delta values를 이용해서 원하는 줌 레벨을 설정할 수 있습니다. delta value이 커지면 줌 레벨은 작아집니다. delta value가 작아지면 줌 레벨을 커지면서 더 가까이 지도를 볼 수 있습니다.   body property의 Map()은 Generic Structure로 사용할 지도 인터페이스를 보여주는 역할을 합니다. 위 코드에는 표현되지 않았지만 사용자의 위치를 보여주거나 이동경로를 추적하는 등의 기능을 합니다.             ","categories": ["TIL"],
        "tags": ["learning","공부 기록","Swift"],
        "url": "/til/landmarks/",
        "teaser": "/assets/images/teaser.jpg"
      }]
